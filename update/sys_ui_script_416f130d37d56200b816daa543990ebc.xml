<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_ui_script">
    <sys_ui_script action="INSERT_OR_UPDATE">
        <active>true</active>
        <description/>
        <global>false</global>
        <name>x_rugl_barcode.angular-1.0.0rc4</name>
        <script>/**&#13;
 * @license AngularJS v1.0.0rc4&#13;
 * (c) 2010-2012 AngularJS http://angularjs.org&#13;
 * License: MIT&#13;
 */&#13;
(function(window, document, undefined) {&#13;
'use strict';&#13;
&#13;
////////////////////////////////////&#13;
&#13;
if (typeof document.getAttribute == $undefined)&#13;
  document.getAttribute = function() {};&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.lowercase&#13;
 * @function&#13;
 *&#13;
 * @description Converts the specified string to lowercase.&#13;
 * @param {string} string String to be converted to lowercase.&#13;
 * @returns {string} Lowercased string.&#13;
 */&#13;
var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.uppercase&#13;
 * @function&#13;
 *&#13;
 * @description Converts the specified string to uppercase.&#13;
 * @param {string} string String to be converted to uppercase.&#13;
 * @returns {string} Uppercased string.&#13;
 */&#13;
var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};&#13;
&#13;
&#13;
var manualLowercase = function(s) {&#13;
  return isString(s)&#13;
      ? s.replace(/[A-Z]/g, function(ch) {return fromCharCode(ch.charCodeAt(0) | 32);})&#13;
      : s;&#13;
};&#13;
var manualUppercase = function(s) {&#13;
  return isString(s)&#13;
      ? s.replace(/[a-z]/g, function(ch) {return fromCharCode(ch.charCodeAt(0) &amp; ~32);})&#13;
      : s;&#13;
};&#13;
&#13;
&#13;
// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish&#13;
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods&#13;
// with correct but slower alternatives.&#13;
if ('i' !== 'I'.toLowerCase()) {&#13;
  lowercase = manualLowercase;&#13;
  uppercase = manualUppercase;&#13;
}&#13;
&#13;
function fromCharCode(code) {return String.fromCharCode(code);}&#13;
&#13;
&#13;
var $boolean          = 'boolean',&#13;
    $console          = 'console',&#13;
    $length           = 'length',&#13;
    $name             = 'name',&#13;
    $object           = 'object',&#13;
    $string           = 'string',&#13;
    $undefined        = 'undefined',&#13;
    Error             = window.Error,&#13;
    /** holds major version number for IE or NaN for real browsers */&#13;
    msie              = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]),&#13;
    jqLite,           // delay binding since jQuery could be loaded after us.&#13;
    jQuery,           // delay binding&#13;
    slice             = [].slice,&#13;
    push              = [].push,&#13;
    toString          = Object.prototype.toString,&#13;
&#13;
    /** @name angular */&#13;
    angular           = window.angular || (window.angular = {}),&#13;
    angularModule,&#13;
    /** @name angular.module.ng */&#13;
    nodeName_,&#13;
    uid               = ['0', '0', '0'];&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.forEach&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Invokes the `iterator` function once for each item in `obj` collection, which can be either an&#13;
 * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`&#13;
 * is the value of an object property or an array element and `key` is the object property key or&#13;
 * array element index. Specifying a `context` for the function is optional.&#13;
 *&#13;
 * Note: this function was previously known as `angular.foreach`.&#13;
 *&#13;
   &lt;pre&gt;&#13;
     var values = {name: 'misko', gender: 'male'};&#13;
     var log = [];&#13;
     angular.forEach(values, function(value, key){&#13;
       this.push(key + ': ' + value);&#13;
     }, log);&#13;
     expect(log).toEqual(['name: misko', 'gender:male']);&#13;
   &lt;/pre&gt;&#13;
 *&#13;
 * @param {Object|Array} obj Object to iterate over.&#13;
 * @param {Function} iterator Iterator function.&#13;
 * @param {Object=} context Object to become context (`this`) for the iterator function.&#13;
 * @returns {Object|Array} Reference to `obj`.&#13;
 */&#13;
function forEach(obj, iterator, context) {&#13;
  var key;&#13;
  if (obj) {&#13;
    if (isFunction(obj)){&#13;
      for (key in obj) {&#13;
        if (key != 'prototype' &amp;&amp; key != $length &amp;&amp; key != $name &amp;&amp; obj.hasOwnProperty(key)) {&#13;
          iterator.call(context, obj[key], key);&#13;
        }&#13;
      }&#13;
    } else if (obj.forEach &amp;&amp; obj.forEach !== forEach) {&#13;
      obj.forEach(iterator, context);&#13;
    } else if (isObject(obj) &amp;&amp; isNumber(obj.length)) {&#13;
      for (key = 0; key &lt; obj.length; key++)&#13;
        iterator.call(context, obj[key], key);&#13;
    } else {&#13;
      for (key in obj) {&#13;
        if (obj.hasOwnProperty(key)) {&#13;
          iterator.call(context, obj[key], key);&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
  return obj;&#13;
}&#13;
&#13;
function sortedKeys(obj) {&#13;
  var keys = [];&#13;
  for (var key in obj) {&#13;
    if (obj.hasOwnProperty(key)) {&#13;
      keys.push(key);&#13;
    }&#13;
  }&#13;
  return keys.sort();&#13;
}&#13;
&#13;
function forEachSorted(obj, iterator, context) {&#13;
  var keys = sortedKeys(obj)&#13;
  for ( var i = 0; i &lt; keys.length; i++) {&#13;
    iterator.call(context, obj[keys[i]], keys[i]);&#13;
  }&#13;
  return keys;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * when using forEach the params are value, key, but it is often useful to have key, value.&#13;
 * @param {function(string, *)} iteratorFn&#13;
 * @returns {function(*, string)}&#13;
 */&#13;
function reverseParams(iteratorFn) {&#13;
  return function(value, key) { iteratorFn(key, value) };&#13;
}&#13;
&#13;
/**&#13;
 * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric&#13;
 * characters such as '012ABC'. The reason why we are not using simply a number counter is that&#13;
 * the number string gets longer over time, and it can also overflow, where as the the nextId&#13;
 * will grow much slower, it is a string, and it will never overflow.&#13;
 *&#13;
 * @returns an unique alpha-numeric string&#13;
 */&#13;
function nextUid() {&#13;
  var index = uid.length;&#13;
  var digit;&#13;
&#13;
  while(index) {&#13;
    index--;&#13;
    digit = uid[index].charCodeAt(0);&#13;
    if (digit == 57 /*'9'*/) {&#13;
      uid[index] = 'A';&#13;
      return uid.join('');&#13;
    }&#13;
    if (digit == 90  /*'Z'*/) {&#13;
      uid[index] = '0';&#13;
    } else {&#13;
      uid[index] = String.fromCharCode(digit + 1);&#13;
      return uid.join('');&#13;
    }&#13;
  }&#13;
  uid.unshift('0');&#13;
  return uid.join('');&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.extend&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Extends the destination object `dst` by copying all of the properties from the `src` object(s)&#13;
 * to `dst`. You can specify multiple `src` objects.&#13;
 *&#13;
 * @param {Object} dst Destination object.&#13;
 * @param {...Object} src Source object(s).&#13;
 */&#13;
function extend(dst) {&#13;
  forEach(arguments, function(obj){&#13;
    if (obj !== dst) {&#13;
      forEach(obj, function(value, key){&#13;
        dst[key] = value;&#13;
      });&#13;
    }&#13;
  });&#13;
  return dst;&#13;
}&#13;
&#13;
function int(str) {&#13;
  return parseInt(str, 10);&#13;
}&#13;
&#13;
&#13;
function inherit(parent, extra) {&#13;
  return extend(new (extend(function() {}, {prototype:parent}))(), extra);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.noop&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * A function that performs no operations. This function can be useful when writing code in the&#13;
 * functional style.&#13;
   &lt;pre&gt;&#13;
     function foo(callback) {&#13;
       var result = calculateResult();&#13;
       (callback || angular.noop)(result);&#13;
     }&#13;
   &lt;/pre&gt;&#13;
 */&#13;
function noop() {}&#13;
noop.$inject = [];&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.identity&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * A function that returns its first argument. This function is useful when writing code in the&#13;
 * functional style.&#13;
 *&#13;
   &lt;pre&gt;&#13;
     function transformer(transformationFn, value) {&#13;
       return (transformationFn || identity)(value);&#13;
     };&#13;
   &lt;/pre&gt;&#13;
 */&#13;
function identity($) {return $;}&#13;
identity.$inject = [];&#13;
&#13;
&#13;
function valueFn(value) {return function() {return value;};}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isUndefined&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is undefined.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is undefined.&#13;
 */&#13;
function isUndefined(value){return typeof value == $undefined;}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isDefined&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is defined.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is defined.&#13;
 */&#13;
function isDefined(value){return typeof value != $undefined;}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isObject&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not&#13;
 * considered to be objects.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is an `Object` but not `null`.&#13;
 */&#13;
function isObject(value){return value!=null &amp;&amp; typeof value == $object;}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isString&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is a `String`.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is a `String`.&#13;
 */&#13;
function isString(value){return typeof value == $string;}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isNumber&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is a `Number`.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is a `Number`.&#13;
 */&#13;
function isNumber(value){return typeof value == 'number';}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isDate&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a value is a date.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is a `Date`.&#13;
 */&#13;
function isDate(value){&#13;
  return toString.apply(value) == '[object Date]';&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isArray&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is an `Array`.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is an `Array`.&#13;
 */&#13;
function isArray(value) {&#13;
  return toString.apply(value) == '[object Array]';&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isFunction&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is a `Function`.&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is a `Function`.&#13;
 */&#13;
function isFunction(value){return typeof value == 'function';}&#13;
&#13;
&#13;
/**&#13;
 * Checks if `obj` is a window object.&#13;
 *&#13;
 * @private&#13;
 * @param {*} obj Object to check&#13;
 * @returns {boolean} True if `obj` is a window obj.&#13;
 */&#13;
function isWindow(obj) {&#13;
  return obj &amp;&amp; obj.document &amp;&amp; obj.location &amp;&amp; obj.alert &amp;&amp; obj.setInterval;&#13;
}&#13;
&#13;
&#13;
function isScope(obj) {&#13;
  return obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;&#13;
}&#13;
&#13;
&#13;
function isFile(obj) {&#13;
  return toString.apply(obj) === '[object File]';&#13;
}&#13;
&#13;
&#13;
function isBoolean(value) {return typeof value == $boolean;}&#13;
function isTextNode(node) {return nodeName_(node) == '#text';}&#13;
&#13;
function trim(value) {&#13;
  return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.isElement&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if a reference is a DOM element (or wrapped jQuery element).&#13;
 *&#13;
 * @param {*} value Reference to check.&#13;
 * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).&#13;
 */&#13;
function isElement(node) {&#13;
  return node &amp;&amp;&#13;
    (node.nodeName  // we are a direct element&#13;
    || (node.bind &amp;&amp; node.find));  // we have a bind and find method part of jQuery API&#13;
}&#13;
&#13;
/**&#13;
 * @param str 'key1,key2,...'&#13;
 * @returns {object} in the form of {key1:true, key2:true, ...}&#13;
 */&#13;
function makeMap(str){&#13;
  var obj = {}, items = str.split(","), i;&#13;
  for ( i = 0; i &lt; items.length; i++ )&#13;
    obj[ items[i] ] = true;&#13;
  return obj;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * HTML class which is the only class which can be used in ng-bind to inline HTML for security&#13;
 * reasons.&#13;
 *&#13;
 * @constructor&#13;
 * @param html raw (unsafe) html&#13;
 * @param {string=} option If set to 'usafe', get method will return raw (unsafe/unsanitized) html&#13;
 */&#13;
function HTML(html, option) {&#13;
  this.html = html;&#13;
  this.get = lowercase(option) == 'unsafe'&#13;
    ? valueFn(html)&#13;
    : function htmlSanitize() {&#13;
        var buf = [];&#13;
        htmlParser(html, htmlSanitizeWriter(buf));&#13;
        return buf.join('');&#13;
      };&#13;
}&#13;
&#13;
if (msie &lt; 9) {&#13;
  nodeName_ = function(element) {&#13;
    element = element.nodeName ? element : element[0];&#13;
    return (element.scopeName &amp;&amp; element.scopeName != 'HTML')&#13;
      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;&#13;
  };&#13;
} else {&#13;
  nodeName_ = function(element) {&#13;
    return element.nodeName ? element.nodeName : element[0].nodeName;&#13;
  };&#13;
}&#13;
&#13;
function isVisible(element) {&#13;
  var rect = element[0].getBoundingClientRect(),&#13;
      width = (rect.width || (rect.right||0 - rect.left||0)),&#13;
      height = (rect.height || (rect.bottom||0 - rect.top||0));&#13;
  return width&gt;0 &amp;&amp; height&gt;0;&#13;
}&#13;
&#13;
function map(obj, iterator, context) {&#13;
  var results = [];&#13;
  forEach(obj, function(value, index, list) {&#13;
    results.push(iterator.call(context, value, index, list));&#13;
  });&#13;
  return results;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @description&#13;
 * Determines the number of elements in an array, the number of properties an object has, or&#13;
 * the length of a string.&#13;
 *&#13;
 * Note: This function is used to augment the Object type in Angular expressions. See&#13;
 * {@link angular.Object} for more information about Angular arrays.&#13;
 *&#13;
 * @param {Object|Array|string} obj Object, array, or string to inspect.&#13;
 * @param {boolean} [ownPropsOnly=false] Count only "own" properties in an object&#13;
 * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.&#13;
 */&#13;
function size(obj, ownPropsOnly) {&#13;
  var size = 0, key;&#13;
&#13;
  if (isArray(obj) || isString(obj)) {&#13;
    return obj.length;&#13;
  } else if (isObject(obj)){&#13;
    for (key in obj)&#13;
      if (!ownPropsOnly || obj.hasOwnProperty(key))&#13;
        size++;&#13;
  }&#13;
&#13;
  return size;&#13;
}&#13;
&#13;
&#13;
function includes(array, obj) {&#13;
  return indexOf(array, obj) != -1;&#13;
}&#13;
&#13;
function indexOf(array, obj) {&#13;
  if (array.indexOf) return array.indexOf(obj);&#13;
&#13;
  for ( var i = 0; i &lt; array.length; i++) {&#13;
    if (obj === array[i]) return i;&#13;
  }&#13;
  return -1;&#13;
}&#13;
&#13;
function arrayRemove(array, value) {&#13;
  var index = indexOf(array, value);&#13;
  if (index &gt;=0)&#13;
    array.splice(index, 1);&#13;
  return value;&#13;
}&#13;
&#13;
function isLeafNode (node) {&#13;
  if (node) {&#13;
    switch (node.nodeName) {&#13;
    case "OPTION":&#13;
    case "PRE":&#13;
    case "TITLE":&#13;
      return true;&#13;
    }&#13;
  }&#13;
  return false;&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.copy&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Creates a deep copy of `source`, which should be an object or an array.&#13;
 *&#13;
 * * If no destination is supplied, a copy of the object or array is created.&#13;
 * * If a destination is provided, all of its elements (for array) or properties (for objects)&#13;
 *   are deleted and then all elements/properties from the source are copied to it.&#13;
 * * If  `source` is not an object or array, `source` is returned.&#13;
 *&#13;
 * Note: this function is used to augment the Object type in Angular expressions. See&#13;
 * {@link angular.module.ng.$filter} for more information about Angular arrays.&#13;
 *&#13;
 * @param {*} source The source that will be used to make a copy.&#13;
 *                   Can be any type, including primitives, `null`, and `undefined`.&#13;
 * @param {(Object|Array)=} destination Destination into which the source is copied. If&#13;
 *     provided, must be of the same type as `source`.&#13;
 * @returns {*} The copy or updated `destination`, if `destination` was specified.&#13;
 */&#13;
function copy(source, destination){&#13;
  if (isWindow(source) || isScope(source)) throw Error("Can't copy Window or Scope");&#13;
  if (!destination) {&#13;
    destination = source;&#13;
    if (source) {&#13;
      if (isArray(source)) {&#13;
        destination = copy(source, []);&#13;
      } else if (isDate(source)) {&#13;
        destination = new Date(source.getTime());&#13;
      } else if (isObject(source)) {&#13;
        destination = copy(source, {});&#13;
      }&#13;
    }&#13;
  } else {&#13;
    if (source === destination) throw Error("Can't copy equivalent objects or arrays");&#13;
    if (isArray(source)) {&#13;
      while(destination.length) {&#13;
        destination.pop();&#13;
      }&#13;
      for ( var i = 0; i &lt; source.length; i++) {&#13;
        destination.push(copy(source[i]));&#13;
      }&#13;
    } else {&#13;
      forEach(destination, function(value, key){&#13;
        delete destination[key];&#13;
      });&#13;
      for ( var key in source) {&#13;
        destination[key] = copy(source[key]);&#13;
      }&#13;
    }&#13;
  }&#13;
  return destination;&#13;
}&#13;
&#13;
/**&#13;
 * Create a shallow copy of an object&#13;
 */&#13;
function shallowCopy(src, dst) {&#13;
  dst = dst || {};&#13;
&#13;
  for(var key in src) {&#13;
    if (src.hasOwnProperty(key) &amp;&amp; key.substr(0, 2) !== '$$') {&#13;
      dst[key] = src[key];&#13;
    }&#13;
  }&#13;
&#13;
  return dst;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.equals&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Determines if two objects or two values are equivalent. Supports value types, arrays and&#13;
 * objects.&#13;
 *&#13;
 * Two objects or values are considered equivalent if at least one of the following is true:&#13;
 *&#13;
 * * Both objects or values pass `===` comparison.&#13;
 * * Both objects or values are of the same type and all of their properties pass `===` comparison.&#13;
 * * Both values are NaN. (In JavasScript, NaN == NaN =&gt; false. But we consider two NaN as equal)&#13;
 *&#13;
 * During a property comparision, properties of `function` type and properties with names&#13;
 * that begin with `$` are ignored.&#13;
 *&#13;
 * Scope and DOMWindow objects are being compared only be identify (`===`).&#13;
 *&#13;
 * @param {*} o1 Object or value to compare.&#13;
 * @param {*} o2 Object or value to compare.&#13;
 * @returns {boolean} True if arguments are equal.&#13;
 */&#13;
function equals(o1, o2) {&#13;
  if (o1 === o2) return true;&#13;
  if (o1 === null || o2 === null) return false;&#13;
  if (o1 !== o1 &amp;&amp; o2 !== o2) return true; // NaN === NaN&#13;
  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;&#13;
  if (t1 == t2) {&#13;
    if (t1 == 'object') {&#13;
      if (isArray(o1)) {&#13;
        if ((length = o1.length) == o2.length) {&#13;
          for(key=0; key&lt;length; key++) {&#13;
            if (!equals(o1[key], o2[key])) return false;&#13;
          }&#13;
          return true;&#13;
        }&#13;
      } else if (isDate(o1)) {&#13;
        return isDate(o2) &amp;&amp; o1.getTime() == o2.getTime();&#13;
      } else {&#13;
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2)) return false;&#13;
        keySet = {};&#13;
        for(key in o1) {&#13;
          if (key.charAt(0) !== '$' &amp;&amp; !isFunction(o1[key]) &amp;&amp; !equals(o1[key], o2[key])) {&#13;
            return false;&#13;
          }&#13;
          keySet[key] = true;&#13;
        }&#13;
        for(key in o2) {&#13;
          if (!keySet[key] &amp;&amp; key.charAt(0) !== '$' &amp;&amp; !isFunction(o2[key])) return false;&#13;
        }&#13;
        return true;&#13;
      }&#13;
    }&#13;
  }&#13;
  return false;&#13;
}&#13;
&#13;
function setHtml(node, html) {&#13;
  if (isLeafNode(node)) {&#13;
    if (msie) {&#13;
      node.innerText = html;&#13;
    } else {&#13;
      node.textContent = html;&#13;
    }&#13;
  } else {&#13;
    node.innerHTML = html;&#13;
  }&#13;
}&#13;
&#13;
function concat(array1, array2, index) {&#13;
  return array1.concat(slice.call(array2, index));&#13;
}&#13;
&#13;
function sliceArgs(args, startIndex) {&#13;
  return slice.call(args, startIndex || 0);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.bind&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for&#13;
 * `fn`). You can supply optional `args` that are are prebound to the function. This feature is also&#13;
 * known as [function currying](http://en.wikipedia.org/wiki/Currying).&#13;
 *&#13;
 * @param {Object} self Context which `fn` should be evaluated in.&#13;
 * @param {function()} fn Function to be bound.&#13;
 * @param {...*} args Optional arguments to be prebound to the `fn` function call.&#13;
 * @returns {function()} Function that wraps the `fn` with all the specified bindings.&#13;
 */&#13;
function bind(self, fn) {&#13;
  var curryArgs = arguments.length &gt; 2 ? sliceArgs(arguments, 2) : [];&#13;
  if (isFunction(fn) &amp;&amp; !(fn instanceof RegExp)) {&#13;
    return curryArgs.length&#13;
      ? function() {&#13;
          return arguments.length&#13;
            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))&#13;
            : fn.apply(self, curryArgs);&#13;
        }&#13;
      : function() {&#13;
          return arguments.length&#13;
            ? fn.apply(self, arguments)&#13;
            : fn.call(self);&#13;
        };&#13;
  } else {&#13;
    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)&#13;
    return fn;&#13;
  }&#13;
}&#13;
&#13;
&#13;
function toJsonReplacer(key, value) {&#13;
  var val = value;&#13;
&#13;
  if (/^\$+/.test(key)) {&#13;
    val = undefined;&#13;
  } else if (isWindow(value)) {&#13;
    val = '$WINDOW';&#13;
  } else if (value &amp;&amp;  document === value) {&#13;
    val = '$DOCUMENT';&#13;
  } else if (isScope(value)) {&#13;
    val = '$SCOPE';&#13;
  }&#13;
&#13;
  return val;&#13;
};&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.toJson&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Serializes input into a JSON-formatted string.&#13;
 *&#13;
 * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.&#13;
 * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.&#13;
 * @returns {string} Jsonified string representing `obj`.&#13;
 */&#13;
function toJson(obj, pretty) {&#13;
  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.fromJson&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Deserializes a JSON string.&#13;
 *&#13;
 * @param {string} json JSON string to deserialize.&#13;
 * @returns {Object|Array|Date|string|number} Deserialized thingy.&#13;
 */&#13;
function fromJson(json) {&#13;
  return isString(json)&#13;
      ? JSON.parse(json)&#13;
      : json;&#13;
}&#13;
&#13;
&#13;
function toBoolean(value) {&#13;
  if (value &amp;&amp; value.length !== 0) {&#13;
    var v = lowercase("" + value);&#13;
    value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');&#13;
  } else {&#13;
    value = false;&#13;
  }&#13;
  return value;&#13;
}&#13;
&#13;
/**&#13;
 * @returns {string} Returns the string representation of the element.&#13;
 */&#13;
function startingTag(element) {&#13;
  element = jqLite(element).clone();&#13;
  try {&#13;
    // turns out IE does not let you set .html() on elements which&#13;
    // are not allowed to have children. So we just ignore it.&#13;
    element.html('');&#13;
  } catch(e) {};&#13;
  return jqLite('&lt;div&gt;').append(element).html().match(/^(&lt;[^&gt;]+&gt;)/)[1];&#13;
}&#13;
&#13;
&#13;
/////////////////////////////////////////////////&#13;
&#13;
/**&#13;
 * Parses an escaped url query string into key-value pairs.&#13;
 * @returns Object.&lt;(string|boolean)&gt;&#13;
 */&#13;
function parseKeyValue(/**string*/keyValue) {&#13;
  var obj = {}, key_value, key;&#13;
  forEach((keyValue || "").split('&amp;'), function(keyValue){&#13;
    if (keyValue) {&#13;
      key_value = keyValue.split('=');&#13;
      key = decodeURIComponent(key_value[0]);&#13;
      obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;&#13;
    }&#13;
  });&#13;
  return obj;&#13;
}&#13;
&#13;
function toKeyValue(obj) {&#13;
  var parts = [];&#13;
  forEach(obj, function(value, key) {&#13;
    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));&#13;
  });&#13;
  return parts.length ? parts.join('&amp;') : '';&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * We need our custom mehtod because encodeURIComponent is too agressive and doesn't follow&#13;
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path&#13;
 * segments:&#13;
 *    segment       = *pchar&#13;
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"&#13;
 *    pct-encoded   = "%" HEXDIG HEXDIG&#13;
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"&#13;
 *    sub-delims    = "!" / "$" / "&amp;" / "'" / "(" / ")"&#13;
 *                     / "*" / "+" / "," / ";" / "="&#13;
 */&#13;
function encodeUriSegment(val) {&#13;
  return encodeUriQuery(val, true).&#13;
             replace(/%26/gi, '&amp;').&#13;
             replace(/%3D/gi, '=').&#13;
             replace(/%2B/gi, '+');&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom&#13;
 * method becuase encodeURIComponent is too agressive and encodes stuff that doesn't have to be&#13;
 * encoded per http://tools.ietf.org/html/rfc3986:&#13;
 *    query       = *( pchar / "/" / "?" )&#13;
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"&#13;
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"&#13;
 *    pct-encoded   = "%" HEXDIG HEXDIG&#13;
 *    sub-delims    = "!" / "$" / "&amp;" / "'" / "(" / ")"&#13;
 *                     / "*" / "+" / "," / ";" / "="&#13;
 */&#13;
function encodeUriQuery(val, pctEncodeSpaces) {&#13;
  return encodeURIComponent(val).&#13;
             replace(/%40/gi, '@').&#13;
             replace(/%3A/gi, ':').&#13;
             replace(/%24/g, '$').&#13;
             replace(/%2C/gi, ',').&#13;
             replace((pctEncodeSpaces ? null : /%20/g), '+');&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-app&#13;
 *&#13;
 * @element ANY&#13;
 * @param {angular.Module} ng-app on optional application&#13;
 *   {@link angular.module module} name to load.&#13;
 *&#13;
 * @description&#13;
 *&#13;
 * Use this directive to auto-bootstrap on application. Only&#13;
 * one directive can be used per HTML document. The directive&#13;
 * designates the root of the application and is typically placed&#13;
 * ot the root of the page.&#13;
 *&#13;
 * In the example below if the `ng-app` directive would not be placed&#13;
 * on the `html` element then the document would not be compiled&#13;
 * and the `{{ 1+2 }}` would not be resolved to `3`.&#13;
 *&#13;
 * `ng-app` is the easiest way to bootstrap an application.&#13;
 *&#13;
 &lt;doc:example&gt;&#13;
   &lt;doc:source&gt;&#13;
    I can add: 1 + 2 =  {{ 1+2 }}&#13;
   &lt;/doc:source&gt;&#13;
 &lt;/doc:example&gt;&#13;
 *&#13;
 */&#13;
function angularInit(element, bootstrap) {&#13;
  var elements = [element],&#13;
      appElement,&#13;
      module,&#13;
      names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],&#13;
      NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;&#13;
&#13;
  function append(element) {&#13;
    element &amp;&amp; elements.push(element);&#13;
  }&#13;
&#13;
  forEach(names, function(name) {&#13;
    names[name] = true;&#13;
    append(document.getElementById(name));&#13;
    name = name.replace(':', '\\:');&#13;
    if (element.querySelectorAll) {&#13;
      forEach(element.querySelectorAll('.' + name), append);&#13;
      forEach(element.querySelectorAll('.' + name + '\\:'), append);&#13;
      forEach(element.querySelectorAll('[' + name + ']'), append);&#13;
    };&#13;
  });&#13;
&#13;
  forEach(elements, function(element) {&#13;
    if (!appElement) {&#13;
      var className = ' ' + element.className + ' ';&#13;
      var match = NG_APP_CLASS_REGEXP.exec(className);&#13;
      if (match) {&#13;
        appElement = element;&#13;
        module = (match[2] || '').replace(/\s+/g, ',');&#13;
      } else {&#13;
        forEach(element.attributes, function(attr) {&#13;
          if (!appElement &amp;&amp; names[attr.name]) {&#13;
            appElement = element;&#13;
            module = attr.value;&#13;
          }&#13;
        });&#13;
      }&#13;
    }&#13;
  });&#13;
  if (appElement) {&#13;
    bootstrap(appElement, module ? [module] : []);&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.bootstrap&#13;
 * @description&#13;
 * Use this function to manually start up angular application.&#13;
 *&#13;
 * See: {@link guide/dev_guide.bootstrap.manual_bootstrap Bootstrap}&#13;
 *&#13;
 * @param {Element} element DOM element which is the root of angular application.&#13;
 * @param {Array&lt;String,function&gt;=} modules an array of module declarations. See: {@link angular.module modules}&#13;
 * @param {angular.module.auta.$injector} the injector;&#13;
 */&#13;
function bootstrap(element, modules) {&#13;
  element = jqLite(element);&#13;
  modules = modules || [];&#13;
  modules.unshift('ng');&#13;
  var injector = createInjector(modules);&#13;
  injector.invoke(&#13;
    ['$rootScope', '$compile', '$injector', function(scope, compile, injector){&#13;
      scope.$apply(function() {&#13;
        element.data('$injector', injector);&#13;
        compile(element)(scope);&#13;
      });&#13;
    }]&#13;
  );&#13;
  return injector;&#13;
}&#13;
&#13;
var SNAKE_CASE_REGEXP = /[A-Z]/g;&#13;
function snake_case(name, separator){&#13;
  separator = separator || '_';&#13;
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {&#13;
    return (pos ? separator : '') + letter.toLowerCase();&#13;
  });&#13;
}&#13;
&#13;
function bindJQuery() {&#13;
  // bind to jQuery if present;&#13;
  jQuery = window.jQuery;&#13;
  // reset to jQuery or default to us.&#13;
  if (jQuery) {&#13;
    jqLite = jQuery;&#13;
    extend(jQuery.fn, {&#13;
      scope: JQLitePrototype.scope,&#13;
      controller: JQLitePrototype.controller,&#13;
      injector: JQLitePrototype.injector,&#13;
      inheritedData: JQLitePrototype.inheritedData&#13;
    });&#13;
    JQLitePatchJQueryRemove('remove', true);&#13;
    JQLitePatchJQueryRemove('empty');&#13;
    JQLitePatchJQueryRemove('html');&#13;
  } else {&#13;
    jqLite = JQLite;&#13;
  }&#13;
  angular.element = jqLite;&#13;
}&#13;
&#13;
/**&#13;
 * throw error of the argument is falsy.&#13;
 */&#13;
function assertArg(arg, name, reason) {&#13;
  if (!arg) {&#13;
    var error = new Error("Argument '" + (name||'?') + "' is " +&#13;
        (reason || "required"));&#13;
    throw error;&#13;
  }&#13;
  return arg;&#13;
}&#13;
&#13;
function assertArgFn(arg, name, acceptArrayAnnotation) {&#13;
  if (acceptArrayAnnotation &amp;&amp; isArray(arg)) {&#13;
      arg = arg[arg.length - 1];&#13;
  }&#13;
&#13;
  assertArg(isFunction(arg), name, 'not a function, got ' +&#13;
      (arg &amp;&amp; typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));&#13;
  return arg;&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc interface&#13;
 * @name angular.Module&#13;
 * @description&#13;
 *&#13;
 * Interface for configuring angular {@link angular.module modules}.&#13;
 */&#13;
&#13;
function setupModuleLoader(window) {&#13;
&#13;
  function ensure(obj, name, factory) {&#13;
    return obj[name] || (obj[name] = factory());&#13;
  }&#13;
&#13;
  return ensure(ensure(window, 'angular', Object), 'module', function() {&#13;
    /** @type {Object.&lt;string, angular.Module&gt;} */&#13;
    var modules = {};&#13;
&#13;
    /**&#13;
     * @ngdoc function&#13;
     * @name angular.module&#13;
     * @description&#13;
     *&#13;
     * The `angular.module` is a global place for creating and registering Angular modules. All&#13;
     * modules (angular core or 3rd party) that should be available to an application must be&#13;
     * registered using this mechanism.&#13;
     *&#13;
     *&#13;
     * # Module&#13;
     *&#13;
     * A module is a collocation of services, directives, filters, and configure information. Module&#13;
     * is used to configure the {@link angular.module.AUTO.$injector $injector}.&#13;
     *&#13;
     * &lt;pre&gt;&#13;
     * // Create a new module&#13;
     * var myModule = angular.module('myModule', []);&#13;
     *&#13;
     * // register a new service&#13;
     * myModule.value('appName', 'MyCoolApp');&#13;
     *&#13;
     * // configure existing services inside initialization blocks.&#13;
     * myModule.config(function($locationProvider) {&#13;
     *   // Configure existing providers&#13;
     *   $locationProvider.hashPrefix('!');&#13;
     * });&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * Then you can create an injector and load your modules like this:&#13;
     *&#13;
     * &lt;pre&gt;&#13;
     * var injector = angular.injector(['ng', 'MyModule'])&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * However it's more likely that you'll just use&#13;
     * {@link angular.module.ng.$compileProvider.directive.ng-app ng-app} or&#13;
     * {@link angular.bootstrap} to simplify this process for you.&#13;
     *&#13;
     * @param {!string} name The name of the module to create or retrieve.&#13;
     * @param {Array.&lt;string&gt;=} requires If specified then new module is being created. If unspecified then the&#13;
     *        the module is being retrieved for further configuration.&#13;
     * @param {Function} configFn Option configuration function for the module. Same as&#13;
     *        {@link angular.Module#config Module#config()}.&#13;
     * @returns {module} new module with the {@link angular.Module} api.&#13;
     */&#13;
    return function module(name, requires, configFn) {&#13;
      if (requires &amp;&amp; modules.hasOwnProperty(name)) {&#13;
        modules[name] = null;&#13;
      }&#13;
      return ensure(modules, name, function() {&#13;
        if (!requires) {&#13;
          throw Error('No module: ' + name);&#13;
        }&#13;
&#13;
        /** @type {!Array.&lt;Array.&lt;*&gt;&gt;} */&#13;
        var invokeQueue = [];&#13;
&#13;
        /** @type {!Array.&lt;Function&gt;} */&#13;
        var runBlocks = [];&#13;
&#13;
        var config = invokeLater('$injector', 'invoke');&#13;
&#13;
        /** @type {angular.Module} */&#13;
        var moduleInstance = {&#13;
          // Private state&#13;
          _invokeQueue: invokeQueue,&#13;
          _runBlocks: runBlocks,&#13;
&#13;
          /**&#13;
           * @ngdoc property&#13;
           * @name angular.Module#requires&#13;
           * @propertyOf angular.Module&#13;
           * @returns {Array.&lt;string&gt;} List of module names which must be loaded before this module.&#13;
           * @description&#13;
           * Holds the list of modules which the injector will load before the current module is loaded.&#13;
           */&#13;
          requires: requires,&#13;
&#13;
          /**&#13;
           * @ngdoc property&#13;
           * @name angular.Module#name&#13;
           * @propertyOf angular.Module&#13;
           * @returns {string} Name of the module.&#13;
           * @description&#13;
           */&#13;
          name: name,&#13;
&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#provider&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name service name&#13;
           * @param {Function} providerType Construction function for creating new instance of the service.&#13;
           * @description&#13;
           * See {@link angular.module.AUTO.$provide#provider $provide.provider()}.&#13;
           */&#13;
          provider: invokeLater('$provide', 'provider'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#factory&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name service name&#13;
           * @param {Function} providerFunction Function for creating new instance of the service.&#13;
           * @description&#13;
           * See {@link angular.module.AUTO.$provide#factory $provide.factory()}.&#13;
           */&#13;
          factory: invokeLater('$provide', 'factory'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#service&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name service name&#13;
           * @param {Function} constructor A constructor function that will be instantiated.&#13;
           * @description&#13;
           * See {@link angular.module.AUTO.$provide#service $provide.service()}.&#13;
           */&#13;
          service: invokeLater('$provide', 'service'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#value&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name service name&#13;
           * @param {*} object Service instance object.&#13;
           * @description&#13;
           * See {@link angular.module.AUTO.$provide#value $provide.value()}.&#13;
           */&#13;
          value: invokeLater('$provide', 'value'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#constant&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name constant name&#13;
           * @param {*} object Constant value.&#13;
           * @description&#13;
           * Because the constant are fixed, they get applied before other provide methods.&#13;
           * See {@link angular.module.AUTO.$provide#constant $provide.constant()}.&#13;
           */&#13;
          constant: invokeLater('$provide', 'constant', 'unshift'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#filter&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name Filter name.&#13;
           * @param {Function} filterFactory Factory function for creating new instance of filter.&#13;
           * @description&#13;
           * See {@link angular.module.ng.$filterProvider#register $filterProvider.register()}.&#13;
           */&#13;
          filter: invokeLater('$filterProvider', 'register'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#controller&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name Controller name.&#13;
           * @param {Function} constructor Controller constructor function.&#13;
           * @description&#13;
           * See {@link angular.module.ng.$controllerProvider#register $controllerProvider.register()}.&#13;
           */&#13;
          controller: invokeLater('$controllerProvider', 'register'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#directive&#13;
           * @methodOf angular.Module&#13;
           * @param {string} name directive name&#13;
           * @param {Function} directiveFactory Factory function for creating new instance of&#13;
           * directives.&#13;
           * @description&#13;
           * See {@link angular.module.ng.$compileProvider.directive $compileProvider.directive()}.&#13;
           */&#13;
          directive: invokeLater('$compileProvider', 'directive'),&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#config&#13;
           * @methodOf angular.Module&#13;
           * @param {Function} configFn Execute this function on module load. Useful for service&#13;
           *    configuration.&#13;
           * @description&#13;
           * Use this method to register work which needs to be performed on module loading.&#13;
           */&#13;
          config: config,&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.Module#run&#13;
           * @methodOf angular.Module&#13;
           * @param {Function} initializationFn Execute this function after injector creation.&#13;
           *    Useful for application initialization.&#13;
           * @description&#13;
           * Use this method to register work which needs to be performed when the injector with&#13;
           * with the current module is finished loading.&#13;
           */&#13;
          run: function(block) {&#13;
            runBlocks.push(block);&#13;
            return this;&#13;
          }&#13;
        };&#13;
&#13;
        if (configFn) {&#13;
          config(configFn);&#13;
        }&#13;
&#13;
        return  moduleInstance;&#13;
&#13;
        /**&#13;
         * @param {string} provider&#13;
         * @param {string} method&#13;
         * @param {String=} insertMethod&#13;
         * @returns {angular.Module}&#13;
         */&#13;
        function invokeLater(provider, method, insertMethod) {&#13;
          return function() {&#13;
            invokeQueue[insertMethod || 'push']([provider, method, arguments]);&#13;
            return moduleInstance;&#13;
          }&#13;
        }&#13;
      });&#13;
    };&#13;
  });&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc property&#13;
 * @name angular.version&#13;
 * @description&#13;
 * An object that contains information about the current AngularJS version. This object has the&#13;
 * following properties:&#13;
 *&#13;
 * - `full` â€" `{string}` â€" Full version string, such as "0.9.18".&#13;
 * - `major` â€" `{number}` â€" Major version number, such as "0".&#13;
 * - `minor` â€" `{number}` â€" Minor version number, such as "9".&#13;
 * - `dot` â€" `{number}` â€" Dot version number, such as "18".&#13;
 * - `codeName` â€" `{string}` â€" Code name of the release, such as "jiggling-armfat".&#13;
 */&#13;
var version = {&#13;
  full: '1.0.0rc4',    // all of these placeholder strings will be replaced by rake's&#13;
  major: 1,    // compile task&#13;
  minor: 0,&#13;
  dot: 0,&#13;
  codeName: 'insomnia-induction'&#13;
};&#13;
&#13;
&#13;
function publishExternalAPI(angular){&#13;
  extend(angular, {&#13;
    'bootstrap': bootstrap,&#13;
    'copy': copy,&#13;
    'extend': extend,&#13;
    'equals': equals,&#13;
    'element': jqLite,&#13;
    'forEach': forEach,&#13;
    'injector': createInjector,&#13;
    'noop':noop,&#13;
    'bind':bind,&#13;
    'toJson': toJson,&#13;
    'fromJson': fromJson,&#13;
    'identity':identity,&#13;
    'isUndefined': isUndefined,&#13;
    'isDefined': isDefined,&#13;
    'isString': isString,&#13;
    'isFunction': isFunction,&#13;
    'isObject': isObject,&#13;
    'isNumber': isNumber,&#13;
    'isElement': isElement,&#13;
    'isArray': isArray,&#13;
    'version': version,&#13;
    'isDate': isDate,&#13;
    'lowercase': lowercase,&#13;
    'uppercase': uppercase,&#13;
    'callbacks': {counter: 0}&#13;
  });&#13;
&#13;
  angularModule = setupModuleLoader(window);&#13;
  try {&#13;
    angularModule('ngLocale');&#13;
  } catch (e) {&#13;
    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);&#13;
  }&#13;
&#13;
  angularModule('ng', ['ngLocale'], ['$provide',&#13;
    function ngModule($provide) {&#13;
      $provide.provider('$compile', $CompileProvider).&#13;
        directive({&#13;
            a: htmlAnchorDirective,&#13;
            input: inputDirective,&#13;
            textarea: inputDirective,&#13;
            form: formDirective,&#13;
            script: scriptDirective,&#13;
            select: selectDirective,&#13;
            style: styleDirective,&#13;
            option: optionDirective,&#13;
            ngBind: ngBindDirective,&#13;
            ngBindHtml: ngBindHtmlDirective,&#13;
            ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,&#13;
            ngBindTemplate: ngBindTemplateDirective,&#13;
            ngClass: ngClassDirective,&#13;
            ngClassEven: ngClassEvenDirective,&#13;
            ngClassOdd: ngClassOddDirective,&#13;
            ngCloak: ngCloakDirective,&#13;
            ngController: ngControllerDirective,&#13;
            ngForm: ngFormDirective,&#13;
            ngHide: ngHideDirective,&#13;
            ngInclude: ngIncludeDirective,&#13;
            ngInit: ngInitDirective,&#13;
            ngNonBindable: ngNonBindableDirective,&#13;
            ngPluralize: ngPluralizeDirective,&#13;
            ngRepeat: ngRepeatDirective,&#13;
            ngShow: ngShowDirective,&#13;
            ngSubmit: ngSubmitDirective,&#13;
            ngStyle: ngStyleDirective,&#13;
            ngSwitch: ngSwitchDirective,&#13;
            ngSwitchWhen: ngSwitchWhenDirective,&#13;
            ngSwitchDefault: ngSwitchDefaultDirective,&#13;
            ngOptions: ngOptionsDirective,&#13;
            ngView: ngViewDirective,&#13;
            ngTransclude: ngTranscludeDirective,&#13;
            ngModel: ngModelDirective,&#13;
            ngList: ngListDirective,&#13;
            ngChange: ngChangeDirective,&#13;
            required: requiredDirective,&#13;
            ngRequired: requiredDirective,&#13;
            ngValue: ngValueDirective&#13;
        }).&#13;
        directive(ngAttributeAliasDirectives).&#13;
        directive(ngEventDirectives);&#13;
      $provide.provider({&#13;
        $anchorScroll: $AnchorScrollProvider,&#13;
        $browser: $BrowserProvider,&#13;
        $cacheFactory: $CacheFactoryProvider,&#13;
        $controller: $ControllerProvider,&#13;
        $defer: $DeferProvider,&#13;
        $document: $DocumentProvider,&#13;
        $exceptionHandler: $ExceptionHandlerProvider,&#13;
        $filter: $FilterProvider,&#13;
        $interpolate: $InterpolateProvider,&#13;
        $http: $HttpProvider,&#13;
        $httpBackend: $HttpBackendProvider,&#13;
        $location: $LocationProvider,&#13;
        $log: $LogProvider,&#13;
        $parse: $ParseProvider,&#13;
        $route: $RouteProvider,&#13;
        $routeParams: $RouteParamsProvider,&#13;
        $rootScope: $RootScopeProvider,&#13;
        $q: $QProvider,&#13;
        $sanitize: $SanitizeProvider,&#13;
        $sniffer: $SnifferProvider,&#13;
        $templateCache: $TemplateCacheProvider,&#13;
        $window: $WindowProvider&#13;
      });&#13;
    }&#13;
  ]);&#13;
};&#13;
&#13;
//////////////////////////////////&#13;
//JQLite&#13;
//////////////////////////////////&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.element&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.&#13;
 * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if&#13;
 * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite&#13;
 * implementation (commonly referred to as jqLite).&#13;
 *&#13;
 * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`&#13;
 * event fired.&#13;
 *&#13;
 * jqLite is a tiny, API-compatible subset of jQuery that allows&#13;
 * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality&#13;
 * within a very small footprint, so only a subset of the jQuery API - methods, arguments and&#13;
 * invocation styles - are supported.&#13;
 *&#13;
 * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never&#13;
 * raw DOM references.&#13;
 *&#13;
 * ## Angular's jQuery lite provides the following methods:&#13;
 *&#13;
 * - [addClass()](http://api.jquery.com/addClass/)&#13;
 * - [after()](http://api.jquery.com/after/)&#13;
 * - [append()](http://api.jquery.com/append/)&#13;
 * - [attr()](http://api.jquery.com/attr/)&#13;
 * - [bind()](http://api.jquery.com/bind/)&#13;
 * - [children()](http://api.jquery.com/children/)&#13;
 * - [clone()](http://api.jquery.com/clone/)&#13;
 * - [contents()](http://api.jquery.com/contents/)&#13;
 * - [css()](http://api.jquery.com/css/)&#13;
 * - [data()](http://api.jquery.com/data/)&#13;
 * - [eq()](http://api.jquery.com/eq/)&#13;
 * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name.&#13;
 * - [hasClass()](http://api.jquery.com/hasClass/)&#13;
 * - [html()](http://api.jquery.com/html/)&#13;
 * - [next()](http://api.jquery.com/next/)&#13;
 * - [parent()](http://api.jquery.com/parent/)&#13;
 * - [prepend()](http://api.jquery.com/prepend/)&#13;
 * - [prop()](http://api.jquery.com/prop/)&#13;
 * - [ready()](http://api.jquery.com/ready/)&#13;
 * - [remove()](http://api.jquery.com/remove/)&#13;
 * - [removeAttr()](http://api.jquery.com/removeAttr/)&#13;
 * - [removeClass()](http://api.jquery.com/removeClass/)&#13;
 * - [removeData()](http://api.jquery.com/removeData/)&#13;
 * - [replaceWith()](http://api.jquery.com/replaceWith/)&#13;
 * - [text()](http://api.jquery.com/text/)&#13;
 * - [toggleClass()](http://api.jquery.com/toggleClass/)&#13;
 * - [unbind()](http://api.jquery.com/unbind/)&#13;
 * - [val()](http://api.jquery.com/val/)&#13;
 * - [wrap()](http://api.jquery.com/wrap/)&#13;
 *&#13;
 * ## In addtion to the above, Angular privides an additional method to both jQuery and jQuery lite:&#13;
 *&#13;
 * - `controller(name)` - retrieves the controller of the current element or its parent. By default&#13;
 *   retrieves controller associated with the `ng-controller` directive. If `name` is provided as&#13;
 *   camelCase directive name, then the controller for this directive will be retrieved (e.g.&#13;
 *   `'ngModel'`).&#13;
 * - `injector()` - retrieves the injector of the current element or its parent.&#13;
 * - `scope()` - retrieves the {@link api/angular.module.ng.$rootScope.Scope scope} of the current&#13;
 *   element or its parent.&#13;
 * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top&#13;
 *   parent element is reached.&#13;
 *&#13;
 * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.&#13;
 * @returns {Object} jQuery object.&#13;
 */&#13;
&#13;
var jqCache = {},&#13;
    jqName = 'ng-' + new Date().getTime(),&#13;
    jqId = 1,&#13;
    addEventListenerFn = (window.document.addEventListener&#13;
      ? function(element, type, fn) {element.addEventListener(type, fn, false);}&#13;
      : function(element, type, fn) {element.attachEvent('on' + type, fn);}),&#13;
    removeEventListenerFn = (window.document.removeEventListener&#13;
      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }&#13;
      : function(element, type, fn) {element.detachEvent('on' + type, fn); });&#13;
&#13;
function jqNextId() { return (jqId++); }&#13;
&#13;
&#13;
function getStyle(element) {&#13;
  var current = {}, style = element[0].style, value, name, i;&#13;
  if (typeof style.length == 'number') {&#13;
    for(i = 0; i &lt; style.length; i++) {&#13;
      name = style[i];&#13;
      current[name] = style[name];&#13;
    }&#13;
  } else {&#13;
    for (name in style) {&#13;
      value = style[name];&#13;
      if (1*name != name &amp;&amp; name != 'cssText' &amp;&amp; value &amp;&amp; typeof value == 'string' &amp;&amp; value !='false')&#13;
        current[name] = value;&#13;
    }&#13;
  }&#13;
  return current;&#13;
}&#13;
&#13;
&#13;
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;&#13;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;&#13;
&#13;
/**&#13;
 * Converts snake_case to camelCase.&#13;
 * Also there is special case for Moz prefix starting with upper case letter.&#13;
 * @param name Name to normalize&#13;
 */&#13;
function camelCase(name) {&#13;
  return name.&#13;
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {&#13;
      return offset ? letter.toUpperCase() : letter;&#13;
    }).&#13;
    replace(MOZ_HACK_REGEXP, 'Moz$1');&#13;
}&#13;
&#13;
/////////////////////////////////////////////&#13;
// jQuery mutation patch&#13;
//&#13;
//  In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a&#13;
// $destroy event on all DOM nodes being removed.&#13;
//&#13;
/////////////////////////////////////////////&#13;
&#13;
function JQLitePatchJQueryRemove(name, dispatchThis) {&#13;
  var originalJqFn = jQuery.fn[name];&#13;
  originalJqFn = originalJqFn.$original || originalJqFn;&#13;
  removePatch.$original = originalJqFn;&#13;
  jQuery.fn[name] = removePatch;&#13;
&#13;
  function removePatch() {&#13;
    var list = [this],&#13;
        fireEvent = dispatchThis,&#13;
        set, setIndex, setLength,&#13;
        element, childIndex, childLength, children,&#13;
        fns, data;&#13;
&#13;
    while(list.length) {&#13;
      set = list.shift();&#13;
      for(setIndex = 0, setLength = set.length; setIndex &lt; setLength; setIndex++) {&#13;
        element = jqLite(set[setIndex]);&#13;
        if (fireEvent) {&#13;
          data = element.data('events');&#13;
          if ( (fns = data &amp;&amp; data.$destroy) ) {&#13;
            forEach(fns, function(fn){&#13;
              fn.handler();&#13;
            });&#13;
          }&#13;
        } else {&#13;
          fireEvent = !fireEvent;&#13;
        }&#13;
        for(childIndex = 0, childLength = (children = element.children()).length;&#13;
            childIndex &lt; childLength;&#13;
            childIndex++) {&#13;
          list.push(jQuery(children[childIndex]));&#13;
        }&#13;
      }&#13;
    }&#13;
    return originalJqFn.apply(this, arguments);&#13;
  }&#13;
}&#13;
&#13;
/////////////////////////////////////////////&#13;
function JQLite(element) {&#13;
  if (element instanceof JQLite) {&#13;
    return element;&#13;
  }&#13;
  if (!(this instanceof JQLite)) {&#13;
    if (isString(element) &amp;&amp; element.charAt(0) != '&lt;') {&#13;
      throw Error('selectors not implemented');&#13;
    }&#13;
    return new JQLite(element);&#13;
  }&#13;
&#13;
  if (isString(element)) {&#13;
    var div = document.createElement('div');&#13;
    // Read about the NoScope elements here:&#13;
    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx&#13;
    div.innerHTML = '&lt;div&gt;&amp;nbsp;&lt;/div&gt;' + element; // IE insanity to make NoScope elements work!&#13;
    div.removeChild(div.firstChild); // remove the superfluous div&#13;
    JQLiteAddNodes(this, div.childNodes);&#13;
    this.remove(); // detach the elements from the temporary DOM div.&#13;
  } else {&#13;
    JQLiteAddNodes(this, element);&#13;
  }&#13;
}&#13;
&#13;
function JQLiteClone(element) {&#13;
  return element.cloneNode(true);&#13;
}&#13;
&#13;
function JQLiteDealoc(element){&#13;
  JQLiteRemoveData(element);&#13;
  for ( var i = 0, children = element.childNodes || []; i &lt; children.length; i++) {&#13;
    JQLiteDealoc(children[i]);&#13;
  }&#13;
}&#13;
&#13;
function JQLiteRemoveData(element) {&#13;
  var cacheId = element[jqName],&#13;
  cache = jqCache[cacheId];&#13;
  if (cache) {&#13;
    if (cache.bind) {&#13;
      forEach(cache.bind, function(fn, type){&#13;
        if (type == '$destroy') {&#13;
          fn({});&#13;
        } else {&#13;
          removeEventListenerFn(element, type, fn);&#13;
        }&#13;
      });&#13;
    }&#13;
    delete jqCache[cacheId];&#13;
    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.&#13;
  }&#13;
}&#13;
&#13;
function JQLiteData(element, key, value) {&#13;
  var cacheId = element[jqName],&#13;
      cache = jqCache[cacheId || -1];&#13;
  if (isDefined(value)) {&#13;
    if (!cache) {&#13;
      element[jqName] = cacheId = jqNextId();&#13;
      cache = jqCache[cacheId] = {};&#13;
    }&#13;
    cache[key] = value;&#13;
  } else {&#13;
    return cache ? cache[key] : null;&#13;
  }&#13;
}&#13;
&#13;
function JQLiteHasClass(element, selector) {&#13;
  return ((" " + element.className + " ").replace(/[\n\t]/g, " ").&#13;
      indexOf( " " + selector + " " ) &gt; -1);&#13;
}&#13;
&#13;
function JQLiteRemoveClass(element, selector) {&#13;
  if (selector) {&#13;
    forEach(selector.split(' '), function(cssClass) {&#13;
      element.className = trim(&#13;
          (" " + element.className + " ")&#13;
          .replace(/[\n\t]/g, " ")&#13;
          .replace(" " + trim(cssClass) + " ", " ")&#13;
      );&#13;
    });&#13;
  }&#13;
}&#13;
&#13;
function JQLiteAddClass(element, selector) {&#13;
  if (selector) {&#13;
    forEach(selector.split(' '), function(cssClass) {&#13;
      if (!JQLiteHasClass(element, cssClass)) {&#13;
        element.className = trim(element.className + ' ' + trim(cssClass));&#13;
      }&#13;
    });&#13;
  }&#13;
}&#13;
&#13;
function JQLiteAddNodes(root, elements) {&#13;
  if (elements) {&#13;
    elements = (!elements.nodeName &amp;&amp; isDefined(elements.length) &amp;&amp; !isWindow(elements))&#13;
      ? elements&#13;
      : [ elements ];&#13;
    for(var i=0; i &lt; elements.length; i++) {&#13;
      root.push(elements[i]);&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
function JQLiteController(element, name) {&#13;
  return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');&#13;
}&#13;
&#13;
function JQLiteInheritedData(element, name, value) {&#13;
  element = jqLite(element);&#13;
&#13;
  // if element is the document object work with the html element instead&#13;
  // this makes $(document).scope() possible&#13;
  if(element[0].nodeType == 9) {&#13;
    element = element.find('html');&#13;
  }&#13;
&#13;
  while (element.length) {&#13;
    if (value = element.data(name)) return value;&#13;
    element = element.parent();&#13;
  }&#13;
}&#13;
&#13;
//////////////////////////////////////////&#13;
// Functions which are declared directly.&#13;
//////////////////////////////////////////&#13;
var JQLitePrototype = JQLite.prototype = {&#13;
  ready: function(fn) {&#13;
    var fired = false;&#13;
&#13;
    function trigger() {&#13;
      if (fired) return;&#13;
      fired = true;&#13;
      fn();&#13;
    }&#13;
&#13;
    this.bind('DOMContentLoaded', trigger); // works for modern browsers and IE9&#13;
    // we can not use jqLite since we are not done loading and jQuery could be loaded later.&#13;
    JQLite(window).bind('load', trigger); // fallback to window.onload for others&#13;
  },&#13;
  toString: function() {&#13;
    var value = [];&#13;
    forEach(this, function(e){ value.push('' + e);});&#13;
    return '[' + value.join(', ') + ']';&#13;
  },&#13;
&#13;
  eq: function(index) {&#13;
      return (index &gt;= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);&#13;
  },&#13;
&#13;
  length: 0,&#13;
  push: push,&#13;
  sort: [].sort,&#13;
  splice: [].splice&#13;
};&#13;
&#13;
//////////////////////////////////////////&#13;
// Functions iterating getter/setters.&#13;
// these functions return self on setter and&#13;
// value on get.&#13;
//////////////////////////////////////////&#13;
var BOOLEAN_ATTR = {};&#13;
forEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function(value) {&#13;
  BOOLEAN_ATTR[lowercase(value)] = value;&#13;
});&#13;
var BOOLEAN_ELEMENTS = {};&#13;
forEach('input,select,option,textarea,button,form'.split(','), function(value) {&#13;
  BOOLEAN_ELEMENTS[uppercase(value)] = true;&#13;
});&#13;
&#13;
function isBooleanAttr(element, name) {&#13;
  return BOOLEAN_ELEMENTS[element.nodeName] &amp;&amp; BOOLEAN_ATTR[name.toLowerCase()];&#13;
}&#13;
&#13;
forEach({&#13;
  data: JQLiteData,&#13;
  inheritedData: JQLiteInheritedData,&#13;
&#13;
  scope: function(element) {&#13;
    return JQLiteInheritedData(element, '$scope');&#13;
  },&#13;
&#13;
  controller: JQLiteController ,&#13;
&#13;
  injector: function(element) {&#13;
    return JQLiteInheritedData(element, '$injector');&#13;
  },&#13;
&#13;
  removeAttr: function(element,name) {&#13;
    element.removeAttribute(name);&#13;
  },&#13;
&#13;
  hasClass: JQLiteHasClass,&#13;
&#13;
  css: function(element, name, value) {&#13;
    name = camelCase(name);&#13;
&#13;
    if (isDefined(value)) {&#13;
      element.style[name] = value;&#13;
    } else {&#13;
      var val;&#13;
&#13;
      if (msie &lt;= 8) {&#13;
        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why&#13;
        val = element.currentStyle &amp;&amp; element.currentStyle[name];&#13;
        if (val === '') val = 'auto';&#13;
      }&#13;
&#13;
      val = val || element.style[name];&#13;
&#13;
      if (msie &lt;= 8) {&#13;
        // jquery weirdness :-/&#13;
        val = (val === '') ? undefined : val;&#13;
      }&#13;
&#13;
      return  val;&#13;
    }&#13;
  },&#13;
&#13;
  attr: function(element, name, value){&#13;
    var lowercasedName = lowercase(name);&#13;
    if (BOOLEAN_ATTR[lowercasedName]) {&#13;
      if (isDefined(value)) {&#13;
        if (!!value) {&#13;
          element[name] = true;&#13;
          element.setAttribute(name, lowercasedName);&#13;
        } else {&#13;
          element[name] = false;&#13;
          element.removeAttribute(lowercasedName);&#13;
        }&#13;
      } else {&#13;
        return (element[name] ||&#13;
                 (element.attributes.getNamedItem(name)|| noop).specified)&#13;
               ? lowercasedName&#13;
               : undefined;&#13;
      }&#13;
    } else if (isDefined(value)) {&#13;
      element.setAttribute(name, value);&#13;
    } else if (element.getAttribute) {&#13;
      // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code&#13;
      // some elements (e.g. Document) don't have get attribute, so return undefined&#13;
      var ret = element.getAttribute(name, 2);&#13;
      // normalize non-existing attributes to undefined (as jQuery)&#13;
      return ret === null ? undefined : ret;&#13;
    }&#13;
  },&#13;
&#13;
  prop: function(element, name, value) {&#13;
    if (isDefined(value)) {&#13;
      element[name] = value;&#13;
    } else {&#13;
      return element[name];&#13;
    }&#13;
  },&#13;
&#13;
  text: extend((msie &lt; 9)&#13;
      ? function(element, value) {&#13;
        if (element.nodeType == 1 /** Element */) {&#13;
          if (isUndefined(value))&#13;
            return element.innerText;&#13;
          element.innerText = value;&#13;
        } else {&#13;
          if (isUndefined(value))&#13;
            return element.nodeValue;&#13;
          element.nodeValue = value;&#13;
        }&#13;
      }&#13;
      : function(element, value) {&#13;
        if (isUndefined(value)) {&#13;
          return element.textContent;&#13;
        }&#13;
        element.textContent = value;&#13;
      }, {$dv:''}),&#13;
&#13;
  val: function(element, value) {&#13;
    if (isUndefined(value)) {&#13;
      return element.value;&#13;
    }&#13;
    element.value = value;&#13;
  },&#13;
&#13;
  html: function(element, value) {&#13;
    if (isUndefined(value)) {&#13;
      return element.innerHTML;&#13;
    }&#13;
    for (var i = 0, childNodes = element.childNodes; i &lt; childNodes.length; i++) {&#13;
      JQLiteDealoc(childNodes[i]);&#13;
    }&#13;
    element.innerHTML = value;&#13;
  }&#13;
}, function(fn, name){&#13;
  /**&#13;
   * Properties: writes return selection, reads return first value&#13;
   */&#13;
  JQLite.prototype[name] = function(arg1, arg2) {&#13;
    var i, key;&#13;
&#13;
    // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it&#13;
    // in a way that survives minification.&#13;
    if (((fn.length == 2 &amp;&amp; (fn !== JQLiteHasClass &amp;&amp; fn !== JQLiteController)) ? arg1 : arg2) === undefined) {&#13;
      if (isObject(arg1)) {&#13;
        // we are a write, but the object properties are the key/values&#13;
        for(i=0; i &lt; this.length; i++) {&#13;
          for (key in arg1) {&#13;
            fn(this[i], key, arg1[key]);&#13;
          }&#13;
        }&#13;
        // return self for chaining&#13;
        return this;&#13;
      } else {&#13;
        // we are a read, so read the first child.&#13;
        if (this.length)&#13;
          return fn(this[0], arg1, arg2);&#13;
      }&#13;
    } else {&#13;
      // we are a write, so apply to all children&#13;
      for(i=0; i &lt; this.length; i++) {&#13;
        fn(this[i], arg1, arg2);&#13;
      }&#13;
      // return self for chaining&#13;
      return this;&#13;
    }&#13;
    return fn.$dv;&#13;
  };&#13;
});&#13;
&#13;
function createEventHandler(element) {&#13;
  var eventHandler = function (event) {&#13;
    if (!event.preventDefault) {&#13;
      event.preventDefault = function() {&#13;
        event.returnValue = false; //ie&#13;
      };&#13;
    }&#13;
&#13;
    if (!event.stopPropagation) {&#13;
      event.stopPropagation = function() {&#13;
        event.cancelBubble = true; //ie&#13;
      };&#13;
    }&#13;
&#13;
    if (!event.target) {&#13;
      event.target = event.srcElement || document;&#13;
    }&#13;
&#13;
    if (isUndefined(event.defaultPrevented)) {&#13;
      var prevent = event.preventDefault;&#13;
      event.preventDefault = function() {&#13;
        event.defaultPrevented = true;&#13;
        prevent.call(event);&#13;
      };&#13;
      event.defaultPrevented = false;&#13;
    }&#13;
&#13;
    event.isDefaultPrevented = function() {&#13;
      return event.defaultPrevented;&#13;
    };&#13;
&#13;
    forEach(eventHandler.fns, function(fn){&#13;
      fn.call(element, event);&#13;
    });&#13;
&#13;
    // Remove monkey-patched methods (IE),&#13;
    // as they would cause memory leaks in IE8.&#13;
    if (msie &lt; 8) {&#13;
      // IE7 does not allow to delete property on native object&#13;
      event.preventDefault = null;&#13;
      event.stopPropagation = null;&#13;
      event.isDefaultPrevented = null;&#13;
    } else {&#13;
      // It shouldn't affect normal browsers (native methods are defined on prototype).&#13;
      delete event.preventDefault;&#13;
      delete event.stopPropagation;&#13;
      delete event.isDefaultPrevented;&#13;
    }&#13;
  };&#13;
  eventHandler.fns = [];&#13;
  return eventHandler;&#13;
};&#13;
&#13;
//////////////////////////////////////////&#13;
// Functions iterating traversal.&#13;
// These functions chain results into a single&#13;
// selector.&#13;
//////////////////////////////////////////&#13;
forEach({&#13;
  removeData: JQLiteRemoveData,&#13;
&#13;
  dealoc: JQLiteDealoc,&#13;
&#13;
  bind: function bindFn(element, type, fn){&#13;
    var bind = JQLiteData(element, 'bind');&#13;
&#13;
&#13;
    if (!bind) JQLiteData(element, 'bind', bind = {});&#13;
    forEach(type.split(' '), function(type){&#13;
      var eventHandler = bind[type];&#13;
&#13;
&#13;
      if (!eventHandler) {&#13;
        if (type == 'mouseenter' || type == 'mouseleave') {&#13;
          var mouseenter = bind.mouseenter = createEventHandler(element);&#13;
          var mouseleave = bind.mouseleave = createEventHandler(element);&#13;
          var counter = 0;&#13;
&#13;
&#13;
          bindFn(element, 'mouseover', function(event) {&#13;
            counter++;&#13;
            if (counter == 1) {&#13;
              event.type = 'mouseenter';&#13;
              mouseenter(event);&#13;
            }&#13;
          });&#13;
          bindFn(element, 'mouseout', function(event) {&#13;
            counter --;&#13;
            if (counter == 0) {&#13;
              event.type = 'mouseleave';&#13;
              mouseleave(event);&#13;
            }&#13;
          });&#13;
          eventHandler = bind[type];&#13;
        } else {&#13;
          eventHandler = bind[type] = createEventHandler(element);&#13;
          addEventListenerFn(element, type, eventHandler);&#13;
        }&#13;
      }&#13;
      eventHandler.fns.push(fn);&#13;
    });&#13;
  },&#13;
&#13;
  unbind: function(element, type, fn) {&#13;
    var bind = JQLiteData(element, 'bind');&#13;
    if (!bind) return; //no listeners registered&#13;
&#13;
    if (isUndefined(type)) {&#13;
      forEach(bind, function(eventHandler, type) {&#13;
        removeEventListenerFn(element, type, eventHandler);&#13;
        delete bind[type];&#13;
      });&#13;
    } else {&#13;
      if (isUndefined(fn)) {&#13;
        removeEventListenerFn(element, type, bind[type]);&#13;
        delete bind[type];&#13;
      } else {&#13;
        arrayRemove(bind[type].fns, fn);&#13;
      }&#13;
    }&#13;
  },&#13;
&#13;
  replaceWith: function(element, replaceNode) {&#13;
    var index, parent = element.parentNode;&#13;
    JQLiteDealoc(element);&#13;
    forEach(new JQLite(replaceNode), function(node){&#13;
      if (index) {&#13;
        parent.insertBefore(node, index.nextSibling);&#13;
      } else {&#13;
        parent.replaceChild(node, element);&#13;
      }&#13;
      index = node;&#13;
    });&#13;
  },&#13;
&#13;
  children: function(element) {&#13;
    var children = [];&#13;
    forEach(element.childNodes, function(element){&#13;
      if (element.nodeName != '#text')&#13;
        children.push(element);&#13;
    });&#13;
    return children;&#13;
  },&#13;
&#13;
  contents: function(element) {&#13;
    return element.childNodes;&#13;
  },&#13;
&#13;
  append: function(element, node) {&#13;
    forEach(new JQLite(node), function(child){&#13;
      if (element.nodeType === 1)&#13;
        element.appendChild(child);&#13;
    });&#13;
  },&#13;
&#13;
  prepend: function(element, node) {&#13;
    if (element.nodeType === 1) {&#13;
      var index = element.firstChild;&#13;
      forEach(new JQLite(node), function(child){&#13;
        if (index) {&#13;
          element.insertBefore(child, index);&#13;
        } else {&#13;
          element.appendChild(child);&#13;
          index = child;&#13;
        }&#13;
      });&#13;
    }&#13;
  },&#13;
&#13;
  wrap: function(element, wrapNode) {&#13;
    wrapNode = jqLite(wrapNode)[0];&#13;
    var parent = element.parentNode;&#13;
    if (parent) {&#13;
      parent.replaceChild(wrapNode, element);&#13;
    }&#13;
    wrapNode.appendChild(element);&#13;
  },&#13;
&#13;
  remove: function(element) {&#13;
    JQLiteDealoc(element);&#13;
    var parent = element.parentNode;&#13;
    if (parent) parent.removeChild(element);&#13;
  },&#13;
&#13;
  after: function(element, newElement) {&#13;
    var index = element, parent = element.parentNode;&#13;
    forEach(new JQLite(newElement), function(node){&#13;
      parent.insertBefore(node, index.nextSibling);&#13;
      index = node;&#13;
    });&#13;
  },&#13;
&#13;
  addClass: JQLiteAddClass,&#13;
  removeClass: JQLiteRemoveClass,&#13;
&#13;
  toggleClass: function(element, selector, condition) {&#13;
    if (isUndefined(condition)) {&#13;
      condition = !JQLiteHasClass(element, selector);&#13;
    }&#13;
    (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);&#13;
  },&#13;
&#13;
  parent: function(element) {&#13;
    var parent = element.parentNode;&#13;
    return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;&#13;
  },&#13;
&#13;
  next: function(element) {&#13;
    return element.nextSibling;&#13;
  },&#13;
&#13;
  find: function(element, selector) {&#13;
    return element.getElementsByTagName(selector);&#13;
  },&#13;
&#13;
  clone: JQLiteClone&#13;
}, function(fn, name){&#13;
  /**&#13;
   * chaining functions&#13;
   */&#13;
  JQLite.prototype[name] = function(arg1, arg2) {&#13;
    var value;&#13;
    for(var i=0; i &lt; this.length; i++) {&#13;
      if (value == undefined) {&#13;
        value = fn(this[i], arg1, arg2);&#13;
        if (value !== undefined) {&#13;
          // any function which returns a value needs to be wrapped&#13;
          value = jqLite(value);&#13;
        }&#13;
      } else {&#13;
        JQLiteAddNodes(value, fn(this[i], arg1, arg2));&#13;
      }&#13;
    }&#13;
    return value == undefined ? this : value;&#13;
  };&#13;
});&#13;
&#13;
/**&#13;
 * Computes a hash of an 'obj'.&#13;
 * Hash of a:&#13;
 *  string is string&#13;
 *  number is number as string&#13;
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,&#13;
 *         that is also assigned to the $$hashKey property of the object.&#13;
 *&#13;
 * @param obj&#13;
 * @returns {string} hash string such that the same input will have the same hash string.&#13;
 *         The resulting string key is in 'type:hashKey' format.&#13;
 */&#13;
function hashKey(obj) {&#13;
  var objType = typeof obj,&#13;
      key;&#13;
&#13;
  if (objType == 'object' &amp;&amp; obj !== null) {&#13;
    if (typeof (key = obj.$$hashKey) == 'function') {&#13;
      // must invoke on object to keep the right this&#13;
      key = obj.$$hashKey();&#13;
    } else if (key === undefined) {&#13;
      key = obj.$$hashKey = nextUid();&#13;
    }&#13;
  } else {&#13;
    key = obj;&#13;
  }&#13;
&#13;
  return objType + ':' + key;&#13;
}&#13;
&#13;
/**&#13;
 * HashMap which can use objects as keys&#13;
 */&#13;
function HashMap(array){&#13;
  forEach(array, this.put, this);&#13;
}&#13;
HashMap.prototype = {&#13;
  /**&#13;
   * Store key value pair&#13;
   * @param key key to store can be any type&#13;
   * @param value value to store can be any type&#13;
   */&#13;
  put: function(key, value) {&#13;
    this[hashKey(key)] = value;&#13;
  },&#13;
&#13;
  /**&#13;
   * @param key&#13;
   * @returns the value for the key&#13;
   */&#13;
  get: function(key) {&#13;
    return this[hashKey(key)];&#13;
  },&#13;
&#13;
  /**&#13;
   * Remove the key/value pair&#13;
   * @param key&#13;
   */&#13;
  remove: function(key) {&#13;
    var value = this[key = hashKey(key)];&#13;
    delete this[key];&#13;
    return value;&#13;
  }&#13;
};&#13;
&#13;
/**&#13;
 * A map where multiple values can be added to the same key such that they form a queue.&#13;
 * @returns {HashQueueMap}&#13;
 */&#13;
function HashQueueMap() {}&#13;
HashQueueMap.prototype = {&#13;
  /**&#13;
   * Same as array push, but using an array as the value for the hash&#13;
   */&#13;
  push: function(key, value) {&#13;
    var array = this[key = hashKey(key)];&#13;
    if (!array) {&#13;
      this[key] = [value];&#13;
    } else {&#13;
      array.push(value);&#13;
    }&#13;
  },&#13;
&#13;
  /**&#13;
   * Same as array shift, but using an array as the value for the hash&#13;
   */&#13;
  shift: function(key) {&#13;
    var array = this[key = hashKey(key)];&#13;
    if (array) {&#13;
      if (array.length == 1) {&#13;
        delete this[key];&#13;
        return array[0];&#13;
      } else {&#13;
        return array.shift();&#13;
      }&#13;
    }&#13;
  }&#13;
};&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.injector&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Creates an injector function that can be used for retrieving services as well as for&#13;
 * dependency injection (see {@link guide/dev_guide.di dependency injection}).&#13;
 *&#13;
&#13;
 * @param {Array.&lt;string|Function&gt;} modules A list of module functions or their aliases. See&#13;
 *        {@link angular.module}. The `ng` module must be explicitly added.&#13;
 * @returns {function()} Injector function. See {@link angular.module.AUTO.$injector $injector}.&#13;
 *&#13;
 * @example&#13;
 * Typical usage&#13;
 * &lt;pre&gt;&#13;
 *   // create an injector&#13;
 *   var $injector = angular.injector(['ng']);&#13;
 *&#13;
 *   // use the injector to kick of your application&#13;
 *   // use the type inference to auto inject arguments, or use implicit injection&#13;
 *   $injector.invoke(function($rootScope, $compile, $document){&#13;
 *     $compile($document)($rootScope);&#13;
 *     $rootScope.$digest();&#13;
 *   });&#13;
 * &lt;/pre&gt;&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc overview&#13;
 * @name angular.module.AUTO&#13;
 * @description&#13;
 *&#13;
 * Implicit module which gets automatically added to each {@link angular.module.AUTO.$injector $injector}.&#13;
 */&#13;
&#13;
var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;&#13;
var FN_ARG_SPLIT = /,/;&#13;
var FN_ARG = /^\s*(_?)(.+?)\1\s*$/;&#13;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;&#13;
function inferInjectionArgs(fn) {&#13;
  assertArgFn(fn);&#13;
  if (!fn.$inject) {&#13;
    var args = fn.$inject = [];&#13;
    var fnText = fn.toString().replace(STRIP_COMMENTS, '');&#13;
    var argDecl = fnText.match(FN_ARGS);&#13;
    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){&#13;
      arg.replace(FN_ARG, function(all, underscore, name){&#13;
        args.push(name);&#13;
      });&#13;
    });&#13;
  }&#13;
  return fn.$inject;&#13;
}&#13;
&#13;
///////////////////////////////////////&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.AUTO.$injector&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 *&#13;
 * `$injector` is used to retrieve object instances as defined by&#13;
 * {@link angular.module.AUTO.$provide provider}, instantiate types, invoke methods,&#13;
 * and load modules.&#13;
 *&#13;
 * The following always holds true:&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 *   var $injector = angular.injector();&#13;
 *   expect($injector.get('$injector')).toBe($injector);&#13;
 *   expect($injector.invoke(function($injector){&#13;
 *     return $injector;&#13;
 *   }).toBe($injector);&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * # Injection Function Annotation&#13;
 *&#13;
 * JavaScript does not have annotations, and annotations are needed for dependency injection. The&#13;
 * following ways are all valid way of annotating function with injection arguments and are equivalent.&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 *   // inferred (only works if code not minified/obfuscated)&#13;
 *   $inject.invoke(function(serviceA){});&#13;
 *&#13;
 *   // annotated&#13;
 *   function explicit(serviceA) {};&#13;
 *   explicit.$inject = ['serviceA'];&#13;
 *   $inject.invoke(explicit);&#13;
 *&#13;
 *   // inline&#13;
 *   $inject.invoke(['serviceA', function(serviceA){}]);&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * ## Inference&#13;
 *&#13;
 * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be&#13;
 * parsed and the function arguments can be extracted. *NOTE:* This does not work with minfication, and obfuscation&#13;
 * tools since these tools change the argument names.&#13;
 *&#13;
 * ## `$inject` Annotation&#13;
 * By adding a `$inject` property onto a function the injection parameters can be specified.&#13;
 *&#13;
 * ## Inline&#13;
 * As an array of injection names, where the last item in the array is the function to call.&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$injector#get&#13;
 * @methodOf angular.module.AUTO.$injector&#13;
 *&#13;
 * @description&#13;
 * Return an instance of the service.&#13;
 *&#13;
 * @param {string} name The name of the instance to retrieve.&#13;
 * @return {*} The instance.&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$injector#invoke&#13;
 * @methodOf angular.module.AUTO.$injector&#13;
 *&#13;
 * @description&#13;
 * Invoke the method and supply the method arguments from the `$injector`.&#13;
 *&#13;
 * @param {!function} fn The function to invoke. The function arguments come form the function annotation.&#13;
 * @param {Object=} self The `this` for the invoked method.&#13;
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before&#13;
 *   the `$injector` is consulted.&#13;
 * @return the value returned by the invoked `fn` function.&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$injector#instantiate&#13;
 * @methodOf angular.module.AUTO.$injector&#13;
 * @description&#13;
 * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies&#13;
 * all of the arguments to the constructor function as specified by the constructor annotation.&#13;
 *&#13;
 * @param {function} Type Annotated constructor function.&#13;
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before&#13;
 *   the `$injector` is consulted.&#13;
 * @return new instance of `Type`.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.AUTO.$provide&#13;
 *&#13;
 * @description&#13;
 *&#13;
 * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.&#13;
 * The providers share the same name as the instance they create with the `Provider` suffixed to them.&#13;
 *&#13;
 * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of&#13;
 * a service. The Provider can have additional methods which would allow for configuration of the provider.&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 *   function GreetProvider() {&#13;
 *     var salutation = 'Hello';&#13;
 *&#13;
 *     this.salutation = function(text) {&#13;
 *       salutation = text;&#13;
 *     };&#13;
 *&#13;
 *     this.$get = function() {&#13;
 *       return function (name) {&#13;
 *         return salutation + ' ' + name + '!';&#13;
 *       };&#13;
 *     };&#13;
 *   }&#13;
 *&#13;
 *   describe('Greeter', function(){&#13;
 *&#13;
 *     beforeEach(module(function($provide) {&#13;
 *       $provide.provider('greet', GreetProvider);&#13;
 *     });&#13;
 *&#13;
 *     it('should greet', inject(function(greet) {&#13;
 *       expect(greet('angular')).toEqual('Hello angular!');&#13;
 *     }));&#13;
 *&#13;
 *     it('should allow configuration of salutation', function() {&#13;
 *       module(function(greetProvider) {&#13;
 *         greetProvider.salutation('Ahoj');&#13;
 *       });&#13;
 *       inject(function(greet) {&#13;
 *         expect(greet('angular')).toEqual('Ahoj angular!');&#13;
 *       });&#13;
 *     )};&#13;
 *&#13;
 *   });&#13;
 * &lt;/pre&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$provide#provider&#13;
 * @methodOf angular.module.AUTO.$provide&#13;
 * @description&#13;
 *&#13;
 * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.&#13;
 *&#13;
 * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.&#13;
 * @param {(Object|function())} provider If the provider is:&#13;
 *&#13;
 *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using&#13;
 *               {@link angular.module.AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.&#13;
 *   - `Constructor`: a new instance of the provider will be created using&#13;
 *               {@link angular.module.AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.&#13;
 *&#13;
 * @returns {Object} registered provider instance&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$provide#factory&#13;
 * @methodOf angular.module.AUTO.$provide&#13;
 * @description&#13;
 *&#13;
 * A short hand for configuring services if only `$get` method is required.&#13;
 *&#13;
 * @param {string} name The name of the instance.&#13;
 * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for&#13;
 * `$provide.provider(name, {$get: $getFn})`.&#13;
 * @returns {Object} registered provider instance&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$provide#service&#13;
 * @methodOf angular.module.AUTO.$provide&#13;
 * @description&#13;
 *&#13;
 * A short hand for registering service of given class.&#13;
 *&#13;
 * @param {string} name The name of the instance.&#13;
 * @param {Function} constructor A class (constructor function) that will be instantiated.&#13;
 * @returns {Object} registered provider instance&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$provide#value&#13;
 * @methodOf angular.module.AUTO.$provide&#13;
 * @description&#13;
 *&#13;
 * A short hand for configuring services if the `$get` method is a constant.&#13;
 *&#13;
 * @param {string} name The name of the instance.&#13;
 * @param {*} value The value.&#13;
 * @returns {Object} registered provider instance&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$provide#constant&#13;
 * @methodOf angular.module.AUTO.$provide&#13;
 * @description&#13;
 *&#13;
 * A constant value, but unlike {@link angular.module.AUTO.$provide#value value} it can be injected&#13;
 * into configuration function (other modules) and it is not interceptable by&#13;
 * {@link angular.module.AUTO.$provide#decorator decorator}.&#13;
 *&#13;
 * @param {string} name The name of the constant.&#13;
 * @param {*} value The constant value.&#13;
 * @returns {Object} registered instance&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.AUTO.$provide#decorator&#13;
 * @methodOf angular.module.AUTO.$provide&#13;
 * @description&#13;
 *&#13;
 * Decoration of service, allows the decorator to intercept the service instance creation. The&#13;
 * returned instance may be the original instance, or a new instance which delegates to the&#13;
 * original instance.&#13;
 *&#13;
 * @param {string} name The name of the service to decorate.&#13;
 * @param {function()} decorator This function will be invoked when the service needs to be&#13;
 *    instanciated. The function is called using the {@link angular.module.AUTO.$injector#invoke&#13;
 *    injector.invoke} method and is therefore fully injectable. Local injection arguments:&#13;
 *&#13;
 *    * `$delegate` - The original service instance, which can be monkey patched, configured,&#13;
 *      decorated or delegated to.&#13;
 */&#13;
&#13;
&#13;
function createInjector(modulesToLoad) {&#13;
  var INSTANTIATING = {},&#13;
      providerSuffix = 'Provider',&#13;
      path = [],&#13;
      loadedModules = new HashMap(),&#13;
      providerCache = {&#13;
        $provide: {&#13;
            provider: supportObject(provider),&#13;
            factory: supportObject(factory),&#13;
            service: supportObject(service),&#13;
            value: supportObject(value),&#13;
            constant: supportObject(constant),&#13;
            decorator: decorator&#13;
          }&#13;
      },&#13;
      providerInjector = createInternalInjector(providerCache, function() {&#13;
        throw Error("Unknown provider: " + path.join(' &lt;- '));&#13;
      }),&#13;
      instanceCache = {},&#13;
      instanceInjector = (instanceCache.$injector =&#13;
          createInternalInjector(instanceCache, function(servicename) {&#13;
            var provider = providerInjector.get(servicename + providerSuffix);&#13;
            return instanceInjector.invoke(provider.$get, provider);&#13;
          }));&#13;
&#13;
&#13;
  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });&#13;
&#13;
  return instanceInjector;&#13;
&#13;
  ////////////////////////////////////&#13;
  // $provider&#13;
  ////////////////////////////////////&#13;
&#13;
  function supportObject(delegate) {&#13;
    return function(key, value) {&#13;
      if (isObject(key)) {&#13;
        forEach(key, reverseParams(delegate));&#13;
      } else {&#13;
        return delegate(key, value);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function provider(name, provider_) {&#13;
    if (isFunction(provider_)) {&#13;
      provider_ = providerInjector.instantiate(provider_);&#13;
    }&#13;
    if (!provider_.$get) {&#13;
      throw Error('Provider ' + name + ' must define $get factory method.');&#13;
    }&#13;
    return providerCache[name + providerSuffix] = provider_;&#13;
  }&#13;
&#13;
  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }&#13;
&#13;
  function service(name, constructor) {&#13;
    return factory(name, ['$injector', function($injector) {&#13;
      return $injector.instantiate(constructor);&#13;
    }]);&#13;
  }&#13;
&#13;
  function value(name, value) { return factory(name, valueFn(value)); }&#13;
&#13;
  function constant(name, value) {&#13;
    providerCache[name] = value;&#13;
    instanceCache[name] = value;&#13;
  }&#13;
&#13;
  function decorator(serviceName, decorFn) {&#13;
    var origProvider = providerInjector.get(serviceName + providerSuffix),&#13;
        orig$get = origProvider.$get;&#13;
&#13;
    origProvider.$get = function() {&#13;
      var origInstance = instanceInjector.invoke(orig$get, origProvider);&#13;
      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});&#13;
    };&#13;
  }&#13;
&#13;
  ////////////////////////////////////&#13;
  // Module Loading&#13;
  ////////////////////////////////////&#13;
  function loadModules(modulesToLoad){&#13;
    var runBlocks = [];&#13;
    forEach(modulesToLoad, function(module) {&#13;
      if (loadedModules.get(module)) return;&#13;
      loadedModules.put(module, true);&#13;
      if (isString(module)) {&#13;
        var moduleFn = angularModule(module);&#13;
        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);&#13;
&#13;
        try {&#13;
          for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i &lt; ii; i++) {&#13;
            var invokeArgs = invokeQueue[i],&#13;
                provider = invokeArgs[0] == '$injector'&#13;
                    ? providerInjector&#13;
                    : providerInjector.get(invokeArgs[0]);&#13;
&#13;
            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);&#13;
          }&#13;
        } catch (e) {&#13;
          if (e.message) e.message += ' from ' + module;&#13;
          throw e;&#13;
        }&#13;
      } else if (isFunction(module)) {&#13;
        try {&#13;
          runBlocks.push(providerInjector.invoke(module));&#13;
        } catch (e) {&#13;
          if (e.message) e.message += ' from ' + module;&#13;
          throw e;&#13;
        }&#13;
      } else if (isArray(module)) {&#13;
        try {&#13;
          runBlocks.push(providerInjector.invoke(module));&#13;
        } catch (e) {&#13;
          if (e.message) e.message += ' from ' + String(module[module.length - 1]);&#13;
          throw e;&#13;
        }&#13;
      } else {&#13;
        assertArgFn(module, 'module');&#13;
      }&#13;
    });&#13;
    return runBlocks;&#13;
  }&#13;
&#13;
  ////////////////////////////////////&#13;
  // internal Injector&#13;
  ////////////////////////////////////&#13;
&#13;
  function createInternalInjector(cache, factory) {&#13;
&#13;
    function getService(serviceName) {&#13;
      if (typeof serviceName !== 'string') {&#13;
        throw Error('Service name expected');&#13;
      }&#13;
      if (cache.hasOwnProperty(serviceName)) {&#13;
        if (cache[serviceName] === INSTANTIATING) {&#13;
          throw Error('Circular dependency: ' + path.join(' &lt;- '));&#13;
        }&#13;
        return cache[serviceName];&#13;
      } else {&#13;
        try {&#13;
          path.unshift(serviceName);&#13;
          cache[serviceName] = INSTANTIATING;&#13;
          return cache[serviceName] = factory(serviceName);&#13;
        } finally {&#13;
          path.shift();&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    function invoke(fn, self, locals){&#13;
      var args = [],&#13;
          $inject,&#13;
          length,&#13;
          key;&#13;
&#13;
      if (typeof fn == 'function') {&#13;
        $inject = inferInjectionArgs(fn);&#13;
        length = $inject.length;&#13;
      } else {&#13;
        if (isArray(fn)) {&#13;
          $inject = fn;&#13;
          length = $inject.length - 1;&#13;
          fn = $inject[length];&#13;
        }&#13;
        assertArgFn(fn, 'fn');&#13;
      }&#13;
&#13;
      for(var i = 0; i &lt; length; i++) {&#13;
        key = $inject[i];&#13;
        args.push(&#13;
          locals &amp;&amp; locals.hasOwnProperty(key)&#13;
          ? locals[key]&#13;
          : getService(key, path)&#13;
        );&#13;
      }&#13;
&#13;
      // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke&#13;
      switch (self ? -1 : args.length) {&#13;
        case  0: return fn();&#13;
        case  1: return fn(args[0]);&#13;
        case  2: return fn(args[0], args[1]);&#13;
        case  3: return fn(args[0], args[1], args[2]);&#13;
        case  4: return fn(args[0], args[1], args[2], args[3]);&#13;
        case  5: return fn(args[0], args[1], args[2], args[3], args[4]);&#13;
        case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);&#13;
        case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);&#13;
        case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);&#13;
        case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);&#13;
        case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);&#13;
        default: return fn.apply(self, args);&#13;
      }&#13;
    }&#13;
&#13;
    function instantiate(Type, locals) {&#13;
      var Constructor = function() {},&#13;
          instance, returnedValue;&#13;
&#13;
      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;&#13;
      instance = new Constructor();&#13;
      returnedValue = invoke(Type, instance, locals);&#13;
&#13;
      return isObject(returnedValue) ? returnedValue : instance;&#13;
    }&#13;
&#13;
    return {&#13;
      invoke: invoke,&#13;
      instantiate: instantiate,&#13;
      get: getService&#13;
    };&#13;
  }&#13;
}&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$anchorScroll&#13;
 * @requires $window&#13;
 * @requires $location&#13;
 * @requires $rootScope&#13;
 *&#13;
 * @description&#13;
 * When called, it checks current value of `$location.hash()` and scroll to related element,&#13;
 * according to rules specified in&#13;
 * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.&#13;
 *&#13;
 * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.&#13;
 * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.&#13;
 */&#13;
function $AnchorScrollProvider() {&#13;
&#13;
  var autoScrollingEnabled = true;&#13;
&#13;
  this.disableAutoScrolling = function() {&#13;
    autoScrollingEnabled = false;&#13;
  };&#13;
&#13;
  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {&#13;
    var document = $window.document;&#13;
&#13;
    // helper function to get first anchor from a NodeList&#13;
    // can't use filter.filter, as it accepts only instances of Array&#13;
    // and IE can't convert NodeList to an array using [].slice&#13;
    // TODO(vojta): use filter if we change it to accept lists as well&#13;
    function getFirstAnchor(list) {&#13;
      var result = null;&#13;
      forEach(list, function(element) {&#13;
        if (!result &amp;&amp; lowercase(element.nodeName) === 'a') result = element;&#13;
      });&#13;
      return result;&#13;
    }&#13;
&#13;
    function scroll() {&#13;
      var hash = $location.hash(), elm;&#13;
&#13;
      // empty hash, scroll to the top of the page&#13;
      if (!hash) $window.scrollTo(0, 0);&#13;
&#13;
      // element with given id&#13;
      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();&#13;
&#13;
      // first anchor with given name :-D&#13;
      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();&#13;
&#13;
      // no element and hash == 'top', scroll to the top of the page&#13;
      else if (hash === 'top') $window.scrollTo(0, 0);&#13;
    }&#13;
&#13;
    // does not scroll when user clicks on anchor link that is currently on&#13;
    // (no url change, no $locaiton.hash() change), browser native does scroll&#13;
    if (autoScrollingEnabled) {&#13;
      $rootScope.$watch(function() {return $location.hash();}, function() {&#13;
        $rootScope.$evalAsync(scroll);&#13;
      });&#13;
    }&#13;
&#13;
    return scroll;&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$browser&#13;
 * @requires $log&#13;
 * @description&#13;
 * This object has two goals:&#13;
 *&#13;
 * - hide all the global state in the browser caused by the window object&#13;
 * - abstract away all the browser specific features and inconsistencies&#13;
 *&#13;
 * For tests we provide {@link angular.module.ngMock.$browser mock implementation} of the `$browser`&#13;
 * service, which can be used for convenient testing of the application without the interaction with&#13;
 * the real browser apis.&#13;
 */&#13;
/**&#13;
 * @param {object} window The global window object.&#13;
 * @param {object} document jQuery wrapped document.&#13;
 * @param {object} body jQuery wrapped document.body.&#13;
 * @param {function()} XHR XMLHttpRequest constructor.&#13;
 * @param {object} $log console.log or an object with the same interface.&#13;
 * @param {object} $sniffer $sniffer service&#13;
 */&#13;
function Browser(window, document, body, $log, $sniffer) {&#13;
  var self = this,&#13;
      rawDocument = document[0],&#13;
      location = window.location,&#13;
      history = window.history,&#13;
      setTimeout = window.setTimeout,&#13;
      clearTimeout = window.clearTimeout,&#13;
      pendingDeferIds = {};&#13;
&#13;
  self.isMock = false;&#13;
&#13;
  var outstandingRequestCount = 0;&#13;
  var outstandingRequestCallbacks = [];&#13;
&#13;
  // TODO(vojta): remove this temporary api&#13;
  self.$$completeOutstandingRequest = completeOutstandingRequest;&#13;
  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };&#13;
&#13;
  /**&#13;
   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`&#13;
   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.&#13;
   */&#13;
  function completeOutstandingRequest(fn) {&#13;
    try {&#13;
      fn.apply(null, sliceArgs(arguments, 1));&#13;
    } finally {&#13;
      outstandingRequestCount--;&#13;
      if (outstandingRequestCount === 0) {&#13;
        while(outstandingRequestCallbacks.length) {&#13;
          try {&#13;
            outstandingRequestCallbacks.pop()();&#13;
          } catch (e) {&#13;
            $log.error(e);&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @private&#13;
   * Note: this method is used only by scenario runner&#13;
   * TODO(vojta): prefix this method with $$ ?&#13;
   * @param {function()} callback Function that will be called when no outstanding request&#13;
   */&#13;
  self.notifyWhenNoOutstandingRequests = function(callback) {&#13;
    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire&#13;
    // at some deterministic time in respect to the test runner's actions. Leaving things up to the&#13;
    // regular poller would result in flaky tests.&#13;
    forEach(pollFns, function(pollFn){ pollFn(); });&#13;
&#13;
    if (outstandingRequestCount === 0) {&#13;
      callback();&#13;
    } else {&#13;
      outstandingRequestCallbacks.push(callback);&#13;
    }&#13;
  };&#13;
&#13;
  //////////////////////////////////////////////////////////////&#13;
  // Poll Watcher API&#13;
  //////////////////////////////////////////////////////////////&#13;
  var pollFns = [],&#13;
      pollTimeout;&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$browser#addPollFn&#13;
   * @methodOf angular.module.ng.$browser&#13;
   *&#13;
   * @param {function()} fn Poll function to add&#13;
   *&#13;
   * @description&#13;
   * Adds a function to the list of functions that poller periodically executes,&#13;
   * and starts polling if not started yet.&#13;
   *&#13;
   * @returns {function()} the added function&#13;
   */&#13;
  self.addPollFn = function(fn) {&#13;
    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);&#13;
    pollFns.push(fn);&#13;
    return fn;&#13;
  };&#13;
&#13;
  /**&#13;
   * @param {number} interval How often should browser call poll functions (ms)&#13;
   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.&#13;
   *&#13;
   * @description&#13;
   * Configures the poller to run in the specified intervals, using the specified&#13;
   * setTimeout fn and kicks it off.&#13;
   */&#13;
  function startPoller(interval, setTimeout) {&#13;
    (function check() {&#13;
      forEach(pollFns, function(pollFn){ pollFn(); });&#13;
      pollTimeout = setTimeout(check, interval);&#13;
    })();&#13;
  }&#13;
&#13;
  //////////////////////////////////////////////////////////////&#13;
  // URL API&#13;
  //////////////////////////////////////////////////////////////&#13;
&#13;
  var lastBrowserUrl = location.href;&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$browser#url&#13;
   * @methodOf angular.module.ng.$browser&#13;
   *&#13;
   * @description&#13;
   * GETTER:&#13;
   * Without any argument, this method just returns current value of location.href.&#13;
   *&#13;
   * SETTER:&#13;
   * With at least one argument, this method sets url to new value.&#13;
   * If html5 history api supported, pushState/replaceState is used, otherwise&#13;
   * location.href/location.replace is used.&#13;
   * Returns its own instance to allow chaining&#13;
   *&#13;
   * NOTE: this api is intended for use only by the $location service. Please use the&#13;
   * {@link angular.module.ng.$location $location service} to change url.&#13;
   *&#13;
   * @param {string} url New url (when used as setter)&#13;
   * @param {boolean=} replace Should new url replace current history record ?&#13;
   */&#13;
  self.url = function(url, replace) {&#13;
    // setter&#13;
    if (url) {&#13;
      lastBrowserUrl = url;&#13;
      if ($sniffer.history) {&#13;
        if (replace) history.replaceState(null, '', url);&#13;
        else history.pushState(null, '', url);&#13;
      } else {&#13;
        if (replace) location.replace(url);&#13;
        else location.href = url;&#13;
      }&#13;
      return self;&#13;
    // getter&#13;
    } else {&#13;
      return location.href;&#13;
    }&#13;
  };&#13;
&#13;
  var urlChangeListeners = [],&#13;
      urlChangeInit = false;&#13;
&#13;
  function fireUrlChange() {&#13;
    if (lastBrowserUrl == self.url()) return;&#13;
&#13;
    lastBrowserUrl = self.url();&#13;
    forEach(urlChangeListeners, function(listener) {&#13;
      listener(self.url());&#13;
    });&#13;
  }&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$browser#onUrlChange&#13;
   * @methodOf angular.module.ng.$browser&#13;
   * @TODO(vojta): refactor to use node's syntax for events&#13;
   *&#13;
   * @description&#13;
   * Register callback function that will be called, when url changes.&#13;
   *&#13;
   * It's only called when the url is changed by outside of angular:&#13;
   * - user types different url into address bar&#13;
   * - user clicks on history (forward/back) button&#13;
   * - user clicks on a link&#13;
   *&#13;
   * It's not called when url is changed by $browser.url() method&#13;
   *&#13;
   * The listener gets called with new url as parameter.&#13;
   *&#13;
   * NOTE: this api is intended for use only by the $location service. Please use the&#13;
   * {@link angular.module.ng.$location $location service} to monitor url changes in angular apps.&#13;
   *&#13;
   * @param {function(string)} listener Listener function to be called when url changes.&#13;
   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.&#13;
   */&#13;
  self.onUrlChange = function(callback) {&#13;
    if (!urlChangeInit) {&#13;
      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)&#13;
      // don't fire popstate when user change the address bar and don't fire hashchange when url&#13;
      // changed by push/replaceState&#13;
&#13;
      // html5 history api - popstate event&#13;
      if ($sniffer.history) jqLite(window).bind('popstate', fireUrlChange);&#13;
      // hashchange event&#13;
      if ($sniffer.hashchange) jqLite(window).bind('hashchange', fireUrlChange);&#13;
      // polling&#13;
      else self.addPollFn(fireUrlChange);&#13;
&#13;
      urlChangeInit = true;&#13;
    }&#13;
&#13;
    urlChangeListeners.push(callback);&#13;
    return callback;&#13;
  };&#13;
&#13;
  //////////////////////////////////////////////////////////////&#13;
  // Cookies API&#13;
  //////////////////////////////////////////////////////////////&#13;
  var lastCookies = {};&#13;
  var lastCookieString = '';&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$browser#cookies&#13;
   * @methodOf angular.module.ng.$browser&#13;
   *&#13;
   * @param {string=} name Cookie name&#13;
   * @param {string=} value Cokkie value&#13;
   *&#13;
   * @description&#13;
   * The cookies method provides a 'private' low level access to browser cookies.&#13;
   * It is not meant to be used directly, use the $cookie service instead.&#13;
   *&#13;
   * The return values vary depending on the arguments that the method was called with as follows:&#13;
   * &lt;ul&gt;&#13;
   *   &lt;li&gt;cookies() -&gt; hash of all cookies, this is NOT a copy of the internal state, so do not modify it&lt;/li&gt;&#13;
   *   &lt;li&gt;cookies(name, value) -&gt; set name to value, if value is undefined delete the cookie&lt;/li&gt;&#13;
   *   &lt;li&gt;cookies(name) -&gt; the same as (name, undefined) == DELETES (no one calls it right now that way)&lt;/li&gt;&#13;
   * &lt;/ul&gt;&#13;
   *&#13;
   * @returns {Object} Hash of all cookies (if called without any parameter)&#13;
   */&#13;
  self.cookies = function(name, value) {&#13;
    var cookieLength, cookieArray, cookie, i, keyValue, index;&#13;
&#13;
    if (name) {&#13;
      if (value === undefined) {&#13;
        rawDocument.cookie = escape(name) + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT";&#13;
      } else {&#13;
        if (isString(value)) {&#13;
          rawDocument.cookie = escape(name) + '=' + escape(value);&#13;
&#13;
          cookieLength = name.length + value.length + 1;&#13;
          if (cookieLength &gt; 4096) {&#13;
            $log.warn("Cookie '"+ name +"' possibly not set or overflowed because it was too large ("+&#13;
              cookieLength + " &gt; 4096 bytes)!");&#13;
          }&#13;
          if (lastCookies.length &gt; 20) {&#13;
            $log.warn("Cookie '"+ name +"' possibly not set or overflowed because too many cookies " +&#13;
              "were already set (" + lastCookies.length + " &gt; 20 )");&#13;
          }&#13;
        }&#13;
      }&#13;
    } else {&#13;
      if (rawDocument.cookie !== lastCookieString) {&#13;
        lastCookieString = rawDocument.cookie;&#13;
        cookieArray = lastCookieString.split("; ");&#13;
        lastCookies = {};&#13;
&#13;
        for (i = 0; i &lt; cookieArray.length; i++) {&#13;
          cookie = cookieArray[i];&#13;
          index = cookie.indexOf('=');&#13;
          if (index &gt; 0) { //ignore nameless cookies&#13;
            lastCookies[unescape(cookie.substring(0, index))] = unescape(cookie.substring(index + 1));&#13;
          }&#13;
        }&#13;
      }&#13;
      return lastCookies;&#13;
    }&#13;
  };&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$browser#defer&#13;
   * @methodOf angular.module.ng.$browser&#13;
   * @param {function()} fn A function, who's execution should be defered.&#13;
   * @param {number=} [delay=0] of milliseconds to defer the function execution.&#13;
   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.&#13;
   *&#13;
   * @description&#13;
   * Executes a fn asynchroniously via `setTimeout(fn, delay)`.&#13;
   *&#13;
   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using&#13;
   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed&#13;
   * via `$browser.defer.flush()`.&#13;
   *&#13;
   */&#13;
  self.defer = function(fn, delay) {&#13;
    var timeoutId;&#13;
    outstandingRequestCount++;&#13;
    timeoutId = setTimeout(function() {&#13;
      delete pendingDeferIds[timeoutId];&#13;
      completeOutstandingRequest(fn);&#13;
    }, delay || 0);&#13;
    pendingDeferIds[timeoutId] = true;&#13;
    return timeoutId;&#13;
  };&#13;
&#13;
&#13;
  /**&#13;
   * THIS DOC IS NOT VISIBLE because ngdocs can't process docs for foo#method.method&#13;
   *&#13;
   * @name angular.module.ng.$browser#defer.cancel&#13;
   * @methodOf angular.module.ng.$browser.defer&#13;
   *&#13;
   * @description&#13;
   * Cancels a defered task identified with `deferId`.&#13;
   *&#13;
   * @param {*} deferId Token returned by the `$browser.defer` function.&#13;
   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfuly canceled.&#13;
   */&#13;
  self.defer.cancel = function(deferId) {&#13;
    if (pendingDeferIds[deferId]) {&#13;
      delete pendingDeferIds[deferId];&#13;
      clearTimeout(deferId);&#13;
      completeOutstandingRequest(noop);&#13;
      return true;&#13;
    }&#13;
    return false;&#13;
  };&#13;
&#13;
&#13;
  //////////////////////////////////////////////////////////////&#13;
  // Misc API&#13;
  //////////////////////////////////////////////////////////////&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$browser#addCss&#13;
   * @methodOf angular.module.ng.$browser&#13;
   *&#13;
   * @param {string} url Url to css file&#13;
   * @description&#13;
   * Adds a stylesheet tag to the head.&#13;
   */&#13;
  self.addCss = function(url) {&#13;
    var link = jqLite(rawDocument.createElement('link'));&#13;
    link.attr('rel', 'stylesheet');&#13;
    link.attr('type', 'text/css');&#13;
    link.attr('href', url);&#13;
    body.append(link);&#13;
  };&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$browser#addJs&#13;
   * @methodOf angular.module.ng.$browser&#13;
   *&#13;
   * @param {string} url Url to js file&#13;
   *&#13;
   * @description&#13;
   * Adds a script tag to the head.&#13;
   */&#13;
  self.addJs = function(url, done) {&#13;
    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:&#13;
    // - fetches local scripts via XHR and evals them&#13;
    // - adds and immediately removes script elements from the document&#13;
    var script = rawDocument.createElement('script');&#13;
&#13;
    script.type = 'text/javascript';&#13;
    script.src = url;&#13;
&#13;
    if (msie) {&#13;
      script.onreadystatechange = function() {&#13;
        /loaded|complete/.test(script.readyState) &amp;&amp; done &amp;&amp; done();&#13;
      };&#13;
    } else {&#13;
      if (done) script.onload = script.onerror = done;&#13;
    }&#13;
&#13;
    body[0].appendChild(script);&#13;
&#13;
    return script;&#13;
  };&#13;
&#13;
  /**&#13;
   * Returns current &lt;base href&gt;&#13;
   * (always relative - without domain)&#13;
   *&#13;
   * @returns {string=}&#13;
   */&#13;
  self.baseHref = function() {&#13;
    var href = document.find('base').attr('href');&#13;
    return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : href;&#13;
  };&#13;
}&#13;
&#13;
function $BrowserProvider(){&#13;
  this.$get = ['$window', '$log', '$sniffer', '$document',&#13;
      function( $window,   $log,   $sniffer,   $document){&#13;
        return new Browser($window, $document, $document.find('body'), $log, $sniffer);&#13;
      }];&#13;
}&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$cacheFactory&#13;
 *&#13;
 * @description&#13;
 * Factory that constructs cache objects.&#13;
 *&#13;
 *&#13;
 * @param {string} cacheId Name or id of the newly created cache.&#13;
 * @param {object=} options Options object that specifies the cache behavior. Properties:&#13;
 *&#13;
 *   - `{number=}` `capacity` â€" turns the cache into LRU cache.&#13;
 *&#13;
 * @returns {object} Newly created cache object with the following set of methods:&#13;
 *&#13;
 * - `{object}` `info()` â€" Returns id, size, and options of cache.&#13;
 * - `{void}` `put({string} key, {*} value)` â€" Puts a new key-value pair into the cache.&#13;
 * - `{{*}} `get({string} key) â€" Returns cached value for `key` or undefined for cache miss.&#13;
 * - `{void}` `remove({string} key) â€" Removes a key-value pair from the cache.&#13;
 * - `{void}` `removeAll() â€" Removes all cached values.&#13;
 * - `{void}` `destroy() â€" Removes references to this cache from $cacheFactory.&#13;
 *&#13;
 */&#13;
function $CacheFactoryProvider() {&#13;
&#13;
  this.$get = function() {&#13;
    var caches = {};&#13;
&#13;
    function cacheFactory(cacheId, options) {&#13;
      if (cacheId in caches) {&#13;
        throw Error('cacheId ' + cacheId + ' taken');&#13;
      }&#13;
&#13;
      var size = 0,&#13;
          stats = extend({}, options, {id: cacheId}),&#13;
          data = {},&#13;
          capacity = (options &amp;&amp; options.capacity) || Number.MAX_VALUE,&#13;
          lruHash = {},&#13;
          freshEnd = null,&#13;
          staleEnd = null;&#13;
&#13;
      return caches[cacheId] = {&#13;
&#13;
        put: function(key, value) {&#13;
          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});&#13;
&#13;
          refresh(lruEntry);&#13;
&#13;
          if (isUndefined(value)) return;&#13;
          if (!(key in data)) size++;&#13;
          data[key] = value;&#13;
&#13;
          if (size &gt; capacity) {&#13;
            this.remove(staleEnd.key);&#13;
          }&#13;
        },&#13;
&#13;
&#13;
        get: function(key) {&#13;
          var lruEntry = lruHash[key];&#13;
&#13;
          if (!lruEntry) return;&#13;
&#13;
          refresh(lruEntry);&#13;
&#13;
          return data[key];&#13;
        },&#13;
&#13;
&#13;
        remove: function(key) {&#13;
          var lruEntry = lruHash[key];&#13;
&#13;
          if (lruEntry == freshEnd) freshEnd = lruEntry.p;&#13;
          if (lruEntry == staleEnd) staleEnd = lruEntry.n;&#13;
          link(lruEntry.n,lruEntry.p);&#13;
&#13;
          delete lruHash[key];&#13;
          delete data[key];&#13;
          size--;&#13;
        },&#13;
&#13;
&#13;
        removeAll: function() {&#13;
          data = {};&#13;
          size = 0;&#13;
          lruHash = {};&#13;
          freshEnd = staleEnd = null;&#13;
        },&#13;
&#13;
&#13;
        destroy: function() {&#13;
          data = null;&#13;
          stats = null;&#13;
          lruHash = null;&#13;
          delete caches[cacheId];&#13;
        },&#13;
&#13;
&#13;
        info: function() {&#13;
          return extend({}, stats, {size: size});&#13;
        }&#13;
      };&#13;
&#13;
&#13;
      /**&#13;
       * makes the `entry` the freshEnd of the LRU linked list&#13;
       */&#13;
      function refresh(entry) {&#13;
        if (entry != freshEnd) {&#13;
          if (!staleEnd) {&#13;
            staleEnd = entry;&#13;
          } else if (staleEnd == entry) {&#13;
            staleEnd = entry.n;&#13;
          }&#13;
&#13;
          link(entry.n, entry.p);&#13;
          link(entry, freshEnd);&#13;
          freshEnd = entry;&#13;
          freshEnd.n = null;&#13;
        }&#13;
      }&#13;
&#13;
&#13;
      /**&#13;
       * bidirectionally links two entries of the LRU linked list&#13;
       */&#13;
      function link(nextEntry, prevEntry) {&#13;
        if (nextEntry != prevEntry) {&#13;
          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify&#13;
          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    cacheFactory.info = function() {&#13;
      var info = {};&#13;
      forEach(caches, function(cache, cacheId) {&#13;
        info[cacheId] = cache.info();&#13;
      });&#13;
      return info;&#13;
    };&#13;
&#13;
&#13;
    cacheFactory.get = function(cacheId) {&#13;
      return caches[cacheId];&#13;
    };&#13;
&#13;
&#13;
    return cacheFactory;&#13;
  };&#13;
}&#13;
&#13;
function $TemplateCacheProvider() {&#13;
  this.$get = ['$cacheFactory', function($cacheFactory) {&#13;
    return $cacheFactory('templates');&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$compile&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Compiles a piece of HTML string or DOM into a template and produces a template function, which&#13;
 * can then be used to link {@link angular.module.ng.$rootScope.Scope scope} and the template together.&#13;
 *&#13;
 * The compilation is a process of walking the DOM tree and trying to match DOM elements to&#13;
 * {@link angular.module.ng.$compileProvider.directive directives}. For each match it&#13;
 * executes corresponding template function and collects the&#13;
 * instance functions into a single template function which is then returned.&#13;
 *&#13;
 * The template function can then be used once to produce the view or as it is the case with&#13;
 * {@link angular.module.ng.$compileProvider.directive.ng-repeat repeater} many-times, in which&#13;
 * case each call results in a view that is a DOM clone of the original template.&#13;
 *&#13;
 &lt;doc:example module="compile"&gt;&#13;
   &lt;doc:source&gt;&#13;
    &lt;script&gt;&#13;
      // declare a new module, and inject the $compileProvider&#13;
      angular.module('compile', [], function($compileProvider) {&#13;
        // configure new 'compile' directive by passing a directive&#13;
        // factory function. The factory function injects the '$compile'&#13;
        $compileProvider.directive('compile', function($compile) {&#13;
          // directive factory creates a link function&#13;
          return function(scope, element, attrs) {&#13;
            scope.$watch(&#13;
              function(scope) {&#13;
                 // watch the 'compile' expression for changes&#13;
                return scope.$eval(attrs.compile);&#13;
              },&#13;
              function(value) {&#13;
                // when the 'compile' expression changes&#13;
                // assign it into the current DOM&#13;
                element.html(value);&#13;
&#13;
                // compile the new DOM and link it to the current&#13;
                // scope.&#13;
                // NOTE: we only compile .childNodes so that&#13;
                // we don't get into infinite loop compiling ourselves&#13;
                $compile(element.contents())(scope);&#13;
              }&#13;
            );&#13;
          };&#13;
        })&#13;
      });&#13;
&#13;
      function Ctrl($scope) {&#13;
        $scope.name = 'Angular';&#13;
        $scope.html = 'Hello {{name}}';&#13;
      }&#13;
    &lt;/script&gt;&#13;
    &lt;div ng-controller="Ctrl"&gt;&#13;
      &lt;input ng-model="name"&gt; &lt;br&gt;&#13;
      &lt;textarea ng-model="html"&gt;&lt;/textarea&gt; &lt;br&gt;&#13;
      &lt;div compile="html"&gt;&lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
   &lt;/doc:source&gt;&#13;
   &lt;doc:scenario&gt;&#13;
     it('should auto compile', function() {&#13;
       expect(element('div[compile]').text()).toBe('Hello Angular');&#13;
       input('html').enter('{{name}}!');&#13;
       expect(element('div[compile]').text()).toBe('Angular!');&#13;
     });&#13;
   &lt;/doc:scenario&gt;&#13;
 &lt;/doc:example&gt;&#13;
&#13;
 *&#13;
 *&#13;
 * @param {string|DOMElement} element Element or HTML string to compile into a template function.&#13;
 * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.&#13;
 * @param {number} maxPriority only apply directives lower then given priority (Only effects the&#13;
 *                 root element(s), not their children)&#13;
 * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template&#13;
 * (a DOM element/tree) to a scope. Where:&#13;
 *&#13;
 *  * `scope` - A {@link angular.module.ng.$rootScope.Scope Scope} to bind to.&#13;
 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the&#13;
 *               `template` and call the `cloneAttachFn` function allowing the caller to attach the&#13;
 *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is&#13;
 *               called as: &lt;br&gt; `cloneAttachFn(clonedElement, scope)` where:&#13;
 *&#13;
 *      * `clonedElement` - is a clone of the original `element` passed into the compiler.&#13;
 *      * `scope` - is the current scope with which the linking function is working with.&#13;
 *&#13;
 * Calling the linking function returns the element of the template. It is either the original element&#13;
 * passed in, or the clone of the element if the `cloneAttachFn` is provided.&#13;
 *&#13;
 * After linking the view is not updateh until after a call to $digest which typically is done by&#13;
 * Angular automatically.&#13;
 *&#13;
 * If you need access to the bound view, there are two ways to do it:&#13;
 *&#13;
 * - If you are not asking the linking function to clone the template, create the DOM element(s)&#13;
 *   before you send them to the compiler and keep this reference around.&#13;
 *   &lt;pre&gt;&#13;
 *     var element = $compile('&lt;p&gt;{{total}}&lt;/p&gt;')(scope);&#13;
 *   &lt;/pre&gt;&#13;
 *&#13;
 * - if on the other hand, you need the element to be cloned, the view reference from the original&#13;
 *   example would not point to the clone, but rather to the original template that was cloned. In&#13;
 *   this case, you can access the clone via the cloneAttachFn:&#13;
 *   &lt;pre&gt;&#13;
 *     var templateHTML = angular.element('&lt;p&gt;{{total}}&lt;/p&gt;'),&#13;
 *         scope = ....;&#13;
 *&#13;
 *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {&#13;
 *       //attach the clone to DOM document at the right place&#13;
 *     });&#13;
 *&#13;
 *     //now we have reference to the cloned DOM via `clone`&#13;
 *   &lt;/pre&gt;&#13;
 *&#13;
 *&#13;
 * For information on how the compiler works, see the&#13;
 * {@link guide/dev_guide.compiler Angular HTML Compiler} section of the Developer Guide.&#13;
 */&#13;
&#13;
&#13;
$CompileProvider.$inject = ['$provide'];&#13;
function $CompileProvider($provide) {&#13;
  var hasDirectives = {},&#13;
      Suffix = 'Directive',&#13;
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,&#13;
      CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,&#13;
      CONTENT_REGEXP = /\&lt;\&lt;content\&gt;\&gt;/i,&#13;
      HAS_ROOT_ELEMENT = /^\&lt;[\s\S]*\&gt;$/;&#13;
&#13;
&#13;
  this.directive = function registerDirective(name, directiveFactory) {&#13;
    if (isString(name)) {&#13;
      assertArg(directiveFactory, 'directive');&#13;
      if (!hasDirectives.hasOwnProperty(name)) {&#13;
        hasDirectives[name] = [];&#13;
        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',&#13;
          function($injector, $exceptionHandler) {&#13;
            var directives = [];&#13;
            forEach(hasDirectives[name], function(directiveFactory) {&#13;
              try {&#13;
                var directive = $injector.invoke(directiveFactory);&#13;
                if (isFunction(directive)) {&#13;
                  directive = { compile: valueFn(directive) };&#13;
                } else if (!directive.compile &amp;&amp; directive.link) {&#13;
                  directive.compile = valueFn(directive.link);&#13;
                }&#13;
                directive.priority = directive.priority || 0;&#13;
                directive.name = directive.name || name;&#13;
                directive.require = directive.require || (directive.controller &amp;&amp; directive.name);&#13;
                directive.restrict = directive.restrict || 'A';&#13;
                directives.push(directive);&#13;
              } catch (e) {&#13;
                $exceptionHandler(e);&#13;
              }&#13;
            });&#13;
            return directives;&#13;
          }]);&#13;
      }&#13;
      hasDirectives[name].push(directiveFactory);&#13;
    } else {&#13;
      forEach(name, reverseParams(registerDirective));&#13;
    }&#13;
    return this;&#13;
  };&#13;
&#13;
&#13;
  this.$get = [&#13;
            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',&#13;
            '$controller',&#13;
    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,&#13;
             $controller) {&#13;
&#13;
    var LOCAL_MODE = {&#13;
      attribute: function(localName, mode, parentScope, scope, attr) {&#13;
        scope[localName] = attr[localName];&#13;
      },&#13;
&#13;
      evaluate: function(localName, mode, parentScope, scope, attr) {&#13;
        scope[localName] = parentScope.$eval(attr[localName]);&#13;
      },&#13;
&#13;
      bind: function(localName, mode, parentScope, scope, attr) {&#13;
        var getter = $interpolate(attr[localName]);&#13;
        scope.$watch(&#13;
          function() { return getter(parentScope); },&#13;
          function(v) { scope[localName] = v; }&#13;
        );&#13;
      },&#13;
&#13;
      accessor: function(localName, mode, parentScope, scope, attr) {&#13;
        var getter = noop,&#13;
            setter = noop,&#13;
            exp = attr[localName];&#13;
&#13;
        if (exp) {&#13;
          getter = $parse(exp);&#13;
          setter = getter.assign || function() {&#13;
            throw Error("Expression '" + exp + "' not assignable.");&#13;
          };&#13;
        }&#13;
&#13;
        scope[localName] = function(value) {&#13;
          return arguments.length ? setter(parentScope, value) : getter(parentScope);&#13;
        };&#13;
      },&#13;
&#13;
      expression: function(localName, mode, parentScope, scope, attr) {&#13;
        scope[localName] = function(locals) {&#13;
          $parse(attr[localName])(parentScope, locals);&#13;
        };&#13;
      }&#13;
    };&#13;
&#13;
    var Attributes = function(element, attr) {&#13;
      this.$$element = element;&#13;
      this.$$observers = {};&#13;
      this.$attr = attr || {};&#13;
    };&#13;
&#13;
    Attributes.prototype = {&#13;
      $normalize: directiveNormalize,&#13;
&#13;
&#13;
      /**&#13;
       * Set a normalized attribute on the element in a way such that all directives&#13;
       * can share the attribute. This function properly handles boolean attributes.&#13;
       * @param {string} key Normalized key. (ie ngAttribute)&#13;
       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.&#13;
       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.&#13;
       *     Defaults to true.&#13;
       * @param {string=} attrName Optional none normalized name. Defaults to key.&#13;
       */&#13;
      $set: function(key, value, writeAttr, attrName) {&#13;
        var booleanKey = isBooleanAttr(this.$$element[0], key.toLowerCase());&#13;
&#13;
        if (booleanKey) {&#13;
          this.$$element.prop(key, value);&#13;
          attrName = booleanKey;&#13;
        }&#13;
&#13;
        this[key] = value;&#13;
&#13;
        // translate normalized key to actual key&#13;
        if (attrName) {&#13;
          this.$attr[key] = attrName;&#13;
        } else {&#13;
          attrName = this.$attr[key];&#13;
          if (!attrName) {&#13;
            this.$attr[key] = attrName = snake_case(key, '-');&#13;
          }&#13;
        }&#13;
&#13;
        if (writeAttr !== false) {&#13;
          if (value === null || value === undefined) {&#13;
            this.$$element.removeAttr(attrName);&#13;
          } else {&#13;
            this.$$element.attr(attrName, value);&#13;
          }&#13;
        }&#13;
&#13;
        // fire observers&#13;
        forEach(this.$$observers[key], function(fn) {&#13;
          try {&#13;
            fn(value);&#13;
          } catch (e) {&#13;
            $exceptionHandler(e);&#13;
          }&#13;
        });&#13;
      },&#13;
&#13;
&#13;
      /**&#13;
       * Observe an interpolated attribute.&#13;
       * The observer will never be called, if given attribute is not interpolated.&#13;
       *&#13;
       * @param {string} key Normalized key. (ie ngAttribute) .&#13;
       * @param {function(*)} fn Function that will be called whenever the attribute value changes.&#13;
       */&#13;
      $observe: function(key, fn) {&#13;
        // keep only observers for interpolated attrs&#13;
        if (this.$$observers[key]) {&#13;
          this.$$observers[key].push(fn);&#13;
        }&#13;
      }&#13;
    };&#13;
&#13;
    return compile;&#13;
&#13;
    //================================&#13;
&#13;
    function compile(templateElement, transcludeFn, maxPriority) {&#13;
      if (!(templateElement instanceof jqLite)) {&#13;
        // jquery always rewraps, where as we need to preserve the original selector so that we can modify it.&#13;
        templateElement = jqLite(templateElement);&#13;
      }&#13;
      // We can not compile top level text elements since text nodes can be merged and we will&#13;
      // not be able to attach scope data to them, so we will wrap them in &lt;span&gt;&#13;
      forEach(templateElement, function(node, index){&#13;
        if (node.nodeType == 3 /* text node */) {&#13;
          templateElement[index] = jqLite(node).wrap('&lt;span&gt;').parent()[0];&#13;
        }&#13;
      });&#13;
      var linkingFn = compileNodes(templateElement, transcludeFn, templateElement, maxPriority);&#13;
      return function(scope, cloneConnectFn){&#13;
        assertArg(scope, 'scope');&#13;
        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart&#13;
        // and sometimes changes the structure of the DOM.&#13;
        var element = cloneConnectFn&#13;
          ? JQLitePrototype.clone.call(templateElement) // IMPORTANT!!!&#13;
          : templateElement;&#13;
        safeAddClass(element.data('$scope', scope), 'ng-scope');&#13;
        if (cloneConnectFn) cloneConnectFn(element, scope);&#13;
        if (linkingFn) linkingFn(scope, element, element);&#13;
        return element;&#13;
      };&#13;
    }&#13;
&#13;
    function wrongMode(localName, mode) {&#13;
      throw Error("Unsupported '" + mode + "' for '" + localName + "'.");&#13;
    }&#13;
&#13;
    function safeAddClass(element, className) {&#13;
      try {&#13;
        element.addClass(className);&#13;
      } catch(e) {&#13;
        // ignore, since it means that we are trying to set class on&#13;
        // SVG element, where class name is read-only.&#13;
      }&#13;
    }&#13;
&#13;
    /**&#13;
     * Compile function matches each node in nodeList against the directives. Once all directives&#13;
     * for a particular node are collected their compile functions are executed. The compile&#13;
     * functions return values - the linking functions - are combined into a composite linking&#13;
     * function, which is the a linking function for the node.&#13;
     *&#13;
     * @param {NodeList} nodeList an array of nodes to compile&#13;
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the&#13;
     *        scope argument is auto-generated to the new child of the transcluded parent scope.&#13;
     * @param {DOMElement=} rootElement If the nodeList is the root of the compilation tree then the&#13;
     *        rootElement must be set the jqLite collection of the compile root. This is&#13;
     *        needed so that the jqLite collection items can be replaced with widgets.&#13;
     * @param {number=} max directive priority&#13;
     * @returns {?function} A composite linking function of all of the matched directives or null.&#13;
     */&#13;
    function compileNodes(nodeList, transcludeFn, rootElement, maxPriority) {&#13;
     var linkingFns = [],&#13;
         directiveLinkingFn, childLinkingFn, directives, attrs, linkingFnFound;&#13;
&#13;
     for(var i = 0; i &lt; nodeList.length; i++) {&#13;
       attrs = new Attributes();&#13;
&#13;
       // we must always refer to nodeList[i] since the nodes can be replaced underneath us.&#13;
       directives = collectDirectives(nodeList[i], [], attrs, maxPriority);&#13;
&#13;
       directiveLinkingFn = (directives.length)&#13;
           ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, rootElement)&#13;
           : null;&#13;
&#13;
       childLinkingFn = (directiveLinkingFn &amp;&amp; directiveLinkingFn.terminal)&#13;
           ? null&#13;
           : compileNodes(nodeList[i].childNodes,&#13;
                directiveLinkingFn ? directiveLinkingFn.transclude : transcludeFn);&#13;
&#13;
       linkingFns.push(directiveLinkingFn);&#13;
       linkingFns.push(childLinkingFn);&#13;
       linkingFnFound = (linkingFnFound || directiveLinkingFn || childLinkingFn);&#13;
     }&#13;
&#13;
     // return a linking function if we have found anything, null otherwise&#13;
     return linkingFnFound ? linkingFn : null;&#13;
&#13;
     /* nodesetLinkingFn */ function linkingFn(scope, nodeList, rootElement, boundTranscludeFn) {&#13;
       var childLinkingFn, directiveLinkingFn, node, childScope, childTransclusionFn;&#13;
&#13;
       for(var i=0, n=0, ii=linkingFns.length; i&lt;ii; n++) {&#13;
         node = nodeList[n];&#13;
         directiveLinkingFn = /* directiveLinkingFn */ linkingFns[i++];&#13;
         childLinkingFn = /* nodesetLinkingFn */ linkingFns[i++];&#13;
&#13;
         if (directiveLinkingFn) {&#13;
           if (directiveLinkingFn.scope) {&#13;
             childScope = scope.$new(isObject(directiveLinkingFn.scope));&#13;
             jqLite(node).data('$scope', childScope);&#13;
           } else {&#13;
             childScope = scope;&#13;
           }&#13;
           childTransclusionFn = directiveLinkingFn.transclude;&#13;
           if (childTransclusionFn || (!boundTranscludeFn &amp;&amp; transcludeFn)) {&#13;
             directiveLinkingFn(childLinkingFn, childScope, node, rootElement,&#13;
                 (function(transcludeFn) {&#13;
                   return function(cloneFn) {&#13;
                     var transcludeScope = scope.$new();&#13;
&#13;
                     return transcludeFn(transcludeScope, cloneFn).&#13;
                         bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));&#13;
                    };&#13;
                  })(childTransclusionFn || transcludeFn)&#13;
             );&#13;
           } else {&#13;
             directiveLinkingFn(childLinkingFn, childScope, node, undefined, boundTranscludeFn);&#13;
           }&#13;
         } else if (childLinkingFn) {&#13;
           childLinkingFn(scope, node.childNodes, undefined, boundTranscludeFn);&#13;
         }&#13;
       }&#13;
     }&#13;
   }&#13;
&#13;
&#13;
    /**&#13;
     * Looks for directives on the given node ands them to the directive collection which is sorted.&#13;
     *&#13;
     * @param node node to search&#13;
     * @param directives an array to which the directives are added to. This array is sorted before&#13;
     *        the function returns.&#13;
     * @param attrs the shared attrs object which is used to populate the normalized attributes.&#13;
     * @param {number=} max directive priority&#13;
     */&#13;
    function collectDirectives(node, directives, attrs, maxPriority) {&#13;
      var nodeType = node.nodeType,&#13;
          attrsMap = attrs.$attr,&#13;
          match,&#13;
          className;&#13;
&#13;
      switch(nodeType) {&#13;
        case 1: /* Element */&#13;
          // use the node name: &lt;directive&gt;&#13;
          addDirective(directives,&#13;
              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);&#13;
&#13;
          // iterate over the attributes&#13;
          for (var attr, name, nName, value, nAttrs = node.attributes,&#13;
                   j = 0, jj = nAttrs &amp;&amp; nAttrs.length; j &lt; jj; j++) {&#13;
            attr = nAttrs[j];&#13;
            if (attr.specified) {&#13;
              name = attr.name;&#13;
              nName = directiveNormalize(name.toLowerCase());&#13;
              attrsMap[nName] = name;&#13;
              attrs[nName] = value = trim((msie &amp;&amp; name == 'href')&#13;
                ? decodeURIComponent(node.getAttribute(name, 2))&#13;
                : attr.value);&#13;
              if (isBooleanAttr(node, nName)) {&#13;
                attrs[nName] = true; // presence means true&#13;
              }&#13;
              addAttrInterpolateDirective(node, directives, value, nName)&#13;
              addDirective(directives, nName, 'A', maxPriority);&#13;
            }&#13;
          }&#13;
&#13;
          // use class as directive&#13;
          className = node.className;&#13;
          if (isString(className)) {&#13;
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {&#13;
              nName = directiveNormalize(match[2]);&#13;
              if (addDirective(directives, nName, 'C', maxPriority)) {&#13;
                attrs[nName] = trim(match[3]);&#13;
              }&#13;
              className = className.substr(match.index + match[0].length);&#13;
            }&#13;
          }&#13;
          break;&#13;
        case 3: /* Text Node */&#13;
          addTextInterpolateDirective(directives, node.nodeValue);&#13;
          break;&#13;
        case 8: /* Comment */&#13;
          match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);&#13;
          if (match) {&#13;
            nName = directiveNormalize(match[1]);&#13;
            if (addDirective(directives, nName, 'M', maxPriority)) {&#13;
              attrs[nName] = trim(match[2]);&#13;
            }&#13;
          }&#13;
          break;&#13;
      }&#13;
&#13;
      directives.sort(byPriority);&#13;
      return directives;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * Once the directives have been collected their compile functions is executed. This method&#13;
     * is responsible for inlining directive templates as well as terminating the application&#13;
     * of the directives if the terminal directive has been reached..&#13;
     *&#13;
     * @param {Array} directives Array of collected directives to execute their compile function.&#13;
     *        this needs to be pre-sorted by priority order.&#13;
     * @param {Node} templateNode The raw DOM node to apply the compile functions to&#13;
     * @param {Object} templateAttrs The shared attribute function&#13;
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the&#13;
     *        scope argument is auto-generated to the new child of the transcluded parent scope.&#13;
     * @param {DOMElement} rootElement If we are working on the root of the compile tree then this&#13;
     *        argument has the root jqLite array so that we can replace widgets on it.&#13;
     * @returns linkingFn&#13;
     */&#13;
    function applyDirectivesToNode(directives, templateNode, templateAttrs, transcludeFn, rootElement) {&#13;
      var terminalPriority = -Number.MAX_VALUE,&#13;
          preLinkingFns = [],&#13;
          postLinkingFns = [],&#13;
          newScopeDirective = null,&#13;
          newIsolatedScopeDirective = null,&#13;
          templateDirective = null,&#13;
          delayedLinkingFn = null,&#13;
          element = templateAttrs.$$element = jqLite(templateNode),&#13;
          directive,&#13;
          directiveName,&#13;
          template,&#13;
          transcludeDirective,&#13;
          childTranscludeFn = transcludeFn,&#13;
          controllerDirectives,&#13;
          linkingFn,&#13;
          directiveValue;&#13;
&#13;
      // executes all directives on the current element&#13;
      for(var i = 0, ii = directives.length; i &lt; ii; i++) {&#13;
        directive = directives[i];&#13;
        template = undefined;&#13;
&#13;
        if (terminalPriority &gt; directive.priority) {&#13;
          break; // prevent further processing of directives&#13;
        }&#13;
&#13;
        if (directiveValue = directive.scope) {&#13;
          assertNoDuplicate('isolated scope', newIsolatedScopeDirective, directive, element);&#13;
          if (isObject(directiveValue)) {&#13;
            safeAddClass(element, 'ng-isolate-scope');&#13;
            newIsolatedScopeDirective = directive;&#13;
          }&#13;
          safeAddClass(element, 'ng-scope');&#13;
          newScopeDirective = newScopeDirective || directive;&#13;
        }&#13;
&#13;
        directiveName = directive.name;&#13;
&#13;
        if (directiveValue = directive.controller) {&#13;
          controllerDirectives = controllerDirectives || {};&#13;
          assertNoDuplicate("'" + directiveName + "' controller",&#13;
              controllerDirectives[directiveName], directive, element);&#13;
          controllerDirectives[directiveName] = directive;&#13;
        }&#13;
&#13;
        if (directiveValue = directive.transclude) {&#13;
          assertNoDuplicate('transclusion', transcludeDirective, directive, element);&#13;
          transcludeDirective = directive;&#13;
          terminalPriority = directive.priority;&#13;
          if (directiveValue == 'element') {&#13;
            template = jqLite(templateNode);&#13;
            templateNode = (element = templateAttrs.$$element = jqLite(&#13;
                '&lt;!-- ' + directiveName + ': ' + templateAttrs[directiveName]  + ' --&gt;'))[0];&#13;
            replaceWith(rootElement, jqLite(template[0]), templateNode);&#13;
            childTranscludeFn = compile(template, transcludeFn, terminalPriority);&#13;
          } else {&#13;
            template = jqLite(JQLiteClone(templateNode));&#13;
            element.html(''); // clear contents&#13;
            childTranscludeFn = compile(template.contents(), transcludeFn);&#13;
          }&#13;
        }&#13;
&#13;
        if (directiveValue = directive.template) {&#13;
          assertNoDuplicate('template', templateDirective, directive, element);&#13;
          templateDirective = directive;&#13;
&#13;
          // include the contents of the original element into the template and replace the element&#13;
          var content = directiveValue.replace(CONTENT_REGEXP, element.html());&#13;
          templateNode = jqLite(content)[0];&#13;
          if (directive.replace) {&#13;
            replaceWith(rootElement, element, templateNode);&#13;
&#13;
            var newTemplateAttrs = {$attr: {}};&#13;
&#13;
            // combine directives from the original node and from the template:&#13;
            // - take the array of directives for this element&#13;
            // - split it into two parts, those that were already applied and those that weren't&#13;
            // - collect directives from the template, add them to the second group and sort them&#13;
            // - append the second group with new directives to the first group&#13;
            directives = directives.concat(&#13;
                collectDirectives(&#13;
                    templateNode,&#13;
                    directives.splice(i + 1, directives.length - (i + 1)),&#13;
                    newTemplateAttrs&#13;
                )&#13;
            );&#13;
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);&#13;
&#13;
            ii = directives.length;&#13;
          } else {&#13;
            element.html(content);&#13;
          }&#13;
        }&#13;
&#13;
        if (directive.templateUrl) {&#13;
          assertNoDuplicate('template', templateDirective, directive, element);&#13;
          templateDirective = directive;&#13;
          delayedLinkingFn = compileTemplateUrl(directives.splice(i, directives.length - i),&#13;
              /* directiveLinkingFn */ compositeLinkFn, element, templateAttrs, rootElement,&#13;
              directive.replace, childTranscludeFn);&#13;
          ii = directives.length;&#13;
        } else if (directive.compile) {&#13;
          try {&#13;
            linkingFn = directive.compile(element, templateAttrs, childTranscludeFn);&#13;
            if (isFunction(linkingFn)) {&#13;
              addLinkingFns(null, linkingFn);&#13;
            } else if (linkingFn) {&#13;
              addLinkingFns(linkingFn.pre, linkingFn.post);&#13;
            }&#13;
          } catch (e) {&#13;
            $exceptionHandler(e, startingTag(element));&#13;
          }&#13;
        }&#13;
&#13;
        if (directive.terminal) {&#13;
          compositeLinkFn.terminal = true;&#13;
          terminalPriority = Math.max(terminalPriority, directive.priority);&#13;
        }&#13;
&#13;
      }&#13;
&#13;
      linkingFn = delayedLinkingFn || compositeLinkFn;&#13;
      linkingFn.scope = newScopeDirective &amp;&amp; newScopeDirective.scope;&#13;
      linkingFn.transclude = transcludeDirective &amp;&amp; childTranscludeFn;&#13;
&#13;
      // if we have templateUrl, then we have to delay linking&#13;
      return linkingFn;&#13;
&#13;
      ////////////////////&#13;
&#13;
      function addLinkingFns(pre, post) {&#13;
        if (pre) {&#13;
          pre.require = directive.require;&#13;
          preLinkingFns.push(pre);&#13;
        }&#13;
        if (post) {&#13;
          post.require = directive.require;&#13;
          postLinkingFns.push(post);&#13;
        }&#13;
      }&#13;
&#13;
&#13;
      function getControllers(require, element) {&#13;
        var value, retrievalMethod = 'data', optional = false;&#13;
        if (isString(require)) {&#13;
          while((value = require.charAt(0)) == '^' || value == '?') {&#13;
            require = require.substr(1);&#13;
            if (value == '^') {&#13;
              retrievalMethod = 'inheritedData';&#13;
            }&#13;
            optional = optional || value == '?';&#13;
          }&#13;
          value = element[retrievalMethod]('$' + require + 'Controller');&#13;
          if (!value &amp;&amp; !optional) {&#13;
            throw Error("No controller: " + require);&#13;
          }&#13;
          return value;&#13;
        } else if (isArray(require)) {&#13;
          value = [];&#13;
          forEach(require, function(require) {&#13;
            value.push(getControllers(require, element));&#13;
          });&#13;
        }&#13;
        return value;&#13;
      }&#13;
&#13;
&#13;
      /* directiveLinkingFn */&#13;
      function compositeLinkFn(/* nodesetLinkingFn */ childLinkingFn,&#13;
                               scope, linkNode, rootElement, boundTranscludeFn) {&#13;
        var attrs, element, i, ii, linkingFn, controller;&#13;
&#13;
        if (templateNode === linkNode) {&#13;
          attrs = templateAttrs;&#13;
        } else {&#13;
          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));&#13;
        }&#13;
        element = attrs.$$element;&#13;
&#13;
        if (newScopeDirective &amp;&amp; isObject(newScopeDirective.scope)) {&#13;
          forEach(newScopeDirective.scope, function(mode, name) {&#13;
            (LOCAL_MODE[mode] || wrongMode)(name, mode,&#13;
                scope.$parent || scope, scope, attrs);&#13;
          });&#13;
        }&#13;
&#13;
        if (controllerDirectives) {&#13;
          forEach(controllerDirectives, function(directive) {&#13;
            var locals = {&#13;
              $scope: scope,&#13;
              $element: element,&#13;
              $attrs: attrs,&#13;
              $transclude: boundTranscludeFn&#13;
            };&#13;
&#13;
&#13;
            forEach(directive.inject || {}, function(mode, name) {&#13;
              (LOCAL_MODE[mode] || wrongMode)(name, mode,&#13;
                  newScopeDirective ? scope.$parent || scope : scope, locals, attrs);&#13;
            });&#13;
&#13;
            controller = directive.controller;&#13;
            if (controller == '@') {&#13;
              controller = attrs[directive.name];&#13;
            }&#13;
&#13;
            element.data(&#13;
                '$' + directive.name + 'Controller',&#13;
                $controller(controller, locals));&#13;
          });&#13;
        }&#13;
&#13;
        // PRELINKING&#13;
        for(i = 0, ii = preLinkingFns.length; i &lt; ii; i++) {&#13;
          try {&#13;
            linkingFn = preLinkingFns[i];&#13;
            linkingFn(scope, element, attrs,&#13;
                linkingFn.require &amp;&amp; getControllers(linkingFn.require, element));&#13;
          } catch (e) {&#13;
            $exceptionHandler(e, startingTag(element));&#13;
          }&#13;
        }&#13;
&#13;
        // RECURSION&#13;
        childLinkingFn &amp;&amp; childLinkingFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);&#13;
&#13;
        // POSTLINKING&#13;
        for(i = 0, ii = postLinkingFns.length; i &lt; ii; i++) {&#13;
          try {&#13;
            linkingFn = postLinkingFns[i];&#13;
            linkingFn(scope, element, attrs,&#13;
                linkingFn.require &amp;&amp; getControllers(linkingFn.require, element));&#13;
          } catch (e) {&#13;
            $exceptionHandler(e, startingTag(element));&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * looks up the directive and decorates it with exception handling and proper parameters. We&#13;
     * call this the boundDirective.&#13;
     *&#13;
     * @param {string} name name of the directive to look up.&#13;
     * @param {string} location The directive must be found in specific format.&#13;
     *   String containing any of theses characters:&#13;
     *&#13;
     *   * `E`: element name&#13;
     *   * `A': attribute&#13;
     *   * `C`: class&#13;
     *   * `M`: comment&#13;
     * @returns true if directive was added.&#13;
     */&#13;
    function addDirective(tDirectives, name, location, maxPriority) {&#13;
      var match = false;&#13;
      if (hasDirectives.hasOwnProperty(name)) {&#13;
        for(var directive, directives = $injector.get(name + Suffix),&#13;
            i=0, ii = directives.length; i&lt;ii; i++) {&#13;
          try {&#13;
            directive = directives[i];&#13;
            if ( (maxPriority === undefined || maxPriority &gt; directive.priority) &amp;&amp;&#13;
                 directive.restrict.indexOf(location) != -1) {&#13;
              tDirectives.push(directive);&#13;
              match = true;&#13;
            }&#13;
          } catch(e) { $exceptionHandler(e); }&#13;
        }&#13;
      }&#13;
      return match;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * When the element is replaced with HTML template then the new attributes&#13;
     * on the template need to be merged with the existing attributes in the DOM.&#13;
     * The desired effect is to have both of the attributes present.&#13;
     *&#13;
     * @param {object} dst destination attributes (original DOM)&#13;
     * @param {object} src source attributes (from the directive template)&#13;
     */&#13;
    function mergeTemplateAttributes(dst, src) {&#13;
      var srcAttr = src.$attr,&#13;
          dstAttr = dst.$attr,&#13;
          element = dst.$$element;&#13;
      // reapply the old attributes to the new element&#13;
      forEach(dst, function(value, key) {&#13;
        if (key.charAt(0) != '$') {&#13;
          if (src[key]) {&#13;
            value += (key === 'style' ? ';' : ' ') + src[key];&#13;
          }&#13;
          dst.$set(key, value, true, srcAttr[key]);&#13;
        }&#13;
      });&#13;
      // copy the new attributes on the old attrs object&#13;
      forEach(src, function(value, key) {&#13;
        if (key == 'class') {&#13;
          safeAddClass(element, value);&#13;
        } else if (key == 'style') {&#13;
          element.attr('style', element.attr('style') + ';' + value);&#13;
        } else if (key.charAt(0) != '$' &amp;&amp; !dst.hasOwnProperty(key)) {&#13;
          dst[key] = value;&#13;
          dstAttr[key] = srcAttr[key];&#13;
        }&#13;
      });&#13;
    }&#13;
&#13;
&#13;
    function compileTemplateUrl(directives, /* directiveLinkingFn */ beforeWidgetLinkFn,&#13;
                                tElement, tAttrs, rootElement, replace, transcludeFn) {&#13;
      var linkQueue = [],&#13;
          afterWidgetLinkFn,&#13;
          afterWidgetChildrenLinkFn,&#13;
          originalWidgetNode = tElement[0],&#13;
          asyncWidgetDirective = directives.shift(),&#13;
          // The fact that we have to copy and patch the directive seems wrong!&#13;
          syncWidgetDirective = extend({}, asyncWidgetDirective, {templateUrl:null, transclude:null}),&#13;
          html = tElement.html();&#13;
&#13;
      tElement.html('');&#13;
&#13;
      $http.get(asyncWidgetDirective.templateUrl, {cache: $templateCache}).&#13;
        success(function(content) {&#13;
          content = trim(content).replace(CONTENT_REGEXP, html);&#13;
          if (replace &amp;&amp; !content.match(HAS_ROOT_ELEMENT)) {&#13;
            throw Error('Template must have exactly one root element: ' + content);&#13;
          }&#13;
&#13;
          var templateNode, tempTemplateAttrs;&#13;
&#13;
          if (replace) {&#13;
            tempTemplateAttrs = {$attr: {}};&#13;
            templateNode = jqLite(content)[0];&#13;
            replaceWith(rootElement, tElement, templateNode);&#13;
            collectDirectives(tElement[0], directives, tempTemplateAttrs);&#13;
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);&#13;
          } else {&#13;
            templateNode = tElement[0];&#13;
            tElement.html(content);&#13;
          }&#13;
&#13;
          directives.unshift(syncWidgetDirective);&#13;
          afterWidgetLinkFn = /* directiveLinkingFn */ applyDirectivesToNode(directives, tElement, tAttrs, transcludeFn);&#13;
          afterWidgetChildrenLinkFn = /* nodesetLinkingFn */ compileNodes(tElement.contents(), transcludeFn);&#13;
&#13;
&#13;
          while(linkQueue.length) {&#13;
            var controller = linkQueue.pop(),&#13;
                linkRootElement = linkQueue.pop(),&#13;
                cLinkNode = linkQueue.pop(),&#13;
                scope = linkQueue.pop(),&#13;
                node = templateNode;&#13;
&#13;
            if (cLinkNode !== originalWidgetNode) {&#13;
              // it was cloned therefore we have to clone as well.&#13;
              node = JQLiteClone(templateNode);&#13;
              replaceWith(linkRootElement, jqLite(cLinkNode), node);&#13;
            }&#13;
            afterWidgetLinkFn(function() {&#13;
              beforeWidgetLinkFn(afterWidgetChildrenLinkFn, scope, node, rootElement, controller);&#13;
            }, scope, node, rootElement, controller);&#13;
          }&#13;
          linkQueue = null;&#13;
        }).&#13;
        error(function(response, code, headers, config) {&#13;
          throw Error('Failed to load template: ' + config.url);&#13;
        });&#13;
&#13;
      return /* directiveLinkingFn */ function(ignoreChildLinkingFn, scope, node, rootElement,&#13;
                                               controller) {&#13;
        if (linkQueue) {&#13;
          linkQueue.push(scope);&#13;
          linkQueue.push(node);&#13;
          linkQueue.push(rootElement);&#13;
          linkQueue.push(controller);&#13;
        } else {&#13;
          afterWidgetLinkFn(function() {&#13;
            beforeWidgetLinkFn(afterWidgetChildrenLinkFn, scope, node, rootElement, controller);&#13;
          }, scope, node, rootElement, controller);&#13;
        }&#13;
      };&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * Sorting function for bound directives.&#13;
     */&#13;
    function byPriority(a, b) {&#13;
      return b.priority - a.priority;&#13;
    }&#13;
&#13;
&#13;
    function assertNoDuplicate(what, previousDirective, directive, element) {&#13;
      if (previousDirective) {&#13;
        throw Error('Multiple directives [' + previousDirective.name + ', ' +&#13;
          directive.name + '] asking for ' + what + ' on: ' +  startingTag(element));&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    function addTextInterpolateDirective(directives, text) {&#13;
      var interpolateFn = $interpolate(text, true);&#13;
      if (interpolateFn) {&#13;
        directives.push({&#13;
          priority: 0,&#13;
          compile: valueFn(function(scope, node) {&#13;
            var parent = node.parent(),&#13;
                bindings = parent.data('$binding') || [];&#13;
            bindings.push(interpolateFn);&#13;
            safeAddClass(parent.data('$binding', bindings), 'ng-binding');&#13;
            scope.$watch(interpolateFn, function(value) {&#13;
              node[0].nodeValue = value;&#13;
            });&#13;
          })&#13;
        });&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    function addAttrInterpolateDirective(node, directives, value, name) {&#13;
      var interpolateFn = $interpolate(value, true);&#13;
&#13;
&#13;
      // no interpolation found -&gt; ignore&#13;
      if (!interpolateFn) return;&#13;
&#13;
      directives.push({&#13;
        priority: 100,&#13;
        compile: valueFn(function(scope, element, attr) {&#13;
          if (name === 'class') {&#13;
            // we need to interpolate classes again, in the case the element was replaced&#13;
            // and therefore the two class attrs got merged - we want to interpolate the result&#13;
            interpolateFn = $interpolate(attr[name], true);&#13;
          }&#13;
&#13;
          // we define observers array only for interpolated attrs&#13;
          // and ignore observers for non interpolated attrs to save some memory&#13;
          attr.$$observers[name] = [];&#13;
          attr[name] = undefined;&#13;
          scope.$watch(interpolateFn, function(value) {&#13;
            attr.$set(name, value);&#13;
          });&#13;
        })&#13;
      });&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * This is a special jqLite.replaceWith, which can replace items which&#13;
     * have no parents, provided that the containing jqLite collection is provided.&#13;
     *&#13;
     * @param {JqLite=} rootElement The root of the compile tree. Used so that we can replace nodes&#13;
     *    in the root of the tree.&#13;
     * @param {JqLite} element The jqLite element which we are going to replace. We keep the shell,&#13;
     *    but replace its DOM node reference.&#13;
     * @param {Node} newNode The new DOM node.&#13;
     */&#13;
    function replaceWith(rootElement, element, newNode) {&#13;
      var oldNode = element[0],&#13;
          parent = oldNode.parentNode,&#13;
          i, ii;&#13;
&#13;
      if (rootElement) {&#13;
        for(i = 0, ii = rootElement.length; i&lt;ii; i++) {&#13;
          if (rootElement[i] == oldNode) {&#13;
            rootElement[i] = newNode;&#13;
          }&#13;
        }&#13;
      }&#13;
      if (parent) {&#13;
        parent.replaceChild(newNode, oldNode);&#13;
      }&#13;
      element[0] = newNode;&#13;
    }&#13;
  }];&#13;
}&#13;
&#13;
var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;&#13;
/**&#13;
 * Converts all accepted directives format into proper directive name.&#13;
 * All of these will become 'myDirective':&#13;
 *   my:DiRective&#13;
 *   my-directive&#13;
 *   x-my-directive&#13;
 *   data-my:directive&#13;
 *&#13;
 * Also there is special case for Moz prefix starting with upper case letter.&#13;
 * @param name Name to normalize&#13;
 */&#13;
function directiveNormalize(name) {&#13;
  return camelCase(name.replace(PREFIX_REGEXP, ''));&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * Closure compiler type information&#13;
 */&#13;
&#13;
function nodesetLinkingFn(&#13;
  /* angular.Scope */ scope,&#13;
  /* NodeList */ nodeList,&#13;
  /* Element */ rootElement,&#13;
  /* function(Function) */ boundTranscludeFn&#13;
){}&#13;
&#13;
function directiveLinkingFn(&#13;
  /* nodesetLinkingFn */ nodesetLinkingFn,&#13;
  /* angular.Scope */ scope,&#13;
  /* Node */ node,&#13;
  /* Element */ rootElement,&#13;
  /* function(Function) */ boundTranscludeFn&#13;
){}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$controllerProvider&#13;
 * @description&#13;
 * The {@link angular.module.ng.$controller $controller service} is used by Angular to create new&#13;
 * controllers.&#13;
 *&#13;
 * This provider allows controller registration via the&#13;
 * {@link angular.module.ng.$controllerProvider#register register} method.&#13;
 */&#13;
function $ControllerProvider() {&#13;
  var controllers = {};&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc function&#13;
   * @name angular.module.ng.$controllerProvider#register&#13;
   * @methodOf angular.module.ng.$controllerProvider&#13;
   * @param {string} name Controller name&#13;
   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI&#13;
   *    annotations in the array notation).&#13;
   */&#13;
  this.register = function(name, constructor) {&#13;
    controllers[name] = constructor;&#13;
  };&#13;
&#13;
&#13;
  this.$get = ['$injector', '$window', function($injector, $window) {&#13;
&#13;
    /**&#13;
     * @ngdoc function&#13;
     * @name angular.module.ng.$controller&#13;
     * @requires $injector&#13;
     *&#13;
     * @param {Function|string} constructor If called with a function then it's considered to be the&#13;
     *    controller constructor function. Otherwise it's considered to be a string which is used&#13;
     *    to retrieve the controller constructor using the following steps:&#13;
     *&#13;
     *    * check if a controller with given name is registered via `$controllerProvider`&#13;
     *    * check if evaluating the string on the current scope returns a constructor&#13;
     *    * check `window[constructor]` on the global `window` object&#13;
     *&#13;
     * @param {Object} locals Injection locals for Controller.&#13;
     * @return {Object} Instance of given controller.&#13;
     *&#13;
     * @description&#13;
     * `$controller` service is responsible for instantiating controllers.&#13;
     *&#13;
     * It's just simple call to {@link angular.module.AUTO.$injector $injector}, but extracted into&#13;
     * a service, so that one can override this service with {@link https://gist.github.com/1649788&#13;
     * BC version}.&#13;
     */&#13;
    return function(constructor, locals) {&#13;
      if(isString(constructor)) {&#13;
        var name = constructor;&#13;
        constructor = controllers.hasOwnProperty(name)&#13;
            ? controllers[name]&#13;
            : getter(locals.$scope, name, true) || getter($window, name, true);&#13;
&#13;
        assertArgFn(constructor, name, true);&#13;
      }&#13;
&#13;
      return $injector.instantiate(constructor, locals);&#13;
    };&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$defer&#13;
 * @requires $browser&#13;
 *&#13;
 * @description&#13;
 * Delegates to {@link angular.module.ng.$browser#defer $browser.defer}, but wraps the `fn` function&#13;
 * into a try/catch block and delegates any exceptions to&#13;
 * {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.&#13;
 *&#13;
 * In tests you can use `$browser.defer.flush()` to flush the queue of deferred functions.&#13;
 *&#13;
 * @param {function()} fn A function, who's execution should be deferred.&#13;
 * @param {number=} [delay=0] of milliseconds to defer the function execution.&#13;
 * @returns {*} DeferId that can be used to cancel the task via `$defer.cancel()`.&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$defer#cancel&#13;
 * @methodOf angular.module.ng.$defer&#13;
 *&#13;
 * @description&#13;
 * Cancels a defered task identified with `deferId`.&#13;
 *&#13;
 * @param {*} deferId Token returned by the `$defer` function.&#13;
 * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfuly canceled.&#13;
 */&#13;
function $DeferProvider(){&#13;
  this.$get = ['$rootScope', '$browser', function($rootScope, $browser) {&#13;
    function defer(fn, delay) {&#13;
      return $browser.defer(function() {&#13;
        $rootScope.$apply(fn);&#13;
      }, delay);&#13;
    }&#13;
&#13;
    defer.cancel = function(deferId) {&#13;
      return $browser.defer.cancel(deferId);&#13;
    };&#13;
&#13;
    return defer;&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$document&#13;
 * @requires $window&#13;
 *&#13;
 * @description&#13;
 * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`&#13;
 * element.&#13;
 */&#13;
function $DocumentProvider(){&#13;
  this.$get = ['$window', function(window){&#13;
    return jqLite(window.document);&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$exceptionHandler&#13;
 * @requires $log&#13;
 *&#13;
 * @description&#13;
 * Any uncaught exception in angular expressions is delegated to this service.&#13;
 * The default implementation simply delegates to `$log.error` which logs it into&#13;
 * the browser console.&#13;
 *&#13;
 * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by&#13;
 * {@link angular.module.ngMock.$exceptionHandler mock $exceptionHandler}&#13;
 *&#13;
 * @param {Error} exception Exception associated with the error.&#13;
 * @param {string=} cause optional information about the context in which&#13;
 *       the error was thrown.&#13;
 */&#13;
function $ExceptionHandlerProvider() {&#13;
  this.$get = ['$log', function($log){&#13;
    return function(exception, cause) {&#13;
      $log.error.apply($log, arguments);&#13;
    };&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$interpolateProvider&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 *&#13;
 * Used for configuring the interpolation markup. Deafults to `{{` and `}}`.&#13;
 */&#13;
function $InterpolateProvider() {&#13;
  var startSymbol = '{{';&#13;
  var endSymbol = '}}';&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$interpolateProvider#startSymbol&#13;
   * @methodOf angular.module.ng.$interpolateProvider&#13;
   * @description&#13;
   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.&#13;
   *&#13;
   * @prop {string=} value new value to set the starting symbol to.&#13;
   */&#13;
  this.startSymbol = function(value){&#13;
    if (value) {&#13;
      startSymbol = value;&#13;
      return this;&#13;
    } else {&#13;
      return startSymbol;&#13;
    }&#13;
  };&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$interpolateProvider#endSymbol&#13;
   * @methodOf angular.module.ng.$interpolateProvider&#13;
   * @description&#13;
   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.&#13;
   *&#13;
   * @prop {string=} value new value to set the ending symbol to.&#13;
   */&#13;
  this.endSymbol = function(value){&#13;
    if (value) {&#13;
      endSymbol = value;&#13;
      return this;&#13;
    } else {&#13;
      return startSymbol;&#13;
    }&#13;
  };&#13;
&#13;
&#13;
  this.$get = ['$parse', function($parse) {&#13;
    var startSymbolLength = startSymbol.length,&#13;
        endSymbolLength = endSymbol.length;&#13;
&#13;
    /**&#13;
     * @ngdoc function&#13;
     * @name angular.module.ng.$interpolate&#13;
     * @function&#13;
     *&#13;
     * @requires $parse&#13;
     *&#13;
     * @description&#13;
     *&#13;
     * Compiles a string with markup into an interpolation function. This service is used by the&#13;
     * HTML {@link angular.module.ng.$compile $compile} service for data binding. See&#13;
     * {@link angular.module.ng.$interpolateProvider $interpolateProvider} for configuring the&#13;
     * interpolation markup.&#13;
     *&#13;
     *&#13;
       &lt;pre&gt;&#13;
         var $interpolate = ...; // injected&#13;
         var exp = $interpolate('Hello {{name}}!');&#13;
         expect(exp({name:'Angular'}).toEqual('Hello Angular!');&#13;
       &lt;/pre&gt;&#13;
     *&#13;
     *&#13;
     * @param {string} text The text with markup to interpolate.&#13;
     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have&#13;
     *    embedded expression in order to return an interpolation function. Strings with no&#13;
     *    embedded expression will return null for the interpolation function.&#13;
     * @returns {function(context)} an interpolation function which is used to compute the interpolated&#13;
     *    string. The function has these parameters:&#13;
     *&#13;
     *    * `context`: an object against which any expressions embedded in the strings are evaluated&#13;
     *      against.&#13;
     *&#13;
     */&#13;
    return function(text, mustHaveExpression) {&#13;
      var startIndex,&#13;
          endIndex,&#13;
          index = 0,&#13;
          parts = [],&#13;
          length = text.length,&#13;
          hasInterpolation = false,&#13;
          fn,&#13;
          exp,&#13;
          concat = [];&#13;
&#13;
      while(index &lt; length) {&#13;
        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &amp;&amp;&#13;
             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {&#13;
          (index != startIndex) &amp;&amp; parts.push(text.substring(index, startIndex));&#13;
          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));&#13;
          fn.exp = exp;&#13;
          index = endIndex + endSymbolLength;&#13;
          hasInterpolation = true;&#13;
        } else {&#13;
          // we did not find anything, so we have to add the remainder to the parts array&#13;
          (index != length) &amp;&amp; parts.push(text.substring(index));&#13;
          index = length;&#13;
        }&#13;
      }&#13;
&#13;
      if (!(length = parts.length)) {&#13;
        // we added, nothing, must have been an empty string.&#13;
        parts.push('');&#13;
        length = 1;&#13;
      }&#13;
&#13;
      if (!mustHaveExpression  || hasInterpolation) {&#13;
        concat.length = length;&#13;
        fn = function(context) {&#13;
          for(var i = 0, ii = length, part; i&lt;ii; i++) {&#13;
            if (typeof (part = parts[i]) == 'function') {&#13;
              part = part(context);&#13;
              if (part == null || part == undefined) {&#13;
                part = '';&#13;
              } else if (typeof part != 'string') {&#13;
                part = toJson(part);&#13;
              }&#13;
            }&#13;
            concat[i] = part;&#13;
          }&#13;
          return concat.join('');&#13;
        };&#13;
        fn.exp = text;&#13;
        fn.parts = parts;&#13;
        return fn;&#13;
      }&#13;
    };&#13;
  }];&#13;
}&#13;
&#13;
var URL_MATCH = /^(file|ftp|http|https):\/\/(\w+:{0,1}\w*@)?([\w\.-]*)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/,&#13;
    PATH_MATCH = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/,&#13;
    HASH_MATCH = PATH_MATCH,&#13;
    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};&#13;
&#13;
&#13;
/**&#13;
 * Encode path using encodeUriSegment, ignoring forward slashes&#13;
 *&#13;
 * @param {string} path Path to encode&#13;
 * @returns {string}&#13;
 */&#13;
function encodePath(path) {&#13;
  var segments = path.split('/'),&#13;
      i = segments.length;&#13;
&#13;
  while (i--) {&#13;
    segments[i] = encodeUriSegment(segments[i]);&#13;
  }&#13;
&#13;
  return segments.join('/');&#13;
}&#13;
&#13;
&#13;
function matchUrl(url, obj) {&#13;
  var match = URL_MATCH.exec(url);&#13;
&#13;
  match = {&#13;
      protocol: match[1],&#13;
      host: match[3],&#13;
      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,&#13;
      path: match[6] || '/',&#13;
      search: match[8],&#13;
      hash: match[10]&#13;
    };&#13;
&#13;
  if (obj) {&#13;
    obj.$$protocol = match.protocol;&#13;
    obj.$$host = match.host;&#13;
    obj.$$port = match.port;&#13;
  }&#13;
&#13;
  return match;&#13;
}&#13;
&#13;
&#13;
function composeProtocolHostPort(protocol, host, port) {&#13;
  return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);&#13;
}&#13;
&#13;
&#13;
function pathPrefixFromBase(basePath) {&#13;
  return basePath.substr(0, basePath.lastIndexOf('/'));&#13;
}&#13;
&#13;
&#13;
function convertToHtml5Url(url, basePath, hashPrefix) {&#13;
  var match = matchUrl(url);&#13;
&#13;
  // already html5 url&#13;
  if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) ||&#13;
      match.hash.indexOf(hashPrefix) !== 0) {&#13;
    return url;&#13;
  // convert hashbang url -&gt; html5 url&#13;
  } else {&#13;
    return composeProtocolHostPort(match.protocol, match.host, match.port) +&#13;
           pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);&#13;
  }&#13;
}&#13;
&#13;
&#13;
function convertToHashbangUrl(url, basePath, hashPrefix) {&#13;
  var match = matchUrl(url);&#13;
&#13;
  // already hashbang url&#13;
  if (decodeURIComponent(match.path) == basePath) {&#13;
    return url;&#13;
  // convert html5 url -&gt; hashbang url&#13;
  } else {&#13;
    var search = match.search &amp;&amp; '?' + match.search || '',&#13;
        hash = match.hash &amp;&amp; '#' + match.hash || '',&#13;
        pathPrefix = pathPrefixFromBase(basePath),&#13;
        path = match.path.substr(pathPrefix.length);&#13;
&#13;
    if (match.path.indexOf(pathPrefix) !== 0) {&#13;
      throw 'Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !';&#13;
    }&#13;
&#13;
    return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath +&#13;
           '#' + hashPrefix + path + search + hash;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * LocationUrl represents an url&#13;
 * This object is exposed as $location service when HTML5 mode is enabled and supported&#13;
 *&#13;
 * @constructor&#13;
 * @param {string} url HTML5 url&#13;
 * @param {string} pathPrefix&#13;
 */&#13;
function LocationUrl(url, pathPrefix) {&#13;
  pathPrefix = pathPrefix || '';&#13;
&#13;
  /**&#13;
   * Parse given html5 (regular) url string into properties&#13;
   * @param {string} url HTML5 url&#13;
   * @private&#13;
   */&#13;
  this.$$parse = function(url) {&#13;
    var match = matchUrl(url, this);&#13;
&#13;
    if (match.path.indexOf(pathPrefix) !== 0) {&#13;
      throw 'Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !';&#13;
    }&#13;
&#13;
    this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));&#13;
    this.$$search = parseKeyValue(match.search);&#13;
    this.$$hash = match.hash &amp;&amp; decodeURIComponent(match.hash) || '';&#13;
&#13;
    this.$$compose();&#13;
  };&#13;
&#13;
  /**&#13;
   * Compose url and update `absUrl` property&#13;
   * @private&#13;
   */&#13;
  this.$$compose = function() {&#13;
    var search = toKeyValue(this.$$search),&#13;
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';&#13;
&#13;
    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;&#13;
    this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) +&#13;
                    pathPrefix + this.$$url;&#13;
  };&#13;
&#13;
  this.$$parse(url);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * LocationHashbangUrl represents url&#13;
 * This object is exposed as $location service when html5 history api is disabled or not supported&#13;
 *&#13;
 * @constructor&#13;
 * @param {string} url Legacy url&#13;
 * @param {string} hashPrefix Prefix for hash part (containing path and search)&#13;
 */&#13;
function LocationHashbangUrl(url, hashPrefix) {&#13;
  var basePath;&#13;
&#13;
  /**&#13;
   * Parse given hashbang url into properties&#13;
   * @param {string} url Hashbang url&#13;
   * @private&#13;
   */&#13;
  this.$$parse = function(url) {&#13;
    var match = matchUrl(url, this);&#13;
&#13;
    if (match.hash &amp;&amp; match.hash.indexOf(hashPrefix) !== 0) {&#13;
      throw 'Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '" !';&#13;
    }&#13;
&#13;
    basePath = match.path + (match.search ? '?' + match.search : '');&#13;
    match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));&#13;
    if (match[1]) {&#13;
      this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);&#13;
    } else {&#13;
      this.$$path = '';&#13;
    }&#13;
&#13;
    this.$$search = parseKeyValue(match[3]);&#13;
    this.$$hash = match[5] &amp;&amp; decodeURIComponent(match[5]) || '';&#13;
&#13;
    this.$$compose();&#13;
  };&#13;
&#13;
  /**&#13;
   * Compose hashbang url and update `absUrl` property&#13;
   * @private&#13;
   */&#13;
  this.$$compose = function() {&#13;
    var search = toKeyValue(this.$$search),&#13;
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';&#13;
&#13;
    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;&#13;
    this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) +&#13;
                    basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');&#13;
  };&#13;
&#13;
  this.$$parse(url);&#13;
}&#13;
&#13;
&#13;
LocationUrl.prototype = {&#13;
&#13;
  /**&#13;
   * Has any change been replacing ?&#13;
   * @private&#13;
   */&#13;
  $$replace: false,&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#absUrl&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter only.&#13;
   *&#13;
   * Return full url representation with all segments encoded according to rules specified in&#13;
   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.&#13;
   *&#13;
   * @return {string}&#13;
   */&#13;
  absUrl: locationGetter('$$absUrl'),&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#url&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter / setter.&#13;
   *&#13;
   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.&#13;
   *&#13;
   * Change path, search and hash, when called with parameter and return `$location`.&#13;
   *&#13;
   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)&#13;
   * @return {string}&#13;
   */&#13;
  url: function(url, replace) {&#13;
    if (isUndefined(url))&#13;
      return this.$$url;&#13;
&#13;
    var match = PATH_MATCH.exec(url);&#13;
    if (match[1]) this.path(decodeURIComponent(match[1]));&#13;
    if (match[2] || match[1]) this.search(match[3] || '');&#13;
    this.hash(match[5] || '', replace);&#13;
&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#protocol&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter only.&#13;
   *&#13;
   * Return protocol of current url.&#13;
   *&#13;
   * @return {string}&#13;
   */&#13;
  protocol: locationGetter('$$protocol'),&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#host&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter only.&#13;
   *&#13;
   * Return host of current url.&#13;
   *&#13;
   * @return {string}&#13;
   */&#13;
  host: locationGetter('$$host'),&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#port&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter only.&#13;
   *&#13;
   * Return port of current url.&#13;
   *&#13;
   * @return {Number}&#13;
   */&#13;
  port: locationGetter('$$port'),&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#path&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter / setter.&#13;
   *&#13;
   * Return path of current url when called without any parameter.&#13;
   *&#13;
   * Change path when called with parameter and return `$location`.&#13;
   *&#13;
   * Note: Path should always begin with forward slash (/), this method will add the forward slash&#13;
   * if it is missing.&#13;
   *&#13;
   * @param {string=} path New path&#13;
   * @return {string}&#13;
   */&#13;
  path: locationGetterSetter('$$path', function(path) {&#13;
    return path.charAt(0) == '/' ? path : '/' + path;&#13;
  }),&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#search&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter / setter.&#13;
   *&#13;
   * Return search part (as object) of current url when called without any parameter.&#13;
   *&#13;
   * Change search part when called with parameter and return `$location`.&#13;
   *&#13;
   * @param {string|object&lt;string,string&gt;=} search New search params - string or hash object&#13;
   * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a&#13;
   *    single search parameter. If the value is `null`, the parameter will be deleted.&#13;
   *&#13;
   * @return {string}&#13;
   */&#13;
  search: function(search, paramValue) {&#13;
    if (isUndefined(search))&#13;
      return this.$$search;&#13;
&#13;
    if (isDefined(paramValue)) {&#13;
      if (paramValue === null) {&#13;
        delete this.$$search[search];&#13;
      } else {&#13;
        this.$$search[search] = paramValue;&#13;
      }&#13;
    } else {&#13;
      this.$$search = isString(search) ? parseKeyValue(search) : search;&#13;
    }&#13;
&#13;
    this.$$compose();&#13;
    return this;&#13;
  },&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#hash&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * This method is getter / setter.&#13;
   *&#13;
   * Return hash fragment when called without any parameter.&#13;
   *&#13;
   * Change hash fragment when called with parameter and return `$location`.&#13;
   *&#13;
   * @param {string=} hash New hash fragment&#13;
   * @return {string}&#13;
   */&#13;
  hash: locationGetterSetter('$$hash', identity),&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$location#replace&#13;
   * @methodOf angular.module.ng.$location&#13;
   *&#13;
   * @description&#13;
   * If called, all changes to $location during current `$digest` will be replacing current history&#13;
   * record, instead of adding new one.&#13;
   */&#13;
  replace: function() {&#13;
    this.$$replace = true;&#13;
    return this;&#13;
  }&#13;
};&#13;
&#13;
LocationHashbangUrl.prototype = inherit(LocationUrl.prototype);&#13;
&#13;
function locationGetter(property) {&#13;
  return function() {&#13;
    return this[property];&#13;
  };&#13;
}&#13;
&#13;
&#13;
function locationGetterSetter(property, preprocess) {&#13;
  return function(value) {&#13;
    if (isUndefined(value))&#13;
      return this[property];&#13;
&#13;
    this[property] = preprocess(value);&#13;
    this.$$compose();&#13;
&#13;
    return this;&#13;
  };&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$location&#13;
 *&#13;
 * @requires $browser&#13;
 * @requires $sniffer&#13;
 * @requires $document&#13;
 *&#13;
 * @description&#13;
 * The $location service parses the URL in the browser address bar (based on the {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL available to your application. Changes to the URL in the address bar are reflected into $location service and changes to $location are reflected into the browser address bar.&#13;
 *&#13;
 * **The $location service:**&#13;
 *&#13;
 * - Exposes the current URL in the browser address bar, so you can&#13;
 *   - Watch and observe the URL.&#13;
 *   - Change the URL.&#13;
 * - Synchronizes the URL with the browser when the user&#13;
 *   - Changes the address bar.&#13;
 *   - Clicks the back or forward button (or clicks a History link).&#13;
 *   - Clicks on a link.&#13;
 * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).&#13;
 *&#13;
 * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular Services: Using $location}&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$locationProvider&#13;
 * @description&#13;
 * Use the `$locationProvider` to configure how the application deep linking paths are stored.&#13;
 */&#13;
function $LocationProvider(){&#13;
  var hashPrefix = '',&#13;
      html5Mode = false;&#13;
&#13;
  /**&#13;
   * @ngdoc property&#13;
   * @name angular.module.ng.$locationProvider#hashPrefix&#13;
   * @methodOf angular.module.ng.$locationProvider&#13;
   * @description&#13;
   * @param {string=} prefix Prefix for hash part (containing path and search)&#13;
   * @returns {*} current value if used as getter or itself (chaining) if used as setter&#13;
   */&#13;
  this.hashPrefix = function(prefix) {&#13;
    if (isDefined(prefix)) {&#13;
      hashPrefix = prefix;&#13;
      return this;&#13;
    } else {&#13;
      return hashPrefix;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @ngdoc property&#13;
   * @name angular.module.ng.$locationProvider#html5Mode&#13;
   * @methodOf angular.module.ng.$locationProvider&#13;
   * @description&#13;
   * @param {string=} mode Use HTML5 strategy if available.&#13;
   * @returns {*} current value if used as getter or itself (chaining) if used as setter&#13;
   */&#13;
  this.html5Mode = function(mode) {&#13;
    if (isDefined(mode)) {&#13;
      html5Mode = mode;&#13;
      return this;&#13;
    } else {&#13;
      return html5Mode;&#13;
    }&#13;
  };&#13;
&#13;
  this.$get = ['$rootScope', '$browser', '$sniffer', '$document',&#13;
      function( $rootScope,   $browser,   $sniffer,   $document) {&#13;
    var currentUrl,&#13;
        basePath = $browser.baseHref() || '/',&#13;
        pathPrefix = pathPrefixFromBase(basePath),&#13;
        initUrl = $browser.url();&#13;
&#13;
    if (html5Mode) {&#13;
      if ($sniffer.history) {&#13;
        currentUrl = new LocationUrl(convertToHtml5Url(initUrl, basePath, hashPrefix), pathPrefix);&#13;
      } else {&#13;
        currentUrl = new LocationHashbangUrl(convertToHashbangUrl(initUrl, basePath, hashPrefix),&#13;
                                             hashPrefix);&#13;
      }&#13;
&#13;
      // link rewriting&#13;
      var u = currentUrl,&#13;
          absUrlPrefix = composeProtocolHostPort(u.protocol(), u.host(), u.port()) + pathPrefix;&#13;
&#13;
      $document.bind('click', function(event) {&#13;
        // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)&#13;
        // currently we open nice url link and redirect then&#13;
&#13;
        if (event.ctrlKey || event.metaKey || event.which == 2) return;&#13;
&#13;
        var elm = jqLite(event.target);&#13;
&#13;
        // traverse the DOM up to find first A tag&#13;
        while (elm.length &amp;&amp; lowercase(elm[0].nodeName) !== 'a') {&#13;
          elm = elm.parent();&#13;
        }&#13;
&#13;
        var href = elm.attr('href');&#13;
        if (!href || isDefined(elm.attr('ng-ext-link')) || elm.attr('target')) return;&#13;
&#13;
        // remove same domain from full url links (IE7 always returns full hrefs)&#13;
        href = href.replace(absUrlPrefix, '');&#13;
&#13;
        // link to different domain (or base path)&#13;
        if (href.substr(0, 4) == 'http') return;&#13;
&#13;
        // remove pathPrefix from absolute links&#13;
        href = href.indexOf(pathPrefix) === 0 ? href.substr(pathPrefix.length) : href;&#13;
&#13;
        currentUrl.url(href);&#13;
        $rootScope.$apply();&#13;
        event.preventDefault();&#13;
        // hack to work around FF6 bug 684208 when scenario runner clicks on links&#13;
        window.angular['ff-684208-preventDefault'] = true;&#13;
      });&#13;
    } else {&#13;
      currentUrl = new LocationHashbangUrl(initUrl, hashPrefix);&#13;
    }&#13;
&#13;
    // rewrite hashbang url &lt;&gt; html5 url&#13;
    if (currentUrl.absUrl() != initUrl) {&#13;
      $browser.url(currentUrl.absUrl(), true);&#13;
    }&#13;
&#13;
    // update $location when $browser url changes&#13;
    $browser.onUrlChange(function(newUrl) {&#13;
      if (currentUrl.absUrl() != newUrl) {&#13;
        $rootScope.$evalAsync(function() {&#13;
          currentUrl.$$parse(newUrl);&#13;
        });&#13;
        if (!$rootScope.$$phase) $rootScope.$digest();&#13;
      }&#13;
    });&#13;
&#13;
    // update browser&#13;
    var changeCounter = 0;&#13;
    $rootScope.$watch(function $locationWatch() {&#13;
      if ($browser.url() != currentUrl.absUrl()) {&#13;
        changeCounter++;&#13;
        $rootScope.$evalAsync(function() {&#13;
          $browser.url(currentUrl.absUrl(), currentUrl.$$replace);&#13;
          currentUrl.$$replace = false;&#13;
        });&#13;
      }&#13;
&#13;
      return changeCounter;&#13;
    });&#13;
&#13;
    return currentUrl;&#13;
}];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$log&#13;
 * @requires $window&#13;
 *&#13;
 * @description&#13;
 * Simple service for logging. Default implementation writes the message&#13;
 * into the browser's console (if present).&#13;
 *&#13;
 * The main purpose of this service is to simplify debugging and troubleshooting.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
         &lt;script&gt;&#13;
           function LogCtrl($log) {&#13;
             this.$log = $log;&#13;
             this.message = 'Hello World!';&#13;
           }&#13;
         &lt;/script&gt;&#13;
         &lt;div ng-controller="LogCtrl"&gt;&#13;
           &lt;p&gt;Reload this page with open console, enter text and hit the log button...&lt;/p&gt;&#13;
           Message:&#13;
           &lt;input type="text" ng-model="message"/&gt;&#13;
           &lt;button ng-click="$log.log(message)"&gt;log&lt;/button&gt;&#13;
           &lt;button ng-click="$log.warn(message)"&gt;warn&lt;/button&gt;&#13;
           &lt;button ng-click="$log.info(message)"&gt;info&lt;/button&gt;&#13;
           &lt;button ng-click="$log.error(message)"&gt;error&lt;/button&gt;&#13;
         &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
&#13;
function $LogProvider(){&#13;
  this.$get = ['$window', function($window){&#13;
    return {&#13;
      /**&#13;
       * @ngdoc method&#13;
       * @name angular.module.ng.$log#log&#13;
       * @methodOf angular.module.ng.$log&#13;
       *&#13;
       * @description&#13;
       * Write a log message&#13;
       */&#13;
      log: consoleLog('log'),&#13;
&#13;
      /**&#13;
       * @ngdoc method&#13;
       * @name angular.module.ng.$log#warn&#13;
       * @methodOf angular.module.ng.$log&#13;
       *&#13;
       * @description&#13;
       * Write a warning message&#13;
       */&#13;
      warn: consoleLog('warn'),&#13;
&#13;
      /**&#13;
       * @ngdoc method&#13;
       * @name angular.module.ng.$log#info&#13;
       * @methodOf angular.module.ng.$log&#13;
       *&#13;
       * @description&#13;
       * Write an information message&#13;
       */&#13;
      info: consoleLog('info'),&#13;
&#13;
      /**&#13;
       * @ngdoc method&#13;
       * @name angular.module.ng.$log#error&#13;
       * @methodOf angular.module.ng.$log&#13;
       *&#13;
       * @description&#13;
       * Write an error message&#13;
       */&#13;
      error: consoleLog('error')&#13;
    };&#13;
&#13;
    function formatError(arg) {&#13;
      if (arg instanceof Error) {&#13;
        if (arg.stack) {&#13;
          arg = (arg.message &amp;&amp; arg.stack.indexOf(arg.message) === -1)&#13;
              ? 'Error: ' + arg.message + '\n' + arg.stack&#13;
              : arg.stack;&#13;
        } else if (arg.sourceURL) {&#13;
          arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;&#13;
        }&#13;
      }&#13;
      return arg;&#13;
    }&#13;
&#13;
    function consoleLog(type) {&#13;
      var console = $window.console || {},&#13;
          logFn = console[type] || console.log || noop;&#13;
&#13;
      if (logFn.apply) {&#13;
        return function() {&#13;
          var args = [];&#13;
          forEach(arguments, function(arg) {&#13;
            args.push(formatError(arg));&#13;
          });&#13;
          return logFn.apply(console, args);&#13;
        };&#13;
      }&#13;
&#13;
      // we are IE which either doesn't have window.console =&gt; this is noop and we do nothing,&#13;
      // or we are IE where console.log doesn't have apply so we log at least first 2 args&#13;
      return function(arg1, arg2) {&#13;
        logFn(arg1, arg2);&#13;
      }&#13;
    }&#13;
  }];&#13;
}&#13;
&#13;
var OPERATORS = {&#13;
    'null':function(){return null;},&#13;
    'true':function(){return true;},&#13;
    'false':function(){return false;},&#13;
    undefined:noop,&#13;
    '+':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)+(isDefined(b)?b:0);},&#13;
    '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},&#13;
    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},&#13;
    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},&#13;
    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},&#13;
    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},&#13;
    '=':noop,&#13;
    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},&#13;
    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},&#13;
    '&lt;':function(self, locals, a,b){return a(self, locals)&lt;b(self, locals);},&#13;
    '&gt;':function(self, locals, a,b){return a(self, locals)&gt;b(self, locals);},&#13;
    '&lt;=':function(self, locals, a,b){return a(self, locals)&lt;=b(self, locals);},&#13;
    '&gt;=':function(self, locals, a,b){return a(self, locals)&gt;=b(self, locals);},&#13;
    '&amp;&amp;':function(self, locals, a,b){return a(self, locals)&amp;&amp;b(self, locals);},&#13;
    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},&#13;
    '&amp;':function(self, locals, a,b){return a(self, locals)&amp;b(self, locals);},&#13;
//    '|':function(self, locals, a,b){return a|b;},&#13;
    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},&#13;
    '!':function(self, locals, a){return !a(self, locals);}&#13;
};&#13;
var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};&#13;
&#13;
function lex(text){&#13;
  var tokens = [],&#13;
      token,&#13;
      index = 0,&#13;
      json = [],&#13;
      ch,&#13;
      lastCh = ':'; // can start regexp&#13;
&#13;
  while (index &lt; text.length) {&#13;
    ch = text.charAt(index);&#13;
    if (is('"\'')) {&#13;
      readString(ch);&#13;
    } else if (isNumber(ch) || is('.') &amp;&amp; isNumber(peek())) {&#13;
      readNumber();&#13;
    } else if (isIdent(ch)) {&#13;
      readIdent();&#13;
      // identifiers can only be if the preceding char was a { or ,&#13;
      if (was('{,') &amp;&amp; json[0]=='{' &amp;&amp;&#13;
         (token=tokens[tokens.length-1])) {&#13;
        token.json = token.text.indexOf('.') == -1;&#13;
      }&#13;
    } else if (is('(){}[].,;:')) {&#13;
      tokens.push({&#13;
        index:index,&#13;
        text:ch,&#13;
        json:(was(':[,') &amp;&amp; is('{[')) || is('}]:,')&#13;
      });&#13;
      if (is('{[')) json.unshift(ch);&#13;
      if (is('}]')) json.shift();&#13;
      index++;&#13;
    } else if (isWhitespace(ch)) {&#13;
      index++;&#13;
      continue;&#13;
    } else {&#13;
      var ch2 = ch + peek(),&#13;
          fn = OPERATORS[ch],&#13;
          fn2 = OPERATORS[ch2];&#13;
      if (fn2) {&#13;
        tokens.push({index:index, text:ch2, fn:fn2});&#13;
        index += 2;&#13;
      } else if (fn) {&#13;
        tokens.push({index:index, text:ch, fn:fn, json: was('[,:') &amp;&amp; is('+-')});&#13;
        index += 1;&#13;
      } else {&#13;
        throwError("Unexpected next character ", index, index+1);&#13;
      }&#13;
    }&#13;
    lastCh = ch;&#13;
  }&#13;
  return tokens;&#13;
&#13;
  function is(chars) {&#13;
    return chars.indexOf(ch) != -1;&#13;
  }&#13;
&#13;
  function was(chars) {&#13;
    return chars.indexOf(lastCh) != -1;&#13;
  }&#13;
&#13;
  function peek() {&#13;
    return index + 1 &lt; text.length ? text.charAt(index + 1) : false;&#13;
  }&#13;
  function isNumber(ch) {&#13;
    return '0' &lt;= ch &amp;&amp; ch &lt;= '9';&#13;
  }&#13;
  function isWhitespace(ch) {&#13;
    return ch == ' ' || ch == '\r' || ch == '\t' ||&#13;
           ch == '\n' || ch == '\v' || ch == '\u00A0'; // IE treats non-breaking space as \u00A0&#13;
  }&#13;
  function isIdent(ch) {&#13;
    return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' ||&#13;
           'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' ||&#13;
           '_' == ch || ch == '$';&#13;
  }&#13;
  function isExpOperator(ch) {&#13;
    return ch == '-' || ch == '+' || isNumber(ch);&#13;
  }&#13;
&#13;
  function throwError(error, start, end) {&#13;
    end = end || index;&#13;
    throw Error("Lexer Error: " + error + " at column" +&#13;
        (isDefined(start)&#13;
            ? "s " + start +  "-" + index + " [" + text.substring(start, end) + "]"&#13;
            : " " + end) +&#13;
        " in expression [" + text + "].");&#13;
  }&#13;
&#13;
  function readNumber() {&#13;
    var number = "";&#13;
    var start = index;&#13;
    while (index &lt; text.length) {&#13;
      var ch = lowercase(text.charAt(index));&#13;
      if (ch == '.' || isNumber(ch)) {&#13;
        number += ch;&#13;
      } else {&#13;
        var peekCh = peek();&#13;
        if (ch == 'e' &amp;&amp; isExpOperator(peekCh)) {&#13;
          number += ch;&#13;
        } else if (isExpOperator(ch) &amp;&amp;&#13;
            peekCh &amp;&amp; isNumber(peekCh) &amp;&amp;&#13;
            number.charAt(number.length - 1) == 'e') {&#13;
          number += ch;&#13;
        } else if (isExpOperator(ch) &amp;&amp;&#13;
            (!peekCh || !isNumber(peekCh)) &amp;&amp;&#13;
            number.charAt(number.length - 1) == 'e') {&#13;
          throwError('Invalid exponent');&#13;
        } else {&#13;
          break;&#13;
        }&#13;
      }&#13;
      index++;&#13;
    }&#13;
    number = 1 * number;&#13;
    tokens.push({index:start, text:number, json:true,&#13;
      fn:function() {return number;}});&#13;
  }&#13;
  function readIdent() {&#13;
    var ident = "",&#13;
        start = index,&#13;
        lastDot, peekIndex, methodName;&#13;
&#13;
    while (index &lt; text.length) {&#13;
      var ch = text.charAt(index);&#13;
      if (ch == '.' || isIdent(ch) || isNumber(ch)) {&#13;
        if (ch == '.') lastDot = index;&#13;
        ident += ch;&#13;
      } else {&#13;
        break;&#13;
      }&#13;
      index++;&#13;
    }&#13;
&#13;
    //check if this is not a method invocation and if it is back out to last dot&#13;
    if (lastDot) {&#13;
      peekIndex = index&#13;
      while(peekIndex &lt; text.length) {&#13;
        var ch = text.charAt(peekIndex);&#13;
        if (ch == '(') {&#13;
          methodName = ident.substr(lastDot - start + 1);&#13;
          ident = ident.substr(0, lastDot - start);&#13;
          index = peekIndex;&#13;
          break;&#13;
        }&#13;
        if(isWhitespace(ch)) {&#13;
          peekIndex++;&#13;
        } else {&#13;
          break;&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    var token = {&#13;
      index:start,&#13;
      text:ident&#13;
    };&#13;
&#13;
    if (OPERATORS.hasOwnProperty(ident)) {&#13;
      token.fn = token.json = OPERATORS[ident];&#13;
    } else {&#13;
      var getter = getterFn(ident);&#13;
      token.fn = extend(function(self, locals) {&#13;
        return (getter(self, locals));&#13;
      }, {&#13;
        assign: function(self, value) {&#13;
          return setter(self, ident, value);&#13;
        }&#13;
      });&#13;
    }&#13;
&#13;
    tokens.push(token);&#13;
&#13;
    if (methodName) {&#13;
      tokens.push({&#13;
        index:lastDot,&#13;
        text: '.',&#13;
        json: false&#13;
      });&#13;
      tokens.push({&#13;
        index: lastDot + 1,&#13;
        text: methodName,&#13;
        json: false&#13;
      });&#13;
    }&#13;
  }&#13;
&#13;
  function readString(quote) {&#13;
    var start = index;&#13;
    index++;&#13;
    var string = "";&#13;
    var rawString = quote;&#13;
    var escape = false;&#13;
    while (index &lt; text.length) {&#13;
      var ch = text.charAt(index);&#13;
      rawString += ch;&#13;
      if (escape) {&#13;
        if (ch == 'u') {&#13;
          var hex = text.substring(index + 1, index + 5);&#13;
          if (!hex.match(/[\da-f]{4}/i))&#13;
            throwError( "Invalid unicode escape [\\u" + hex + "]");&#13;
          index += 4;&#13;
          string += String.fromCharCode(parseInt(hex, 16));&#13;
        } else {&#13;
          var rep = ESCAPE[ch];&#13;
          if (rep) {&#13;
            string += rep;&#13;
          } else {&#13;
            string += ch;&#13;
          }&#13;
        }&#13;
        escape = false;&#13;
      } else if (ch == '\\') {&#13;
        escape = true;&#13;
      } else if (ch == quote) {&#13;
        index++;&#13;
        tokens.push({&#13;
          index:start,&#13;
          text:rawString,&#13;
          string:string,&#13;
          json:true,&#13;
          fn:function() { return string; }&#13;
        });&#13;
        return;&#13;
      } else {&#13;
        string += ch;&#13;
      }&#13;
      index++;&#13;
    }&#13;
    throwError("Unterminated quote", start);&#13;
  }&#13;
}&#13;
&#13;
/////////////////////////////////////////&#13;
&#13;
function parser(text, json, $filter){&#13;
  var ZERO = valueFn(0),&#13;
      value,&#13;
      tokens = lex(text),&#13;
      assignment = _assignment,&#13;
      functionCall = _functionCall,&#13;
      fieldAccess = _fieldAccess,&#13;
      objectIndex = _objectIndex,&#13;
      filterChain = _filterChain&#13;
  if(json){&#13;
    // The extra level of aliasing is here, just in case the lexer misses something, so that&#13;
    // we prevent any accidental execution in JSON.&#13;
    assignment = logicalOR;&#13;
    functionCall =&#13;
      fieldAccess =&#13;
      objectIndex =&#13;
      filterChain =&#13;
        function() { throwError("is not valid json", {text:text, index:0}); };&#13;
    value = primary();&#13;
  } else {&#13;
    value = statements();&#13;
  }&#13;
  if (tokens.length !== 0) {&#13;
    throwError("is an unexpected token", tokens[0]);&#13;
  }&#13;
  return value;&#13;
&#13;
  ///////////////////////////////////&#13;
  function throwError(msg, token) {&#13;
    throw Error("Syntax Error: Token '" + token.text +&#13;
      "' " + msg + " at column " +&#13;
      (token.index + 1) + " of the expression [" +&#13;
      text + "] starting at [" + text.substring(token.index) + "].");&#13;
  }&#13;
&#13;
  function peekToken() {&#13;
    if (tokens.length === 0)&#13;
      throw Error("Unexpected end of expression: " + text);&#13;
    return tokens[0];&#13;
  }&#13;
&#13;
  function peek(e1, e2, e3, e4) {&#13;
    if (tokens.length &gt; 0) {&#13;
      var token = tokens[0];&#13;
      var t = token.text;&#13;
      if (t==e1 || t==e2 || t==e3 || t==e4 ||&#13;
          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) {&#13;
        return token;&#13;
      }&#13;
    }&#13;
    return false;&#13;
  }&#13;
&#13;
  function expect(e1, e2, e3, e4){&#13;
    var token = peek(e1, e2, e3, e4);&#13;
    if (token) {&#13;
      if (json &amp;&amp; !token.json) {&#13;
        throwError("is not valid json", token);&#13;
      }&#13;
      tokens.shift();&#13;
      return token;&#13;
    }&#13;
    return false;&#13;
  }&#13;
&#13;
  function consume(e1){&#13;
    if (!expect(e1)) {&#13;
      throwError("is unexpected, expecting [" + e1 + "]", peek());&#13;
    }&#13;
  }&#13;
&#13;
  function unaryFn(fn, right) {&#13;
    return function(self, locals) {&#13;
      return fn(self, locals, right);&#13;
    };&#13;
  }&#13;
&#13;
  function binaryFn(left, fn, right) {&#13;
    return function(self, locals) {&#13;
      return fn(self, locals, left, right);&#13;
    };&#13;
  }&#13;
&#13;
  function hasTokens () {&#13;
    return tokens.length &gt; 0;&#13;
  }&#13;
&#13;
  function statements() {&#13;
    var statements = [];&#13;
    while(true) {&#13;
      if (tokens.length &gt; 0 &amp;&amp; !peek('}', ')', ';', ']'))&#13;
        statements.push(filterChain());&#13;
      if (!expect(';')) {&#13;
        // optimize for the common case where there is only one statement.&#13;
        // TODO(size): maybe we should not support multiple statements?&#13;
        return statements.length == 1&#13;
          ? statements[0]&#13;
          : function(self, locals){&#13;
            var value;&#13;
            for ( var i = 0; i &lt; statements.length; i++) {&#13;
              var statement = statements[i];&#13;
              if (statement)&#13;
                value = statement(self, locals);&#13;
            }&#13;
            return value;&#13;
          };&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function _filterChain() {&#13;
    var left = expression();&#13;
    var token;&#13;
    while(true) {&#13;
      if ((token = expect('|'))) {&#13;
        left = binaryFn(left, token.fn, filter());&#13;
      } else {&#13;
        return left;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function filter() {&#13;
    var token = expect();&#13;
    var fn = $filter(token.text);&#13;
    var argsFn = [];&#13;
    while(true) {&#13;
      if ((token = expect(':'))) {&#13;
        argsFn.push(expression());&#13;
      } else {&#13;
        var fnInvoke = function(self, locals, input){&#13;
          var args = [input];&#13;
          for ( var i = 0; i &lt; argsFn.length; i++) {&#13;
            args.push(argsFn[i](self, locals));&#13;
          }&#13;
          return fn.apply(self, args);&#13;
        };&#13;
        return function() {&#13;
          return fnInvoke;&#13;
        };&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function expression() {&#13;
    return assignment();&#13;
  }&#13;
&#13;
  function _assignment() {&#13;
    var left = logicalOR();&#13;
    var right;&#13;
    var token;&#13;
    if ((token = expect('='))) {&#13;
      if (!left.assign) {&#13;
        throwError("implies assignment but [" +&#13;
          text.substring(0, token.index) + "] can not be assigned to", token);&#13;
      }&#13;
      right = logicalOR();&#13;
      return function(self, locals){&#13;
        return left.assign(self, right(self, locals), locals);&#13;
      };&#13;
    } else {&#13;
      return left;&#13;
    }&#13;
  }&#13;
&#13;
  function logicalOR() {&#13;
    var left = logicalAND();&#13;
    var token;&#13;
    while(true) {&#13;
      if ((token = expect('||'))) {&#13;
        left = binaryFn(left, token.fn, logicalAND());&#13;
      } else {&#13;
        return left;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function logicalAND() {&#13;
    var left = equality();&#13;
    var token;&#13;
    if ((token = expect('&amp;&amp;'))) {&#13;
      left = binaryFn(left, token.fn, logicalAND());&#13;
    }&#13;
    return left;&#13;
  }&#13;
&#13;
  function equality() {&#13;
    var left = relational();&#13;
    var token;&#13;
    if ((token = expect('==','!='))) {&#13;
      left = binaryFn(left, token.fn, equality());&#13;
    }&#13;
    return left;&#13;
  }&#13;
&#13;
  function relational() {&#13;
    var left = additive();&#13;
    var token;&#13;
    if ((token = expect('&lt;', '&gt;', '&lt;=', '&gt;='))) {&#13;
      left = binaryFn(left, token.fn, relational());&#13;
    }&#13;
    return left;&#13;
  }&#13;
&#13;
  function additive() {&#13;
    var left = multiplicative();&#13;
    var token;&#13;
    while ((token = expect('+','-'))) {&#13;
      left = binaryFn(left, token.fn, multiplicative());&#13;
    }&#13;
    return left;&#13;
  }&#13;
&#13;
  function multiplicative() {&#13;
    var left = unary();&#13;
    var token;&#13;
    while ((token = expect('*','/','%'))) {&#13;
      left = binaryFn(left, token.fn, unary());&#13;
    }&#13;
    return left;&#13;
  }&#13;
&#13;
  function unary() {&#13;
    var token;&#13;
    if (expect('+')) {&#13;
      return primary();&#13;
    } else if ((token = expect('-'))) {&#13;
      return binaryFn(ZERO, token.fn, unary());&#13;
    } else if ((token = expect('!'))) {&#13;
      return unaryFn(token.fn, unary());&#13;
    } else {&#13;
      return primary();&#13;
    }&#13;
  }&#13;
&#13;
  function _functionIdent(fnScope) {&#13;
    var token = expect();&#13;
    var element = token.text.split('.');&#13;
    var instance = fnScope;&#13;
    var key;&#13;
    for ( var i = 0; i &lt; element.length; i++) {&#13;
      key = element[i];&#13;
      if (instance)&#13;
        instance = instance[key];&#13;
    }&#13;
    if (!isFunction(instance)) {&#13;
      throwError("should be a function", token);&#13;
    }&#13;
    return instance;&#13;
  }&#13;
&#13;
  function primary() {&#13;
    var primary;&#13;
    if (expect('(')) {&#13;
      primary = filterChain();&#13;
      consume(')');&#13;
    } else if (expect('[')) {&#13;
      primary = arrayDeclaration();&#13;
    } else if (expect('{')) {&#13;
      primary = object();&#13;
    } else {&#13;
      var token = expect();&#13;
      primary = token.fn;&#13;
      if (!primary) {&#13;
        throwError("not a primary expression", token);&#13;
      }&#13;
    }&#13;
&#13;
    var next, context;&#13;
    while ((next = expect('(', '[', '.'))) {&#13;
      if (next.text === '(') {&#13;
        primary = functionCall(primary, context);&#13;
        context = null;&#13;
      } else if (next.text === '[') {&#13;
        context = primary;&#13;
        primary = objectIndex(primary);&#13;
      } else if (next.text === '.') {&#13;
        context = primary;&#13;
        primary = fieldAccess(primary);&#13;
      } else {&#13;
        throwError("IMPOSSIBLE");&#13;
      }&#13;
    }&#13;
    return primary;&#13;
  }&#13;
&#13;
  function _fieldAccess(object) {&#13;
    var field = expect().text;&#13;
    var getter = getterFn(field);&#13;
    return extend(&#13;
        function(self, locals) {&#13;
          return getter(object(self, locals), locals);&#13;
        },&#13;
        {&#13;
          assign:function(self, value, locals) {&#13;
            return setter(object(self, locals), field, value);&#13;
          }&#13;
        }&#13;
    );&#13;
  }&#13;
&#13;
  function _objectIndex(obj) {&#13;
    var indexFn = expression();&#13;
    consume(']');&#13;
    return extend(&#13;
      function(self, locals){&#13;
        var o = obj(self, locals),&#13;
            i = indexFn(self, locals),&#13;
            v, p;&#13;
&#13;
        if (!o) return undefined;&#13;
        v = o[i];&#13;
        if (v &amp;&amp; v.then) {&#13;
          p = v;&#13;
          if (!('$$v' in v)) {&#13;
            p.$$v = undefined;&#13;
            p.then(function(val) { p.$$v = val; });&#13;
          }&#13;
          v = v.$$v;&#13;
        }&#13;
        return v;&#13;
      }, {&#13;
        assign:function(self, value, locals){&#13;
          return obj(self, locals)[indexFn(self, locals)] = value;&#13;
        }&#13;
      });&#13;
  }&#13;
&#13;
  function _functionCall(fn, contextGetter) {&#13;
    var argsFn = [];&#13;
    if (peekToken().text != ')') {&#13;
      do {&#13;
        argsFn.push(expression());&#13;
      } while (expect(','));&#13;
    }&#13;
    consume(')');&#13;
    return function(self, locals){&#13;
      var args = [],&#13;
          context = contextGetter ? contextGetter(self, locals) : self;&#13;
&#13;
      for ( var i = 0; i &lt; argsFn.length; i++) {&#13;
        args.push(argsFn[i](self, locals));&#13;
      }&#13;
      var fnPtr = fn(self, locals) || noop;&#13;
      // IE stupidity!&#13;
      return fnPtr.apply&#13;
          ? fnPtr.apply(context, args)&#13;
          : fnPtr(args[0], args[1], args[2], args[3], args[4]);&#13;
    };&#13;
  }&#13;
&#13;
  // This is used with json array declaration&#13;
  function arrayDeclaration () {&#13;
    var elementFns = [];&#13;
    if (peekToken().text != ']') {&#13;
      do {&#13;
        elementFns.push(expression());&#13;
      } while (expect(','));&#13;
    }&#13;
    consume(']');&#13;
    return function(self, locals){&#13;
      var array = [];&#13;
      for ( var i = 0; i &lt; elementFns.length; i++) {&#13;
        array.push(elementFns[i](self, locals));&#13;
      }&#13;
      return array;&#13;
    };&#13;
  }&#13;
&#13;
  function object () {&#13;
    var keyValues = [];&#13;
    if (peekToken().text != '}') {&#13;
      do {&#13;
        var token = expect(),&#13;
        key = token.string || token.text;&#13;
        consume(":");&#13;
        var value = expression();&#13;
        keyValues.push({key:key, value:value});&#13;
      } while (expect(','));&#13;
    }&#13;
    consume('}');&#13;
    return function(self, locals){&#13;
      var object = {};&#13;
      for ( var i = 0; i &lt; keyValues.length; i++) {&#13;
        var keyValue = keyValues[i];&#13;
        var value = keyValue.value(self, locals);&#13;
        object[keyValue.key] = value;&#13;
      }&#13;
      return object;&#13;
    };&#13;
  }&#13;
}&#13;
&#13;
//////////////////////////////////////////////////&#13;
// Parser helper functions&#13;
//////////////////////////////////////////////////&#13;
&#13;
function setter(obj, path, setValue) {&#13;
  var element = path.split('.');&#13;
  for (var i = 0; element.length &gt; 1; i++) {&#13;
    var key = element.shift();&#13;
    var propertyObj = obj[key];&#13;
    if (!propertyObj) {&#13;
      propertyObj = {};&#13;
      obj[key] = propertyObj;&#13;
    }&#13;
    obj = propertyObj;&#13;
  }&#13;
  obj[element.shift()] = setValue;&#13;
  return setValue;&#13;
}&#13;
&#13;
/**&#13;
 * Return the value accesible from the object by path. Any undefined traversals are ignored&#13;
 * @param {Object} obj starting object&#13;
 * @param {string} path path to traverse&#13;
 * @param {boolean=true} bindFnToScope&#13;
 * @returns value as accesbile by path&#13;
 */&#13;
//TODO(misko): this function needs to be removed&#13;
function getter(obj, path, bindFnToScope) {&#13;
  if (!path) return obj;&#13;
  var keys = path.split('.');&#13;
  var key;&#13;
  var lastInstance = obj;&#13;
  var len = keys.length;&#13;
&#13;
  for (var i = 0; i &lt; len; i++) {&#13;
    key = keys[i];&#13;
    if (obj) {&#13;
      obj = (lastInstance = obj)[key];&#13;
    }&#13;
  }&#13;
  if (!bindFnToScope &amp;&amp; isFunction(obj)) {&#13;
    return bind(lastInstance, obj);&#13;
  }&#13;
  return obj;&#13;
}&#13;
&#13;
var getterFnCache = {};&#13;
&#13;
function getterFn(path) {&#13;
  if (getterFnCache.hasOwnProperty(path)) {&#13;
    return getterFnCache[path];&#13;
  }&#13;
&#13;
  var fn, code = 'var l, fn, p;\n';&#13;
  forEach(path.split('.'), function(key, index) {&#13;
    code += 'if(!s) return s;\n' +&#13;
            'l=s;\n' +&#13;
            's='+ (index&#13;
                    // we simply direference 's' on any .dot notation&#13;
                    ? 's'&#13;
                    // but if we are first then we check locals firs, and if so read it first&#13;
                    : '((k&amp;&amp;k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' +&#13;
            'if (s &amp;&amp; s.then) {\n' +&#13;
              ' if (!("$$v" in s)) {\n' +&#13;
                ' p=s;\n' +&#13;
                ' p.$$v = undefined;\n' +&#13;
                ' p.then(function(v) {p.$$v=v;});\n' +&#13;
                '}\n' +&#13;
              ' s=s.$$v\n' +&#13;
            '}\n';&#13;
  });&#13;
  code += 'return s;';&#13;
  fn = Function('s', 'k', code);&#13;
  fn.toString = function() { return code; };&#13;
&#13;
  return getterFnCache[path] = fn;&#13;
}&#13;
&#13;
///////////////////////////////////&#13;
&#13;
function $ParseProvider() {&#13;
  var cache = {};&#13;
  this.$get = ['$filter', function($filter) {&#13;
    return function(exp) {&#13;
      switch(typeof exp) {&#13;
        case 'string':&#13;
          return cache.hasOwnProperty(exp)&#13;
            ? cache[exp]&#13;
            : cache[exp] =  parser(exp, false, $filter);&#13;
        case 'function':&#13;
          return exp;&#13;
        default:&#13;
          return noop;&#13;
      }&#13;
    };&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc service&#13;
 * @name angular.module.ng.$q&#13;
 * @requires $rootScope&#13;
 *&#13;
 * @description&#13;
 * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).&#13;
 *&#13;
 * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an&#13;
 * interface for interacting with an object that represents the result of an action that is&#13;
 * performed asynchronously, and may or may not be finished at any given point in time.&#13;
 *&#13;
 * From the perspective of dealing with error handling, deferred and promise apis are to&#13;
 * asynchronous programing what `try`, `catch` and `throw` keywords are to synchronous programing.&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 *   // for the purpose of this example let's assume that variables `$q` and `scope` are&#13;
 *   // available in the current lexical scope (they could have been injected or passed in).&#13;
 *&#13;
 *   function asyncGreet(name) {&#13;
 *     var deferred = $q.defer();&#13;
 *&#13;
 *     setTimeout(function() {&#13;
 *       // since this fn executes async in a future turn of the event loop, we need to wrap&#13;
 *       // our code into an $apply call so that the model changes are properly observed.&#13;
 *       scope.$apply(function() {&#13;
 *         if (okToGreet(name)) {&#13;
 *           deferred.resolve('Hello, ' + name + '!');&#13;
 *         } else {&#13;
 *           deferred.reject('Greeting ' + name + ' is not allowed.');&#13;
 *         }&#13;
 *       });&#13;
 *     }, 1000);&#13;
 *&#13;
 *     return deferred.promise;&#13;
 *   }&#13;
 *&#13;
 *   var promise = asyncGreet('Robin Hood');&#13;
 *   promise.then(function(greeting) {&#13;
 *     alert('Success: ' + greeting);&#13;
 *   }, function(reason) {&#13;
 *     alert('Failed: ' + reason);&#13;
 *   );&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * At first it might not be obvious why this extra complexity is worth the trouble. The payoff&#13;
 * comes in the way of&#13;
 * [guarantees that promise and deferred apis make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).&#13;
 *&#13;
 * Additionally the promise api allows for composition that is very hard to do with the&#13;
 * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.&#13;
 * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the&#13;
 * section on serial or parallel joining of promises.&#13;
 *&#13;
 *&#13;
 * # The Deferred API&#13;
 *&#13;
 * A new instance of deferred is constructed by calling `$q.defer()`.&#13;
 *&#13;
 * The purpose of the deferred object is to expose the associated Promise instance as well as apis&#13;
 * that can be used for signaling the successful or unsuccessful completion of the task.&#13;
 *&#13;
 * **Methods**&#13;
 *&#13;
 * - `resolve(value)` â€" resolves the derived promise with the `value`. If the value is a rejection&#13;
 *   constructed via `$q.reject`, the promise will be rejected instead.&#13;
 * - `reject(reason)` â€" rejects the derived promise with the `reason`. This is equivalent to&#13;
 *   resolving it with a rejection constructed via `$q.reject`.&#13;
 *&#13;
 * **Properties**&#13;
 *&#13;
 * - promise â€" `{Promise}` â€" promise object associated with this deferred.&#13;
 *&#13;
 *&#13;
 * # The Promise API&#13;
 *&#13;
 * A new promise instance is created when a deferred instance is created and can be retrieved by&#13;
 * calling `deferred.promise`.&#13;
 *&#13;
 * The purpose of the promise object is to allow for interested parties to get access to the result&#13;
 * of the deferred task when it completes.&#13;
 *&#13;
 * **Methods**&#13;
 *&#13;
 * - `then(successCallback, errorCallback)` â€" regardless of when the promise was or will be resolved&#13;
 *   or rejected calls one of the success or error callbacks asynchronously as soon as the result&#13;
 *   is available. The callbacks are called with a single argument the result or rejection reason.&#13;
 *&#13;
 *   This method *returns a new promise* which is resolved or rejected via the return value of the&#13;
 *   `successCallback` or `errorCallback`.&#13;
 *&#13;
 *&#13;
 * # Chaining promises&#13;
 *&#13;
 * Because calling `then` api of a promise returns a new derived promise, it is easily possible&#13;
 * to create a chain of promises:&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 *   promiseB = promiseA.then(function(result) {&#13;
 *     return result + 1;&#13;
 *   });&#13;
 *&#13;
 *   // promiseB will be resolved immediately after promiseA is resolved and it's value will be&#13;
 *   // the result of promiseA incremented by 1&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * It is possible to create chains of any length and since a promise can be resolved with another&#13;
 * promise (which will defer its resolution further), it is possible to pause/defer resolution of&#13;
 * the promises at any point in the chain. This makes it possible to implement powerful apis like&#13;
 * $http's response interceptors.&#13;
 *&#13;
 *&#13;
 * # Differences between Kris Kowal's Q and $q&#13;
 *&#13;
 *  There are three main differences:&#13;
 *&#13;
 * - $q is integrated with the {@link angular.module.ng.$rootScope.Scope} Scope model observation&#13;
 *   mechanism in angular, which means faster propagation of resolution or rejection into your&#13;
 *   models and avoiding unnecessary browser repaints, which would result in flickering UI.&#13;
 * - $q promises are recognized by the templating engine in angular, which means that in templates&#13;
 *   you can treat promises attached to a scope as if they were the resulting values.&#13;
 * - Q has many more features that $q, but that comes at a cost of bytes. $q is tiny, but contains&#13;
 *   all the important functionality needed for common async tasks.&#13;
 */&#13;
function $QProvider() {&#13;
&#13;
  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {&#13;
    return qFactory(function(callback) {&#13;
      $rootScope.$evalAsync(callback);&#13;
    }, $exceptionHandler);&#13;
  }];&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Constructs a promise manager.&#13;
 *&#13;
 * @param {function(function)} nextTick Function for executing functions in the next turn.&#13;
 * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for&#13;
 *     debugging purposes.&#13;
 * @returns {object} Promise manager.&#13;
 */&#13;
function qFactory(nextTick, exceptionHandler) {&#13;
&#13;
  /**&#13;
   * @ngdoc&#13;
   * @name angular.module.ng.$q#defer&#13;
   * @methodOf angular.module.ng.$q&#13;
   * @description&#13;
   * Creates a `Deferred` object which represents a task which will finish in the future.&#13;
   *&#13;
   * @returns {Deferred} Returns a new instance of deferred.&#13;
   */&#13;
  var defer = function() {&#13;
    var pending = [],&#13;
        value, deferred;&#13;
&#13;
    deferred = {&#13;
&#13;
      resolve: function(val) {&#13;
        if (pending) {&#13;
          var callbacks = pending;&#13;
          pending = undefined;&#13;
          value = ref(val);&#13;
&#13;
          if (callbacks.length) {&#13;
            nextTick(function() {&#13;
              var callback;&#13;
              for (var i = 0, ii = callbacks.length; i &lt; ii; i++) {&#13;
                callback = callbacks[i];&#13;
                value.then(callback[0], callback[1]);&#13;
              }&#13;
            });&#13;
          }&#13;
        }&#13;
      },&#13;
&#13;
&#13;
      reject: function(reason) {&#13;
        deferred.resolve(reject(reason));&#13;
      },&#13;
&#13;
&#13;
      promise: {&#13;
        then: function(callback, errback) {&#13;
          var result = defer();&#13;
&#13;
          var wrappedCallback = function(value) {&#13;
            try {&#13;
              result.resolve((callback || defaultCallback)(value));&#13;
            } catch(e) {&#13;
              exceptionHandler(e);&#13;
              result.reject(e);&#13;
            }&#13;
          };&#13;
&#13;
          var wrappedErrback = function(reason) {&#13;
            try {&#13;
              result.resolve((errback || defaultErrback)(reason));&#13;
            } catch(e) {&#13;
              exceptionHandler(e);&#13;
              result.reject(e);&#13;
            }&#13;
          };&#13;
&#13;
          if (pending) {&#13;
            pending.push([wrappedCallback, wrappedErrback]);&#13;
          } else {&#13;
            value.then(wrappedCallback, wrappedErrback);&#13;
          }&#13;
&#13;
          return result.promise;&#13;
        }&#13;
      }&#13;
    };&#13;
&#13;
    return deferred;&#13;
  };&#13;
&#13;
&#13;
  var ref = function(value) {&#13;
    if (value &amp;&amp; value.then) return value;&#13;
    return {&#13;
      then: function(callback) {&#13;
        var result = defer();&#13;
        nextTick(function() {&#13;
          result.resolve(callback(value));&#13;
        });&#13;
        return result.promise;&#13;
      }&#13;
    };&#13;
  };&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc&#13;
   * @name angular.module.ng.$q#reject&#13;
   * @methodOf angular.module.ng.$q&#13;
   * @description&#13;
   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be&#13;
   * used to forward rejection in a chain of promises. If you are dealing with the last promise in&#13;
   * a promise chain, you don't need to worry about it.&#13;
   *&#13;
   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of&#13;
   * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via&#13;
   * a promise error callback and you want to forward the error to the promise derived from the&#13;
   * current promise, you have to "rethrow" the error by returning a rejection constructed via&#13;
   * `reject`.&#13;
   *&#13;
   * &lt;pre&gt;&#13;
   *   promiseB = promiseA.then(function(result) {&#13;
   *     // success: do something and resolve promiseB&#13;
   *     //          with the old or a new result&#13;
   *     return result;&#13;
   *   }, function(reason) {&#13;
   *     // error: handle the error if possible and&#13;
   *     //        resolve promiseB with newPromiseOrValue,&#13;
   *     //        otherwise forward the rejection to promiseB&#13;
   *     if (canHandle(reason)) {&#13;
   *      // handle the error and recover&#13;
   *      return newPromiseOrValue;&#13;
   *     }&#13;
   *     return $q.reject(reason);&#13;
   *   });&#13;
   * &lt;/pre&gt;&#13;
   *&#13;
   * @param {*} reason Constant, message, exception or an object representing the rejection reason.&#13;
   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.&#13;
   */&#13;
  var reject = function(reason) {&#13;
    return {&#13;
      then: function(callback, errback) {&#13;
        var result = defer();&#13;
        nextTick(function() {&#13;
          result.resolve((errback || defaultErrback)(reason));&#13;
        });&#13;
        return result.promise;&#13;
      }&#13;
    };&#13;
  };&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc&#13;
   * @name angular.module.ng.$q#when&#13;
   * @methodOf angular.module.ng.$q&#13;
   * @description&#13;
   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.&#13;
   * This is useful when you are dealing with on object that might or might not be a promise, or if&#13;
   * the promise comes from a source that can't be trusted.&#13;
   *&#13;
   * @param {*} value Value or a promise&#13;
   * @returns {Promise} Returns a single promise that will be resolved with an array of values,&#13;
   *   each value coresponding to the promise at the same index in the `promises` array. If any of&#13;
   *   the promises is resolved with a rejection, this resulting promise will be resolved with the&#13;
   *   same rejection.&#13;
   */&#13;
  var when = function(value, callback, errback) {&#13;
    var result = defer(),&#13;
        done;&#13;
&#13;
    var wrappedCallback = function(value) {&#13;
      try {&#13;
        return (callback || defaultCallback)(value);&#13;
      } catch (e) {&#13;
        exceptionHandler(e);&#13;
        return reject(e);&#13;
      }&#13;
    };&#13;
&#13;
    var wrappedErrback = function(reason) {&#13;
      try {&#13;
        return (errback || defaultErrback)(reason);&#13;
      } catch (e) {&#13;
        exceptionHandler(e);&#13;
        return reject(e);&#13;
      }&#13;
    };&#13;
&#13;
    nextTick(function() {&#13;
      ref(value).then(function(value) {&#13;
        if (done) return;&#13;
        done = true;&#13;
        result.resolve(ref(value).then(wrappedCallback, wrappedErrback));&#13;
      }, function(reason) {&#13;
        if (done) return;&#13;
        done = true;&#13;
        result.resolve(wrappedErrback(reason));&#13;
      });&#13;
    });&#13;
&#13;
    return result.promise;&#13;
  };&#13;
&#13;
&#13;
  function defaultCallback(value) {&#13;
    return value;&#13;
  }&#13;
&#13;
&#13;
  function defaultErrback(reason) {&#13;
    return reject(reason);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc&#13;
   * @name angular.module.ng.$q#all&#13;
   * @methodOf angular.module.ng.$q&#13;
   * @description&#13;
   * Combines multiple promises into a single promise that is resolved when all of the input&#13;
   * promises are resolved.&#13;
   *&#13;
   * @param {Array.&lt;Promise&gt;} promises An array of promises.&#13;
   * @returns {Promise} Returns a single promise that will be resolved with an array of values,&#13;
   *   each value coresponding to the promise at the same index in the `promises` array. If any of&#13;
   *   the promises is resolved with a rejection, this resulting promise will be resolved with the&#13;
   *   same rejection.&#13;
   */&#13;
  function all(promises) {&#13;
    var deferred = defer(),&#13;
        counter = promises.length,&#13;
        results = [];&#13;
&#13;
    if (counter) {&#13;
      forEach(promises, function(promise, index) {&#13;
        ref(promise).then(function(value) {&#13;
          if (index in results) return;&#13;
          results[index] = value;&#13;
          if (!(--counter)) deferred.resolve(results);&#13;
        }, function(reason) {&#13;
          if (index in results) return;&#13;
          deferred.reject(reason);&#13;
        });&#13;
      });&#13;
    } else {&#13;
      deferred.resolve(results);&#13;
    }&#13;
&#13;
    return deferred.promise;&#13;
  }&#13;
&#13;
  return {&#13;
    defer: defer,&#13;
    reject: reject,&#13;
    when: when,&#13;
    all: all&#13;
  };&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$routeProvider&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 *&#13;
 * Used for configuring routes. See {@link angular.module.ng.$route $route} for an example.&#13;
 */&#13;
function $RouteProvider(){&#13;
  var routes = {};&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$routeProvider#when&#13;
   * @methodOf angular.module.ng.$routeProvider&#13;
   *&#13;
   * @param {string} path Route path (matched against `$location.path`). If `$location.path`&#13;
   *    contains redudant trailing slash or is missing one, the route will still match and the&#13;
   *    `$location.path` will be updated to add or drop the trailing slash to exacly match the&#13;
   *    route definition.&#13;
   * @param {Object} route Mapping information to be assigned to `$route.current` on route&#13;
   *    match.&#13;
   *&#13;
   *    Object properties:&#13;
   *&#13;
   *    - `controller` â€" `{function()=}` â€" Controller fn that should be associated with newly&#13;
   *      created scope.&#13;
   *    - `template` â€" `{string=}` â€" path to an html template that should be used by&#13;
   *      {@link angular.module.ng.$compileProvider.directive.ng-view ng-view} or&#13;
   *      {@link angular.module.ng.$compileProvider.directive.ng-include ng-include} directives.&#13;
   *    - `redirectTo` â€" {(string|function())=} â€" value to update&#13;
   *      {@link angular.module.ng.$location $location} path with and trigger route redirection.&#13;
   *&#13;
   *      If `redirectTo` is a function, it will be called with the following parameters:&#13;
   *&#13;
   *      - `{Object.&lt;string&gt;}` - route parameters extracted from the current&#13;
   *        `$location.path()` by applying the current route template.&#13;
   *      - `{string}` - current `$location.path()`&#13;
   *      - `{Object}` - current `$location.search()`&#13;
   *&#13;
   *      The custom `redirectTo` function is expected to return a string which will be used&#13;
   *      to update `$location.path()` and `$location.search()`.&#13;
   *&#13;
   *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()&#13;
   *    changes.&#13;
   *&#13;
   *      If the option is set to `false` and url in the browser changes, then&#13;
   *      `$routeUpdate` event is broadcasted on the root scope.&#13;
   *&#13;
   * @returns {Object} self&#13;
   *&#13;
   * @description&#13;
   * Adds a new route definition to the `$route` service.&#13;
   */&#13;
  this.when = function(path, route) {&#13;
    routes[path] = extend({reloadOnSearch: true}, route);&#13;
&#13;
    // create redirection for trailing slashes&#13;
    if (path) {&#13;
      var redirectPath = (path[path.length-1] == '/')&#13;
          ? path.substr(0, path.length-1)&#13;
          : path +'/';&#13;
&#13;
      routes[redirectPath] = {redirectTo: path};&#13;
    }&#13;
&#13;
    return this;&#13;
  };&#13;
&#13;
  /**&#13;
   * @ngdoc method&#13;
   * @name angular.module.ng.$routeProvider#otherwise&#13;
   * @methodOf angular.module.ng.$routeProvider&#13;
   *&#13;
   * @description&#13;
   * Sets route definition that will be used on route change when no other route definition&#13;
   * is matched.&#13;
   *&#13;
   * @param {Object} params Mapping information to be assigned to `$route.current`.&#13;
   * @returns {Object} self&#13;
   */&#13;
  this.otherwise = function(params) {&#13;
    this.when(null, params);&#13;
    return this;&#13;
  };&#13;
&#13;
&#13;
  this.$get = ['$rootScope', '$location', '$routeParams',&#13;
      function( $rootScope,  $location,  $routeParams) {&#13;
&#13;
    /**&#13;
     * @ngdoc object&#13;
     * @name angular.module.ng.$route&#13;
     * @requires $location&#13;
     * @requires $routeParams&#13;
     *&#13;
     * @property {Object} current Reference to the current route definition.&#13;
     * @property {Array.&lt;Object&gt;} routes Array of all configured routes.&#13;
     *&#13;
     * @description&#13;
     * Is used for deep-linking URLs to controllers and views (HTML partials).&#13;
     * It watches `$location.url()` and tries to map the path to an existing route definition.&#13;
     *&#13;
     * You can define routes through {@link angular.module.ng.$routeProvider $routeProvider}'s API.&#13;
     *&#13;
     * The `$route` service is typically used in conjunction with {@link angular.module.ng.$compileProvider.directive.ng-view ng-view}&#13;
     * directive and the {@link angular.module.ng.$routeParams $routeParams} service.&#13;
     *&#13;
     * @example&#13;
       This example shows how changing the URL hash causes the `$route` to match a route against the&#13;
       URL, and the `ng-view` pulls in the partial.&#13;
&#13;
       Note that this example is using {@link angular.module.ng.$compileProvider.directive.script inlined templates}&#13;
       to get it working on jsfiddle as well.&#13;
&#13;
      &lt;doc:example module="route"&gt;&#13;
        &lt;doc:source&gt;&#13;
          &lt;script type="text/ng-template" id="examples/book.html"&gt;&#13;
            controller: {{name}}&lt;br /&gt;&#13;
            Book Id: {{params.bookId}}&lt;br /&gt;&#13;
          &lt;/script&gt;&#13;
&#13;
          &lt;script type="text/ng-template" id="examples/chapter.html"&gt;&#13;
            controller: {{name}}&lt;br /&gt;&#13;
            Book Id: {{params.bookId}}&lt;br /&gt;&#13;
            Chapter Id: {{params.chapterId}}&#13;
          &lt;/script&gt;&#13;
&#13;
          &lt;script&gt;&#13;
            angular.module('route', [], function($routeProvider, $locationProvider) {&#13;
              $routeProvider.when('/Book/:bookId', {template: 'examples/book.html', controller: BookCntl});&#13;
              $routeProvider.when('/Book/:bookId/ch/:chapterId', {template: 'examples/chapter.html', controller: ChapterCntl});&#13;
&#13;
              // configure html5 to get links working on jsfiddle&#13;
              $locationProvider.html5Mode(true);&#13;
            });&#13;
&#13;
            function MainCntl($scope, $route, $routeParams, $location) {&#13;
              $scope.$route = $route;&#13;
              $scope.$location = $location;&#13;
              $scope.$routeParams = $routeParams;&#13;
            }&#13;
&#13;
            function BookCntl($scope, $routeParams) {&#13;
              $scope.name = "BookCntl";&#13;
              $scope.params = $routeParams;&#13;
            }&#13;
&#13;
            function ChapterCntl($scope, $routeParams) {&#13;
              $scope.name = "ChapterCntl";&#13;
              $scope.params = $routeParams;&#13;
            }&#13;
          &lt;/script&gt;&#13;
&#13;
          &lt;div ng-controller="MainCntl"&gt;&#13;
            Choose:&#13;
            &lt;a href="/Book/Moby"&gt;Moby&lt;/a&gt; |&#13;
            &lt;a href="/Book/Moby/ch/1"&gt;Moby: Ch1&lt;/a&gt; |&#13;
            &lt;a href="/Book/Gatsby"&gt;Gatsby&lt;/a&gt; |&#13;
            &lt;a href="/Book/Gatsby/ch/4?key=value"&gt;Gatsby: Ch4&lt;/a&gt; |&#13;
            &lt;a href="/Book/Scarlet"&gt;Scarlet Letter&lt;/a&gt;&lt;br/&gt;&#13;
&#13;
            &lt;div ng-view&gt;&lt;/div&gt;&#13;
            &lt;hr /&gt;&#13;
&#13;
            &lt;pre&gt;$location.path() = {{$location.path()}}&lt;/pre&gt;&#13;
            &lt;pre&gt;$route.current.template = {{$route.current.template}}&lt;/pre&gt;&#13;
            &lt;pre&gt;$route.current.params = {{$route.current.params}}&lt;/pre&gt;&#13;
            &lt;pre&gt;$route.current.scope.name = {{$route.current.scope.name}}&lt;/pre&gt;&#13;
            &lt;pre&gt;$routeParams = {{$routeParams}}&lt;/pre&gt;&#13;
          &lt;/div&gt;&#13;
        &lt;/doc:source&gt;&#13;
        &lt;doc:scenario&gt;&#13;
          it('should load and compile correct template', function() {&#13;
            element('a:contains("Moby: Ch1")').click();&#13;
            var content = element('.doc-example-live [ng-view]').text();&#13;
            expect(content).toMatch(/controller\: ChapterCntl/);&#13;
            expect(content).toMatch(/Book Id\: Moby/);&#13;
            expect(content).toMatch(/Chapter Id\: 1/);&#13;
&#13;
            element('a:contains("Scarlet")').click();&#13;
            content = element('.doc-example-live [ng-view]').text();&#13;
            expect(content).toMatch(/controller\: BookCntl/);&#13;
            expect(content).toMatch(/Book Id\: Scarlet/);&#13;
          });&#13;
        &lt;/doc:scenario&gt;&#13;
      &lt;/doc:example&gt;&#13;
     */&#13;
&#13;
    /**&#13;
     * @ngdoc event&#13;
     * @name angular.module.ng.$route#$beforeRouteChange&#13;
     * @eventOf angular.module.ng.$route&#13;
     * @eventType broadcast on root scope&#13;
     * @description&#13;
     * Broadcasted before a route change.&#13;
     *&#13;
     * @param {Route} next Future route information.&#13;
     * @param {Route} current Current route information.&#13;
     */&#13;
&#13;
    /**&#13;
     * @ngdoc event&#13;
     * @name angular.module.ng.$route#$afterRouteChange&#13;
     * @eventOf angular.module.ng.$route&#13;
     * @eventType broadcast on root scope&#13;
     * @description&#13;
     * Broadcasted after a route change.&#13;
     *&#13;
     * @param {Route} current Current route information.&#13;
     * @param {Route} previous Previous route information.&#13;
     */&#13;
&#13;
    /**&#13;
     * @ngdoc event&#13;
     * @name angular.module.ng.$route#$routeUpdate&#13;
     * @eventOf angular.module.ng.$route&#13;
     * @eventType broadcast on root scope&#13;
     * @description&#13;
     *&#13;
     * The `reloadOnSearch` property has been set to false, and we are reusing the same&#13;
     * instance of the Controller.&#13;
     */&#13;
&#13;
    var matcher = switchRouteMatcher,&#13;
        dirty = 0,&#13;
        forceReload = false,&#13;
        $route = {&#13;
          routes: routes,&#13;
&#13;
          /**&#13;
           * @ngdoc method&#13;
           * @name angular.module.ng.$route#reload&#13;
           * @methodOf angular.module.ng.$route&#13;
           *&#13;
           * @description&#13;
           * Causes `$route` service to reload the current route even if&#13;
           * {@link angular.module.ng.$location $location} hasn't changed.&#13;
           *&#13;
           * As a result of that, {@link angular.module.ng.$compileProvider.directive.ng-view ng-view}&#13;
           * creates new scope, reinstantiates the controller.&#13;
           */&#13;
          reload: function() {&#13;
            dirty++;&#13;
            forceReload = true;&#13;
          }&#13;
        };&#13;
&#13;
    $rootScope.$watch(function() { return dirty + $location.url(); }, updateRoute);&#13;
&#13;
    return $route;&#13;
&#13;
    /////////////////////////////////////////////////////&#13;
&#13;
    function switchRouteMatcher(on, when) {&#13;
      // TODO(i): this code is convoluted and inefficient, we should construct the route matching&#13;
      //   regex only once and then reuse it&#13;
      var regex = '^' + when.replace(/([\.\\\(\)\^\$])/g, "\\$1") + '$',&#13;
          params = [],&#13;
          dst = {};&#13;
      forEach(when.split(/\W/), function(param) {&#13;
        if (param) {&#13;
          var paramRegExp = new RegExp(":" + param + "([\\W])");&#13;
          if (regex.match(paramRegExp)) {&#13;
            regex = regex.replace(paramRegExp, "([^\\/]*)$1");&#13;
            params.push(param);&#13;
          }&#13;
        }&#13;
      });&#13;
      var match = on.match(new RegExp(regex));&#13;
      if (match) {&#13;
        forEach(params, function(name, index) {&#13;
          dst[name] = match[index + 1];&#13;
        });&#13;
      }&#13;
      return match ? dst : null;&#13;
    }&#13;
&#13;
    function updateRoute() {&#13;
      var next = parseRoute(),&#13;
          last = $route.current;&#13;
&#13;
      if (next &amp;&amp; last &amp;&amp; next.$route === last.$route&#13;
          &amp;&amp; equals(next.pathParams, last.pathParams) &amp;&amp; !next.reloadOnSearch &amp;&amp; !forceReload) {&#13;
        last.params = next.params;&#13;
        copy(last.params, $routeParams);&#13;
        $rootScope.$broadcast('$routeUpdate', last);&#13;
      } else if (next || last) {&#13;
        forceReload = false;&#13;
        $rootScope.$broadcast('$beforeRouteChange', next, last);&#13;
        $route.current = next;&#13;
        if (next) {&#13;
          if (next.redirectTo) {&#13;
            if (isString(next.redirectTo)) {&#13;
              $location.path(interpolate(next.redirectTo, next.params)).search(next.params)&#13;
                       .replace();&#13;
            } else {&#13;
              $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))&#13;
                       .replace();&#13;
            }&#13;
          } else {&#13;
            copy(next.params, $routeParams);&#13;
          }&#13;
        }&#13;
        $rootScope.$broadcast('$afterRouteChange', next, last);&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @returns the current active route, by matching it against the URL&#13;
     */&#13;
    function parseRoute() {&#13;
      // Match a route&#13;
      var params, match;&#13;
      forEach(routes, function(route, path) {&#13;
        if (!match &amp;&amp; (params = matcher($location.path(), path))) {&#13;
          match = inherit(route, {&#13;
            params: extend({}, $location.search(), params),&#13;
            pathParams: params});&#13;
          match.$route = route;&#13;
        }&#13;
      });&#13;
      // No route matched; fallback to "otherwise" route&#13;
      return match || routes[null] &amp;&amp; inherit(routes[null], {params: {}, pathParams:{}});&#13;
    }&#13;
&#13;
    /**&#13;
     * @returns interpolation of the redirect path with the parametrs&#13;
     */&#13;
    function interpolate(string, params) {&#13;
      var result = [];&#13;
      forEach((string||'').split(':'), function(segment, i) {&#13;
        if (i == 0) {&#13;
          result.push(segment);&#13;
        } else {&#13;
          var segmentMatch = segment.match(/(\w+)(.*)/);&#13;
          var key = segmentMatch[1];&#13;
          result.push(params[key]);&#13;
          result.push(segmentMatch[2] || '');&#13;
          delete params[key];&#13;
        }&#13;
      });&#13;
      return result.join('');&#13;
    }&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$routeParams&#13;
 * @requires $route&#13;
 *&#13;
 * @description&#13;
 * Current set of route parameters. The route parameters are a combination of the&#13;
 * {@link angular.module.ng.$location $location} `search()`, and `path()`. The `path` parameters&#13;
 * are extracted when the {@link angular.module.ng.$route $route} path is matched.&#13;
 *&#13;
 * In case of parameter name collision, `path` params take precedence over `search` params.&#13;
 *&#13;
 * The service guarantees that the identity of the `$routeParams` object will remain unchanged&#13;
 * (but its properties will likely change) even when a route change occurs.&#13;
 *&#13;
 * @example&#13;
 * &lt;pre&gt;&#13;
 *  // Given:&#13;
 *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby&#13;
 *  // Route: /Chapter/:chapterId/Section/:sectionId&#13;
 *  //&#13;
 *  // Then&#13;
 *  $routeParams ==&gt; {chapterId:1, sectionId:2, search:'moby'}&#13;
 * &lt;/pre&gt;&#13;
 */&#13;
function $RouteParamsProvider() {&#13;
  this.$get = valueFn({});&#13;
}&#13;
&#13;
/**&#13;
 * DESIGN NOTES&#13;
 *&#13;
 * The design decisions behind the scope ware heavily favored for speed and memory consumption.&#13;
 *&#13;
 * The typical use of scope is to watch the expressions, which most of the time return the same&#13;
 * value as last time so we optimize the operation.&#13;
 *&#13;
 * Closures construction is expensive from speed as well as memory:&#13;
 *   - no closures, instead ups prototypical inheritance for API&#13;
 *   - Internal state needs to be stored on scope directly, which means that private state is&#13;
 *     exposed as $$____ properties&#13;
 *&#13;
 * Loop operations are optimized by using while(count--) { ... }&#13;
 *   - this means that in order to keep the same order of execution as addition we have to add&#13;
 *     items to the array at the begging (shift) instead of at the end (push)&#13;
 *&#13;
 * Child scopes are created and removed often&#13;
 *   - Using array would be slow since inserts in meddle are expensive so we use linked list&#13;
 *&#13;
 * There are few watches then a lot of observers. This is why you don't want the observer to be&#13;
 * implemented in the same way as watch. Watch requires return of initialization function which&#13;
 * are expensive to construct.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$rootScopeProvider&#13;
 * @description&#13;
 *&#13;
 * Provider for the $rootScope service.&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$rootScopeProvider#digestTtl&#13;
 * @methodOf angular.module.ng.$rootScopeProvider&#13;
 * @description&#13;
 *&#13;
 * Sets the number of digest iteration the scope should attempt to execute before giving up and&#13;
 * assuming that the model is unstable.&#13;
 *&#13;
 * The current default is 10 iterations.&#13;
 *&#13;
 * @param {number} limit The number of digest iterations.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$rootScope&#13;
 * @description&#13;
 *&#13;
 * Every application has a single root {@link angular.module.ng.$rootScope.Scope scope}.&#13;
 * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide&#13;
 * event processing life-cycle. See {@link guide/dev_guide.scopes developer guide on scopes}.&#13;
 */&#13;
function $RootScopeProvider(){&#13;
  var TTL = 10;&#13;
&#13;
  this.digestTtl = function(value) {&#13;
    if (arguments.length) {&#13;
      TTL = value;&#13;
    }&#13;
    return TTL;&#13;
  }&#13;
&#13;
  this.$get = ['$injector', '$exceptionHandler', '$parse',&#13;
      function( $injector,   $exceptionHandler,   $parse) {&#13;
&#13;
    /**&#13;
     * @ngdoc function&#13;
     * @name angular.module.ng.$rootScope.Scope&#13;
     *&#13;
     * @description&#13;
     * A root scope can be retrieved using the {@link angular.module.ng.$rootScope $rootScope} key from the&#13;
     * {@link angular.module.AUTO.$injector $injector}. Child scopes are created using the&#13;
     * {@link angular.module.ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when&#13;
     * compiled HTML template is executed.)&#13;
     *&#13;
     * Here is a simple scope snippet to show how you can interact with the scope.&#13;
     * &lt;pre&gt;&#13;
        angular.injector(['ng']).invoke(function($rootScope) {&#13;
           var scope = $rootScope.$new();&#13;
           scope.salutation = 'Hello';&#13;
           scope.name = 'World';&#13;
&#13;
           expect(scope.greeting).toEqual(undefined);&#13;
&#13;
           scope.$watch('name', function() {&#13;
             this.greeting = this.salutation + ' ' + this.name + '!';&#13;
           }); // initialize the watch&#13;
&#13;
           expect(scope.greeting).toEqual(undefined);&#13;
           scope.name = 'Misko';&#13;
           // still old value, since watches have not been called yet&#13;
           expect(scope.greeting).toEqual(undefined);&#13;
&#13;
           scope.$digest(); // fire all  the watches&#13;
           expect(scope.greeting).toEqual('Hello Misko!');&#13;
        });&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * # Inheritance&#13;
     * A scope can inherit from a parent scope, as in this example:&#13;
     * &lt;pre&gt;&#13;
         var parent = $rootScope;&#13;
         var child = parent.$new();&#13;
&#13;
         parent.salutation = "Hello";&#13;
         child.name = "World";&#13;
         expect(child.salutation).toEqual('Hello');&#13;
&#13;
         child.salutation = "Welcome";&#13;
         expect(child.salutation).toEqual('Welcome');&#13;
         expect(parent.salutation).toEqual('Hello');&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * # Dependency Injection&#13;
     * See {@link guide/dev_guide.di dependency injection}.&#13;
     *&#13;
     *&#13;
     * @param {Object.&lt;string, function()&gt;=} providers Map of service factory which need to be provided&#13;
     *     for the current scope. Defaults to {@link angular.module.ng}.&#13;
     * @param {Object.&lt;string, *&gt;=} instanceCache Provides pre-instantiated services which should&#13;
     *     append/override services provided by `providers`. This is handy when unit-testing and having&#13;
     *     the need to override a default service.&#13;
     * @returns {Object} Newly created scope.&#13;
     *&#13;
     */&#13;
    function Scope() {&#13;
      this.$id = nextUid();&#13;
      this.$$phase = this.$parent = this.$$watchers =&#13;
                     this.$$nextSibling = this.$$prevSibling =&#13;
                     this.$$childHead = this.$$childTail = null;&#13;
      this['this'] = this.$root =  this;&#13;
      this.$$asyncQueue = [];&#13;
      this.$$listeners = {};&#13;
    }&#13;
&#13;
    /**&#13;
     * @ngdoc property&#13;
     * @name angular.module.ng.$rootScope.Scope#$id&#13;
     * @propertyOf angular.module.ng.$rootScope.Scope&#13;
     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for&#13;
     *   debugging.&#13;
     */&#13;
&#13;
&#13;
    Scope.prototype = {&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$new&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Creates a new child {@link angular.module.ng.$rootScope.Scope scope}.&#13;
       *&#13;
       * The parent scope will propagate the {@link angular.module.ng.$rootScope.Scope#$digest $digest()} and&#13;
       * {@link angular.module.ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope&#13;
       * hierarchy using {@link angular.module.ng.$rootScope.Scope#$destroy $destroy()}.&#13;
       *&#13;
       * {@link angular.module.ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for&#13;
       * the scope and its child scopes to be permanently detached from the parent and thus stop&#13;
       * participating in model change detection and listener notification by invoking.&#13;
       *&#13;
       * @params {boolean} isolate if true then the scoped does not prototypically inherit from the&#13;
       *         parent scope. The scope is isolated, as it can not se parent scope properties.&#13;
       *         When creating widgets it is useful for the widget to not accidently read parent&#13;
       *         state.&#13;
       *&#13;
       * @returns {Object} The newly created child scope.&#13;
       *&#13;
       */&#13;
      $new: function(isolate) {&#13;
        var Child,&#13;
            child;&#13;
&#13;
        if (isFunction(isolate)) {&#13;
          // TODO: remove at some point&#13;
          throw Error('API-CHANGE: Use $controller to instantiate controllers.');&#13;
        }&#13;
        if (isolate) {&#13;
          child = new Scope();&#13;
          child.$root = this.$root;&#13;
        } else {&#13;
          Child = function() {}; // should be anonymous; This is so that when the minifier munges&#13;
            // the name it does not become random set of chars. These will then show up as class&#13;
            // name in the debugger.&#13;
          Child.prototype = this;&#13;
          child = new Child();&#13;
          child.$id = nextUid();&#13;
        }&#13;
        child['this'] = child;&#13;
        child.$$listeners = {};&#13;
        child.$parent = this;&#13;
        child.$$asyncQueue = [];&#13;
        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;&#13;
        child.$$prevSibling = this.$$childTail;&#13;
        if (this.$$childHead) {&#13;
          this.$$childTail.$$nextSibling = child;&#13;
          this.$$childTail = child;&#13;
        } else {&#13;
          this.$$childHead = this.$$childTail = child;&#13;
        }&#13;
        return child;&#13;
      },&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$watch&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.&#13;
       *&#13;
       * - The `watchExpression` is called on every call to {@link angular.module.ng.$rootScope.Scope#$digest $digest()} and&#13;
       *   should return the value which will be watched. (Since {@link angular.module.ng.$rootScope.Scope#$digest $digest()}&#13;
       *   reruns when it detects changes the `watchExpression` can execute multiple times per&#13;
       *   {@link angular.module.ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)&#13;
       * - The `listener` is called only when the value from the current `watchExpression` and the&#13;
       *   previous call to `watchExpression' are not equal (with the exception of the initial run&#13;
       *   see below). The inequality is determined according to&#13;
       *   {@link angular.equals} function. To save the value of the object for later comparison&#13;
       *   {@link angular.copy} function is used. It also means that watching complex options will&#13;
       *   have adverse memory and performance implications.&#13;
       * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This&#13;
       *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration&#13;
       *   limit is 100 to prevent infinity loop deadlock.&#13;
       *&#13;
       *&#13;
       * If you want to be notified whenever {@link angular.module.ng.$rootScope.Scope#$digest $digest} is called,&#13;
       * you can register an `watchExpression` function with no `listener`. (Since `watchExpression`,&#13;
       * can execute multiple times per {@link angular.module.ng.$rootScope.Scope#$digest $digest} cycle when a change is&#13;
       * detected, be prepared for multiple calls to your listener.)&#13;
       *&#13;
       * After a watcher is registered with the scope, the `listener` fn is called asynchronously&#13;
       * (via {@link angular.module.ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the&#13;
       * watcher. In rare cases, this is undesirable because the listener is called when the result&#13;
       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you&#13;
       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the&#13;
       * listener was called due to initialization.&#13;
       *&#13;
       *&#13;
       * # Example&#13;
         &lt;pre&gt;&#13;
           // let's assume that scope was dependency injected as the $rootScope&#13;
           var scope = $rootScope;&#13;
           scope.name = 'misko';&#13;
           scope.counter = 0;&#13;
&#13;
           expect(scope.counter).toEqual(0);&#13;
           scope.$watch('name', function(newValue, oldValue) { counter = counter + 1; });&#13;
           expect(scope.counter).toEqual(0);&#13;
&#13;
           scope.$digest();&#13;
           // no variable change&#13;
           expect(scope.counter).toEqual(0);&#13;
&#13;
           scope.name = 'adam';&#13;
           scope.$digest();&#13;
           expect(scope.counter).toEqual(1);&#13;
         &lt;/pre&gt;&#13;
       *&#13;
       *&#13;
       *&#13;
       * @param {(function()|string)} watchExpression Expression that is evaluated on each&#13;
       *    {@link angular.module.ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a&#13;
       *    call to the `listener`.&#13;
       *&#13;
       *    - `string`: Evaluated as {@link guide/dev_guide.expressions expression}&#13;
       *    - `function(scope)`: called with current `scope` as a parameter.&#13;
       * @param {(function()|string)=} listener Callback called whenever the return value of&#13;
       *   the `watchExpression` changes.&#13;
       *&#13;
       *    - `string`: Evaluated as {@link guide/dev_guide.expressions expression}&#13;
       *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.&#13;
       *&#13;
       * @param {boolean=} objectEquality Compare object for equality rather then for refference.&#13;
       * @returns {function()} Returns a deregistration function for this listener.&#13;
       */&#13;
      $watch: function(watchExp, listener, objectEquality) {&#13;
        var scope = this,&#13;
            get = compileToFn(watchExp, 'watch'),&#13;
            array = scope.$$watchers,&#13;
            watcher = {&#13;
              fn: listener,&#13;
              last: initWatchVal,&#13;
              get: get,&#13;
              exp: watchExp,&#13;
              eq: !!objectEquality&#13;
            };&#13;
&#13;
        // in the case user pass string, we need to compile it, do we really need this ?&#13;
        if (!isFunction(listener)) {&#13;
          var listenFn = compileToFn(listener || noop, 'listener');&#13;
          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};&#13;
        }&#13;
&#13;
        if (!array) {&#13;
          array = scope.$$watchers = [];&#13;
        }&#13;
        // we use unshift since we use a while loop in $digest for speed.&#13;
        // the while loop reads in reverse order.&#13;
        array.unshift(watcher);&#13;
&#13;
        return function() {&#13;
          arrayRemove(array, watcher);&#13;
        };&#13;
      },&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$digest&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Process all of the {@link angular.module.ng.$rootScope.Scope#$watch watchers} of the current scope and its children.&#13;
       * Because a {@link angular.module.ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the&#13;
       * `$digest()` keeps calling the {@link angular.module.ng.$rootScope.Scope#$watch watchers} until no more listeners are&#13;
       * firing. This means that it is possible to get into an infinite loop. This function will throw&#13;
       * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 100.&#13;
       *&#13;
       * Usually you don't call `$digest()` directly in&#13;
       * {@link angular.module.ng.$compileProvider.directive.ng-controller controllers} or in&#13;
       * {@link angular.module.ng.$compileProvider.directive directives}.&#13;
       * Instead a call to {@link angular.module.ng.$rootScope.Scope#$apply $apply()} (typically from within a&#13;
       * {@link angular.module.ng.$compileProvider.directive directives}) will force a `$digest()`.&#13;
       *&#13;
       * If you want to be notified whenever `$digest()` is called,&#13;
       * you can register a `watchExpression` function  with {@link angular.module.ng.$rootScope.Scope#$watch $watch()}&#13;
       * with no `listener`.&#13;
       *&#13;
       * You may have a need to call `$digest()` from within unit-tests, to simulate the scope&#13;
       * life-cycle.&#13;
       *&#13;
       * # Example&#13;
         &lt;pre&gt;&#13;
           var scope = ...;&#13;
           scope.name = 'misko';&#13;
           scope.counter = 0;&#13;
&#13;
           expect(scope.counter).toEqual(0);&#13;
           scope.$watch('name', function(scope, newValue, oldValue) {&#13;
             counter = counter + 1;&#13;
           });&#13;
           expect(scope.counter).toEqual(0);&#13;
&#13;
           scope.$digest();&#13;
           // no variable change&#13;
           expect(scope.counter).toEqual(0);&#13;
&#13;
           scope.name = 'adam';&#13;
           scope.$digest();&#13;
           expect(scope.counter).toEqual(1);&#13;
         &lt;/pre&gt;&#13;
       *&#13;
       */&#13;
      $digest: function() {&#13;
        var watch, value, last,&#13;
            watchers,&#13;
            asyncQueue,&#13;
            length,&#13;
            dirty, ttl = TTL,&#13;
            next, current, target = this,&#13;
            watchLog = [],&#13;
            logIdx, logMsg;&#13;
&#13;
        flagPhase(target, '$digest');&#13;
&#13;
        do {&#13;
          dirty = false;&#13;
          current = target;&#13;
          do {&#13;
            asyncQueue = current.$$asyncQueue;&#13;
            while(asyncQueue.length) {&#13;
              try {&#13;
                current.$eval(asyncQueue.shift());&#13;
              } catch (e) {&#13;
                $exceptionHandler(e);&#13;
              }&#13;
            }&#13;
            if ((watchers = current.$$watchers)) {&#13;
              // process our watches&#13;
              length = watchers.length;&#13;
              while (length--) {&#13;
                try {&#13;
                  watch = watchers[length];&#13;
                  // Most common watches are on primitives, in which case we can short&#13;
                  // circuit it with === operator, only when === fails do we use .equals&#13;
                  if ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;&#13;
                      !(watch.eq&#13;
                          ? equals(value, last)&#13;
                          : (typeof value == 'number' &amp;&amp; typeof last == 'number'&#13;
                             &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) {&#13;
                    dirty = true;&#13;
                    watch.last = watch.eq ? copy(value) : value;&#13;
                    watch.fn(value, ((last === initWatchVal) ? value : last), current);&#13;
                    if (ttl &lt; 5) {&#13;
                      logIdx = 4 - ttl;&#13;
                      if (!watchLog[logIdx]) watchLog[logIdx] = [];&#13;
                      logMsg = (isFunction(watch.exp))&#13;
                          ? 'fn: ' + (watch.exp.name || watch.exp.toString())&#13;
                          : watch.exp;&#13;
                      logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);&#13;
                      watchLog[logIdx].push(logMsg);&#13;
                    }&#13;
                  }&#13;
                } catch (e) {&#13;
                  $exceptionHandler(e);&#13;
                }&#13;
              }&#13;
            }&#13;
&#13;
            // Insanity Warning: scope depth-first traversal&#13;
            // yes, this code is a bit crazy, but it works and we have tests to prove it!&#13;
            // this piece should be kept in sync with the traversal in $broadcast&#13;
            if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) {&#13;
              while(current !== target &amp;&amp; !(next = current.$$nextSibling)) {&#13;
                current = current.$parent;&#13;
              }&#13;
            }&#13;
          } while ((current = next));&#13;
&#13;
          if(dirty &amp;&amp; !(ttl--)) {&#13;
            throw Error(TTL + ' $digest() iterations reached. Aborting!\n' +&#13;
                'Watchers fired in the last 5 iterations: ' + toJson(watchLog));&#13;
          }&#13;
        } while (dirty || asyncQueue.length);&#13;
&#13;
        this.$root.$$phase = null;&#13;
      },&#13;
&#13;
&#13;
      /**&#13;
       * @ngdoc event&#13;
       * @name angular.module.$rootScope.Scope#$destroy&#13;
       * @eventOf angular.module.ng.$rootScope.Scope&#13;
       * @eventType broadcast on scope being destroyed&#13;
       *&#13;
       * @description&#13;
       * Broadcasted when a scope and its children are being destroyed.&#13;
       */&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$destroy&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Remove the current scope (and all of its children) from the parent scope. Removal implies&#13;
       * that calls to {@link angular.module.ng.$rootScope.Scope#$digest $digest()} will no longer&#13;
       * propagate to the current scope and its children. Removal also implies that the current&#13;
       * scope is eligible for garbage collection.&#13;
       *&#13;
       * The `$destroy()` is usually used by directives such as&#13;
       * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat} for managing the&#13;
       * unrolling of the loop.&#13;
       *&#13;
       * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.&#13;
       * Application code can register a `$destroy` event handler that will give it chance to&#13;
       * perform any necessary cleanup.&#13;
       */&#13;
      $destroy: function() {&#13;
        if (this.$root == this) return; // we can't remove the root node;&#13;
        var parent = this.$parent;&#13;
&#13;
        this.$broadcast('$destroy');&#13;
&#13;
        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;&#13;
        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;&#13;
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;&#13;
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;&#13;
      },&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$eval&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Executes the `expression` on the current scope returning the result. Any exceptions in the&#13;
       * expression are propagated (uncaught). This is useful when evaluating engular expressions.&#13;
       *&#13;
       * # Example&#13;
         &lt;pre&gt;&#13;
           var scope = angular.module.ng.$rootScope.Scope();&#13;
           scope.a = 1;&#13;
           scope.b = 2;&#13;
&#13;
           expect(scope.$eval('a+b')).toEqual(3);&#13;
           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);&#13;
         &lt;/pre&gt;&#13;
       *&#13;
       * @param {(string|function())=} expression An angular expression to be executed.&#13;
       *&#13;
       *    - `string`: execute using the rules as defined in  {@link guide/dev_guide.expressions expression}.&#13;
       *    - `function(scope, locals)`: execute the function with the current `scope` parameter.&#13;
       * @param {Object=} locals Hash object of local variables for the expression.&#13;
       *&#13;
       * @returns {*} The result of evaluating the expression.&#13;
       */&#13;
      $eval: function(expr, locals) {&#13;
        return $parse(expr)(this, locals);&#13;
      },&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$evalAsync&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Executes the expression on the current scope at a later point in time.&#13;
       *&#13;
       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:&#13;
       *&#13;
       *   - it will execute in the current script execution context (before any DOM rendering).&#13;
       *   - at least one {@link angular.module.ng.$rootScope.Scope#$digest $digest cycle} will be performed after&#13;
       *     `expression` execution.&#13;
       *&#13;
       * Any exceptions from the execution of the expression are forwarded to the&#13;
       * {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.&#13;
       *&#13;
       * @param {(string|function())=} expression An angular expression to be executed.&#13;
       *&#13;
       *    - `string`: execute using the rules as defined in  {@link guide/dev_guide.expressions expression}.&#13;
       *    - `function(scope)`: execute the function with the current `scope` parameter.&#13;
       *&#13;
       */&#13;
      $evalAsync: function(expr) {&#13;
        this.$$asyncQueue.push(expr);&#13;
      },&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$apply&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * `$apply()` is used to execute an expression in angular from outside of the angular framework.&#13;
       * (For example from browser DOM events, setTimeout, XHR or third party libraries).&#13;
       * Because we are calling into the angular framework we need to perform proper scope life-cycle&#13;
       * of {@link angular.module.ng.$exceptionHandler exception handling},&#13;
       * {@link angular.module.ng.$rootScope.Scope#$digest executing watches}.&#13;
       *&#13;
       * ## Life cycle&#13;
       *&#13;
       * # Pseudo-Code of `$apply()`&#13;
          function $apply(expr) {&#13;
            try {&#13;
              return $eval(expr);&#13;
            } catch (e) {&#13;
              $exceptionHandler(e);&#13;
            } finally {&#13;
              $root.$digest();&#13;
            }&#13;
          }&#13;
       *&#13;
       *&#13;
       * Scope's `$apply()` method transitions through the following stages:&#13;
       *&#13;
       * 1. The {@link guide/dev_guide.expressions expression} is executed using the&#13;
       *    {@link angular.module.ng.$rootScope.Scope#$eval $eval()} method.&#13;
       * 2. Any exceptions from the execution of the expression are forwarded to the&#13;
       *    {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.&#13;
       * 3. The {@link angular.module.ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression&#13;
       *    was executed using the {@link angular.module.ng.$rootScope.Scope#$digest $digest()} method.&#13;
       *&#13;
       *&#13;
       * @param {(string|function())=} exp An angular expression to be executed.&#13;
       *&#13;
       *    - `string`: execute using the rules as defined in {@link guide/dev_guide.expressions expression}.&#13;
       *    - `function(scope)`: execute the function with current `scope` parameter.&#13;
       *&#13;
       * @returns {*} The result of evaluating the expression.&#13;
       */&#13;
      $apply: function(expr) {&#13;
        try {&#13;
          flagPhase(this, '$apply');&#13;
          return this.$eval(expr);&#13;
        } catch (e) {&#13;
          $exceptionHandler(e);&#13;
        } finally {&#13;
          this.$root.$$phase = null;&#13;
          this.$root.$digest();&#13;
        }&#13;
      },&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$on&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Listen on events of a given type. See {@link angular.module.ng.$rootScope.Scope#$emit $emit} for discussion of&#13;
       * event life cycle.&#13;
       *&#13;
       * @param {string} name Event name to listen on.&#13;
       * @param {function(event)} listener Function to call when the event is emitted.&#13;
       * @returns {function()} Returns a deregistration function for this listener.&#13;
       *&#13;
       * The event listener function format is: `function(event)`. The `event` object passed into the&#13;
       * listener has the following attributes&#13;
       *&#13;
       *   - `targetScope` - {Scope}: the scope on which the event was `$emit`-ed or `$broadcast`-ed.&#13;
       *   - `currentScope` - {Scope}: the current scope which is handling the event.&#13;
       *   - `name` - {string}: Name of the event.&#13;
       *   - `cancel` - {function=}: calling `cancel` function will cancel further event propagation&#13;
       *     (available only for events that were `$emit`-ed).&#13;
       *   - `cancelled` - {boolean}: Whether the event was cancelled.&#13;
       */&#13;
      $on: function(name, listener) {&#13;
        var namedListeners = this.$$listeners[name];&#13;
        if (!namedListeners) {&#13;
          this.$$listeners[name] = namedListeners = [];&#13;
        }&#13;
        namedListeners.push(listener);&#13;
&#13;
        return function() {&#13;
          arrayRemove(namedListeners, listener);&#13;
        };&#13;
      },&#13;
&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$emit&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Dispatches an event `name` upwards through the scope hierarchy notifying the&#13;
       * registered {@link angular.module.ng.$rootScope.Scope#$on} listeners.&#13;
       *&#13;
       * The event life cycle starts at the scope on which `$emit` was called. All&#13;
       * {@link angular.module.ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.&#13;
       * Afterwards, the event traverses upwards toward the root scope and calls all registered&#13;
       * listeners along the way. The event will stop propagating if one of the listeners cancels it.&#13;
       *&#13;
       * Any exception emmited from the {@link angular.module.ng.$rootScope.Scope#$on listeners} will be passed&#13;
       * onto the {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.&#13;
       *&#13;
       * @param {string} name Event name to emit.&#13;
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.&#13;
       * @return {Object} Event object, see {@link angular.module.ng.$rootScope.Scope#$on}&#13;
       */&#13;
      $emit: function(name, args) {&#13;
        var empty = [],&#13;
            namedListeners,&#13;
            scope = this,&#13;
            event = {&#13;
              name: name,&#13;
              targetScope: scope,&#13;
              cancel: function() {event.cancelled = true;},&#13;
              cancelled: false&#13;
            },&#13;
            listenerArgs = concat([event], arguments, 1),&#13;
            i, length;&#13;
&#13;
        do {&#13;
          namedListeners = scope.$$listeners[name] || empty;&#13;
          event.currentScope = scope;&#13;
          for (i=0, length=namedListeners.length; i&lt;length; i++) {&#13;
            try {&#13;
              namedListeners[i].apply(null, listenerArgs);&#13;
              if (event.cancelled) return event;&#13;
            } catch (e) {&#13;
              $exceptionHandler(e);&#13;
            }&#13;
          }&#13;
          //traverse upwards&#13;
          scope = scope.$parent;&#13;
        } while (scope);&#13;
&#13;
        return event;&#13;
      },&#13;
&#13;
&#13;
      /**&#13;
       * @ngdoc function&#13;
       * @name angular.module.ng.$rootScope.Scope#$broadcast&#13;
       * @methodOf angular.module.ng.$rootScope.Scope&#13;
       * @function&#13;
       *&#13;
       * @description&#13;
       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the&#13;
       * registered {@link angular.module.ng.$rootScope.Scope#$on} listeners.&#13;
       *&#13;
       * The event life cycle starts at the scope on which `$broadcast` was called. All&#13;
       * {@link angular.module.ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.&#13;
       * Afterwards, the event propagates to all direct and indirect scopes of the current scope and&#13;
       * calls all registered listeners along the way. The event cannot be canceled.&#13;
       *&#13;
       * Any exception emmited from the {@link angular.module.ng.$rootScope.Scope#$on listeners} will be passed&#13;
       * onto the {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.&#13;
       *&#13;
       * @param {string} name Event name to emit.&#13;
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.&#13;
       * @return {Object} Event object, see {@link angular.module.ng.$rootScope.Scope#$on}&#13;
       */&#13;
      $broadcast: function(name, args) {&#13;
        var target = this,&#13;
            current = target,&#13;
            next = target,&#13;
            event = { name: name,&#13;
                      targetScope: target },&#13;
            listenerArgs = concat([event], arguments, 1);&#13;
&#13;
        //down while you can, then up and next sibling or up and next sibling until back at root&#13;
        do {&#13;
          current = next;&#13;
          event.currentScope = current;&#13;
          forEach(current.$$listeners[name], function(listener) {&#13;
            try {&#13;
              listener.apply(null, listenerArgs);&#13;
            } catch(e) {&#13;
              $exceptionHandler(e);&#13;
            }&#13;
          });&#13;
&#13;
          // Insanity Warning: scope depth-first traversal&#13;
          // yes, this code is a bit crazy, but it works and we have tests to prove it!&#13;
          // this piece should be kept in sync with the traversal in $digest&#13;
          if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) {&#13;
            while(current !== target &amp;&amp; !(next = current.$$nextSibling)) {&#13;
              current = current.$parent;&#13;
            }&#13;
          }&#13;
        } while ((current = next));&#13;
&#13;
        return event;&#13;
      }&#13;
    };&#13;
&#13;
&#13;
    function flagPhase(scope, phase) {&#13;
      var root = scope.$root;&#13;
&#13;
      if (root.$$phase) {&#13;
        throw Error(root.$$phase + ' already in progress');&#13;
      }&#13;
&#13;
      root.$$phase = phase;&#13;
    }&#13;
&#13;
    return new Scope();&#13;
&#13;
    function compileToFn(exp, name) {&#13;
      var fn = $parse(exp);&#13;
      assertArgFn(fn, name);&#13;
      return fn;&#13;
    }&#13;
&#13;
    /**&#13;
     * function used as an initial value for watchers.&#13;
     * because it's uniqueue we can easily tell it apart from other values&#13;
     */&#13;
    function initWatchVal() {}&#13;
  }];&#13;
}&#13;
&#13;
/*&#13;
 * HTML Parser By Misko Hevery (misko@hevery.com)&#13;
 * based on:  HTML Parser By John Resig (ejohn.org)&#13;
 * Original code by Erik Arvidsson, Mozilla Public License&#13;
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js&#13;
 *&#13;
 * // Use like so:&#13;
 * htmlParser(htmlString, {&#13;
 *     start: function(tag, attrs, unary) {},&#13;
 *     end: function(tag) {},&#13;
 *     chars: function(text) {},&#13;
 *     comment: function(text) {}&#13;
 * });&#13;
 *&#13;
 */&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc service&#13;
 * @name angular.module.ng.$sanitize&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 *   The input is sanitized by parsing the html into tokens. All safe tokens (from a whitelist) are&#13;
 *   then serialized back to properly escaped html string. This means that no unsafe input can make&#13;
 *   it into the returned string, however, since our parser is more strict than a typical browser&#13;
 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a&#13;
 *   browser, won't make it through the sanitizer.&#13;
 *&#13;
 * @param {string} html Html input.&#13;
 * @returns {string} Sanitized html.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.snippet =&#13;
             '&lt;p style="color:blue"&gt;an html\n' +&#13;
             '&lt;em onmouseover="this.textContent=\'PWN3D!\'"&gt;click here&lt;/em&gt;\n' +&#13;
             'snippet&lt;/p&gt;';&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
          Snippet: &lt;textarea ng-model="snippet" cols="60" rows="3"&gt;&lt;/textarea&gt;&#13;
           &lt;table&gt;&#13;
             &lt;tr&gt;&#13;
               &lt;td&gt;Filter&lt;/td&gt;&#13;
               &lt;td&gt;Source&lt;/td&gt;&#13;
               &lt;td&gt;Rendered&lt;/td&gt;&#13;
             &lt;/tr&gt;&#13;
             &lt;tr id="html-filter"&gt;&#13;
               &lt;td&gt;html filter&lt;/td&gt;&#13;
               &lt;td&gt;&#13;
                 &lt;pre&gt;&amp;lt;div ng-bind-html="snippet"&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&#13;
               &lt;/td&gt;&#13;
               &lt;td&gt;&#13;
                 &lt;div ng-bind-html="snippet"&gt;&lt;/div&gt;&#13;
               &lt;/td&gt;&#13;
             &lt;/tr&gt;&#13;
             &lt;tr id="escaped-html"&gt;&#13;
               &lt;td&gt;no filter&lt;/td&gt;&#13;
               &lt;td&gt;&lt;pre&gt;&amp;lt;div ng-bind="snippet"&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;/td&gt;&#13;
               &lt;td&gt;&lt;div ng-bind="snippet"&gt;&lt;/div&gt;&lt;/td&gt;&#13;
             &lt;/tr&gt;&#13;
             &lt;tr id="html-unsafe-filter"&gt;&#13;
               &lt;td&gt;unsafe html filter&lt;/td&gt;&#13;
               &lt;td&gt;&lt;pre&gt;&amp;lt;div ng-bind-html-unsafe="snippet"&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;/td&gt;&#13;
               &lt;td&gt;&lt;div ng-bind-html-unsafe="snippet"&gt;&lt;/div&gt;&lt;/td&gt;&#13;
             &lt;/tr&gt;&#13;
           &lt;/table&gt;&#13;
         &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should sanitize the html snippet ', function() {&#13;
         expect(using('#html-filter').element('div').html()).&#13;
           toBe('&lt;p&gt;an html\n&lt;em&gt;click here&lt;/em&gt;\nsnippet&lt;/p&gt;');&#13;
       });&#13;
&#13;
       it('should escape snippet without any filter', function() {&#13;
         expect(using('#escaped-html').element('div').html()).&#13;
           toBe("&amp;lt;p style=\"color:blue\"&amp;gt;an html\n" +&#13;
                "&amp;lt;em onmouseover=\"this.textContent='PWN3D!'\"&amp;gt;click here&amp;lt;/em&amp;gt;\n" +&#13;
                "snippet&amp;lt;/p&amp;gt;");&#13;
       });&#13;
&#13;
       it('should inline raw snippet if filtered as unsafe', function() {&#13;
         expect(using('#html-unsafe-filter').element("div").html()).&#13;
           toBe("&lt;p style=\"color:blue\"&gt;an html\n" +&#13;
                "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +&#13;
                "snippet&lt;/p&gt;");&#13;
       });&#13;
&#13;
       it('should update', function() {&#13;
         input('snippet').enter('new &lt;b&gt;text&lt;/b&gt;');&#13;
         expect(using('#html-filter').binding('snippet')).toBe('new &lt;b&gt;text&lt;/b&gt;');&#13;
         expect(using('#escaped-html').element('div').html()).toBe("new &amp;lt;b&amp;gt;text&amp;lt;/b&amp;gt;");&#13;
         expect(using('#html-unsafe-filter').binding("snippet")).toBe('new &lt;b&gt;text&lt;/b&gt;');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
&#13;
function $SanitizeProvider() {&#13;
  this.$get = valueFn(function(html) {&#13;
    var buf = [];&#13;
    htmlParser(html, htmlSanitizeWriter(buf));&#13;
    return buf.join('');&#13;
  });&#13;
};&#13;
&#13;
// Regular Expressions for parsing tags and attributes&#13;
var START_TAG_REGEXP = /^&lt;\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^&gt;\s]+))?)*)\s*(\/?)\s*&gt;/,&#13;
  END_TAG_REGEXP = /^&lt;\s*\/\s*([\w:-]+)[^&gt;]*&gt;/,&#13;
  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^&gt;\s]+)))?/g,&#13;
  BEGIN_TAG_REGEXP = /^&lt;/,&#13;
  BEGING_END_TAGE_REGEXP = /^&lt;\s*\//,&#13;
  COMMENT_REGEXP = /&lt;!--(.*?)--&gt;/g,&#13;
  CDATA_REGEXP = /&lt;!\[CDATA\[(.*?)]]&gt;/g,&#13;
  URI_REGEXP = /^((ftp|https?):\/\/|mailto:|#)/,&#13;
  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g; // Match everything outside of normal chars and " (quote character)&#13;
&#13;
&#13;
// Good source of info about elements and attributes&#13;
// http://dev.w3.org/html5/spec/Overview.html#semantics&#13;
// http://simon.html5.org/html-elements&#13;
&#13;
// Safe Void Elements - HTML5&#13;
// http://dev.w3.org/html5/spec/Overview.html#void-elements&#13;
var voidElements = makeMap("area,br,col,hr,img,wbr");&#13;
&#13;
// Elements that you can, intentionally, leave open (and which close themselves)&#13;
// http://dev.w3.org/html5/spec/Overview.html#optional-tags&#13;
var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),&#13;
    optionalEndTagInlineElements = makeMap("rp,rt"),&#13;
    optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);&#13;
&#13;
// Safe Block Elements - HTML5&#13;
var blockElements = extend({}, optionalEndTagBlockElements, makeMap("address,article,aside," +&#13;
        "blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6," +&#13;
        "header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));&#13;
&#13;
// Inline Elements - HTML5&#13;
var inlineElements = extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b,bdi,bdo," +&#13;
        "big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small," +&#13;
        "span,strike,strong,sub,sup,time,tt,u,var"));&#13;
&#13;
&#13;
// Special Elements (can contain anything)&#13;
var specialElements = makeMap("script,style");&#13;
&#13;
var validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);&#13;
&#13;
//Attributes that have href and hence need to be sanitized&#13;
var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap");&#13;
var validAttrs = extend({}, uriAttrs, makeMap(&#13;
    'abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,'+&#13;
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,'+&#13;
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,'+&#13;
    'scope,scrolling,shape,span,start,summary,target,title,type,'+&#13;
    'valign,value,vspace,width'));&#13;
&#13;
/**&#13;
 * @example&#13;
 * htmlParser(htmlString, {&#13;
 *     start: function(tag, attrs, unary) {},&#13;
 *     end: function(tag) {},&#13;
 *     chars: function(text) {},&#13;
 *     comment: function(text) {}&#13;
 * });&#13;
 *&#13;
 * @param {string} html string&#13;
 * @param {object} handler&#13;
 */&#13;
function htmlParser( html, handler ) {&#13;
  var index, chars, match, stack = [], last = html;&#13;
  stack.last = function() { return stack[ stack.length - 1 ]; };&#13;
&#13;
  while ( html ) {&#13;
    chars = true;&#13;
&#13;
    // Make sure we're not in a script or style element&#13;
    if ( !stack.last() || !specialElements[ stack.last() ] ) {&#13;
&#13;
      // Comment&#13;
      if ( html.indexOf("&lt;!--") === 0 ) {&#13;
        index = html.indexOf("--&gt;");&#13;
&#13;
        if ( index &gt;= 0 ) {&#13;
          if (handler.comment) handler.comment( html.substring( 4, index ) );&#13;
          html = html.substring( index + 3 );&#13;
          chars = false;&#13;
        }&#13;
&#13;
      // end tag&#13;
      } else if ( BEGING_END_TAGE_REGEXP.test(html) ) {&#13;
        match = html.match( END_TAG_REGEXP );&#13;
&#13;
        if ( match ) {&#13;
          html = html.substring( match[0].length );&#13;
          match[0].replace( END_TAG_REGEXP, parseEndTag );&#13;
          chars = false;&#13;
        }&#13;
&#13;
      // start tag&#13;
      } else if ( BEGIN_TAG_REGEXP.test(html) ) {&#13;
        match = html.match( START_TAG_REGEXP );&#13;
&#13;
        if ( match ) {&#13;
          html = html.substring( match[0].length );&#13;
          match[0].replace( START_TAG_REGEXP, parseStartTag );&#13;
          chars = false;&#13;
        }&#13;
      }&#13;
&#13;
      if ( chars ) {&#13;
        index = html.indexOf("&lt;");&#13;
&#13;
        var text = index &lt; 0 ? html : html.substring( 0, index );&#13;
        html = index &lt; 0 ? "" : html.substring( index );&#13;
&#13;
        if (handler.chars) handler.chars( decodeEntities(text) );&#13;
      }&#13;
&#13;
    } else {&#13;
      html = html.replace(new RegExp("(.*)&lt;\\s*\\/\\s*" + stack.last() + "[^&gt;]*&gt;", 'i'), function(all, text){&#13;
        text = text.&#13;
          replace(COMMENT_REGEXP, "$1").&#13;
          replace(CDATA_REGEXP, "$1");&#13;
&#13;
        if (handler.chars) handler.chars( decodeEntities(text) );&#13;
&#13;
        return "";&#13;
      });&#13;
&#13;
      parseEndTag( "", stack.last() );&#13;
    }&#13;
&#13;
    if ( html == last ) {&#13;
      throw "Parse Error: " + html;&#13;
    }&#13;
    last = html;&#13;
  }&#13;
&#13;
  // Clean up any remaining tags&#13;
  parseEndTag();&#13;
&#13;
  function parseStartTag( tag, tagName, rest, unary ) {&#13;
    tagName = lowercase(tagName);&#13;
    if ( blockElements[ tagName ] ) {&#13;
      while ( stack.last() &amp;&amp; inlineElements[ stack.last() ] ) {&#13;
        parseEndTag( "", stack.last() );&#13;
      }&#13;
    }&#13;
&#13;
    if ( optionalEndTagElements[ tagName ] &amp;&amp; stack.last() == tagName ) {&#13;
      parseEndTag( "", tagName );&#13;
    }&#13;
&#13;
    unary = voidElements[ tagName ] || !!unary;&#13;
&#13;
    if ( !unary )&#13;
      stack.push( tagName );&#13;
&#13;
    var attrs = {};&#13;
&#13;
    rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQoutedValue, unqoutedValue) {&#13;
      var value = doubleQuotedValue&#13;
        || singleQoutedValue&#13;
        || unqoutedValue&#13;
        || '';&#13;
&#13;
      attrs[name] = decodeEntities(value);&#13;
    });&#13;
    if (handler.start) handler.start( tagName, attrs, unary );&#13;
  }&#13;
&#13;
  function parseEndTag( tag, tagName ) {&#13;
    var pos = 0, i;&#13;
    tagName = lowercase(tagName);&#13;
    if ( tagName )&#13;
      // Find the closest opened tag of the same type&#13;
      for ( pos = stack.length - 1; pos &gt;= 0; pos-- )&#13;
        if ( stack[ pos ] == tagName )&#13;
          break;&#13;
&#13;
    if ( pos &gt;= 0 ) {&#13;
      // Close all the open elements, up the stack&#13;
      for ( i = stack.length - 1; i &gt;= pos; i-- )&#13;
        if (handler.end) handler.end( stack[ i ] );&#13;
&#13;
      // Remove the open elements from the stack&#13;
      stack.length = pos;&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * decodes all entities into regular string&#13;
 * @param value&#13;
 * @returns {string} A string with decoded entities.&#13;
 */&#13;
var hiddenPre=document.createElement("pre");&#13;
function decodeEntities(value) {&#13;
  hiddenPre.innerHTML=value.replace(/&lt;/g,"&amp;lt;");&#13;
  return hiddenPre.innerText || hiddenPre.textContent || '';&#13;
}&#13;
&#13;
/**&#13;
 * Escapes all potentially dangerous characters, so that the&#13;
 * resulting string can be safely inserted into attribute or&#13;
 * element text.&#13;
 * @param value&#13;
 * @returns escaped text&#13;
 */&#13;
function encodeEntities(value) {&#13;
  return value.&#13;
    replace(/&amp;/g, '&amp;amp;').&#13;
    replace(NON_ALPHANUMERIC_REGEXP, function(value){&#13;
      return '&amp;#' + value.charCodeAt(0) + ';';&#13;
    }).&#13;
    replace(/&lt;/g, '&amp;lt;').&#13;
    replace(/&gt;/g, '&amp;gt;');&#13;
}&#13;
&#13;
/**&#13;
 * create an HTML/XML writer which writes to buffer&#13;
 * @param {Array} buf use buf.jain('') to get out sanitized html string&#13;
 * @returns {object} in the form of {&#13;
 *     start: function(tag, attrs, unary) {},&#13;
 *     end: function(tag) {},&#13;
 *     chars: function(text) {},&#13;
 *     comment: function(text) {}&#13;
 * }&#13;
 */&#13;
function htmlSanitizeWriter(buf){&#13;
  var ignore = false;&#13;
  var out = bind(buf, buf.push);&#13;
  return {&#13;
    start: function(tag, attrs, unary){&#13;
      tag = lowercase(tag);&#13;
      if (!ignore &amp;&amp; specialElements[tag]) {&#13;
        ignore = tag;&#13;
      }&#13;
      if (!ignore &amp;&amp; validElements[tag] == true) {&#13;
        out('&lt;');&#13;
        out(tag);&#13;
        forEach(attrs, function(value, key){&#13;
          var lkey=lowercase(key);&#13;
          if (validAttrs[lkey]==true &amp;&amp; (uriAttrs[lkey]!==true || value.match(URI_REGEXP))) {&#13;
            out(' ');&#13;
            out(key);&#13;
            out('="');&#13;
            out(encodeEntities(value));&#13;
            out('"');&#13;
          }&#13;
        });&#13;
        out(unary ? '/&gt;' : '&gt;');&#13;
      }&#13;
    },&#13;
    end: function(tag){&#13;
        tag = lowercase(tag);&#13;
        if (!ignore &amp;&amp; validElements[tag] == true) {&#13;
          out('&lt;/');&#13;
          out(tag);&#13;
          out('&gt;');&#13;
        }&#13;
        if (tag == ignore) {&#13;
          ignore = false;&#13;
        }&#13;
      },&#13;
    chars: function(chars){&#13;
        if (!ignore) {&#13;
          out(encodeEntities(chars));&#13;
        }&#13;
      }&#13;
  };&#13;
}&#13;
&#13;
/**&#13;
 * !!! This is an undocumented "private" service !!!&#13;
 *&#13;
 * @name angular.module.ng.$sniffer&#13;
 * @requires $window&#13;
 *&#13;
 * @property {boolean} history Does the browser support html5 history api ?&#13;
 * @property {boolean} hashchange Does the browser support hashchange event ?&#13;
 *&#13;
 * @description&#13;
 * This is very simple implementation of testing browser's features.&#13;
 */&#13;
function $SnifferProvider() {&#13;
  this.$get = ['$window', function($window) {&#13;
    var eventSupport = {};&#13;
&#13;
    return {&#13;
      history: !!($window.history &amp;&amp; $window.history.pushState),&#13;
      hashchange: 'onhashchange' in $window &amp;&amp;&#13;
                  // IE8 compatible mode lies&#13;
                  (!$window.document.documentMode || $window.document.documentMode &gt; 7),&#13;
      hasEvent: function(event) {&#13;
        if (isUndefined(eventSupport[event])) {&#13;
          var divElm = $window.document.createElement('div');&#13;
          eventSupport[event] = 'on' + event in divElm;&#13;
        }&#13;
&#13;
        return eventSupport[event];&#13;
      }&#13;
    };&#13;
  }];&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$window&#13;
 *&#13;
 * @description&#13;
 * A reference to the browser's `window` object. While `window`&#13;
 * is globally available in JavaScript, it causes testability problems, because&#13;
 * it is a global variable. In angular we always refer to it through the&#13;
 * `$window` service, so it may be overriden, removed or mocked for testing.&#13;
 *&#13;
 * All expressions are evaluated with respect to current scope so they don't&#13;
 * suffer from window globality.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;input ng-init="$window = $service('$window'); greeting='Hello World!'" type="text" ng-model="greeting" /&gt;&#13;
       &lt;button ng-click="$window.alert(greeting)"&gt;ALERT&lt;/button&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
function $WindowProvider(){&#13;
  this.$get = valueFn(window);&#13;
}&#13;
&#13;
/**&#13;
 * Parse headers into key value object&#13;
 *&#13;
 * @param {string} headers Raw headers as a string&#13;
 * @returns {Object} Parsed headers as key value object&#13;
 */&#13;
function parseHeaders(headers) {&#13;
  var parsed = {}, key, val, i;&#13;
&#13;
  if (!headers) return parsed;&#13;
&#13;
  forEach(headers.split('\n'), function(line) {&#13;
    i = line.indexOf(':');&#13;
    key = lowercase(trim(line.substr(0, i)));&#13;
    val = trim(line.substr(i + 1));&#13;
&#13;
    if (key) {&#13;
      if (parsed[key]) {&#13;
        parsed[key] += ', ' + val;&#13;
      } else {&#13;
        parsed[key] = val;&#13;
      }&#13;
    }&#13;
  });&#13;
&#13;
  return parsed;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Returns a function that provides access to parsed headers.&#13;
 *&#13;
 * Headers are lazy parsed when first requested.&#13;
 * @see parseHeaders&#13;
 *&#13;
 * @param {(string|Object)} headers Headers to provide access to.&#13;
 * @returns {function(string=)} Returns a getter function which if called with:&#13;
 *&#13;
 *   - if called with single an argument returns a single header value or null&#13;
 *   - if called with no arguments returns an object containing all headers.&#13;
 */&#13;
function headersGetter(headers) {&#13;
  var headersObj = isObject(headers) ? headers : undefined;&#13;
&#13;
  return function(name) {&#13;
    if (!headersObj) headersObj =  parseHeaders(headers);&#13;
&#13;
    if (name) {&#13;
      return headersObj[lowercase(name)] || null;&#13;
    }&#13;
&#13;
    return headersObj;&#13;
  };&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Chain all given functions&#13;
 *&#13;
 * This function is used for both request and response transforming&#13;
 *&#13;
 * @param {*} data Data to transform.&#13;
 * @param {function(string=)} headers Http headers getter fn.&#13;
 * @param {(function|Array.&lt;function&gt;)} fns Function or an array of functions.&#13;
 * @returns {*} Transformed data.&#13;
 */&#13;
function transformData(data, headers, fns) {&#13;
  if (isFunction(fns))&#13;
    return fns(data, headers);&#13;
&#13;
  forEach(fns, function(fn) {&#13;
    data = fn(data, headers);&#13;
  });&#13;
&#13;
  return data;&#13;
}&#13;
&#13;
&#13;
function isSuccess(status) {&#13;
  return 200 &lt;= status &amp;&amp; status &lt; 300;&#13;
}&#13;
&#13;
&#13;
function $HttpProvider() {&#13;
  var JSON_START = /^\s*(\[|\{[^\{])/,&#13;
      JSON_END = /[\}\]]\s*$/,&#13;
      PROTECTION_PREFIX = /^\)\]\}',?\n/;&#13;
&#13;
  var $config = this.defaults = {&#13;
    // transform incoming response data&#13;
    transformResponse: [function(data) {&#13;
      if (isString(data)) {&#13;
        // strip json vulnerability protection prefix&#13;
        data = data.replace(PROTECTION_PREFIX, '');&#13;
        if (JSON_START.test(data) &amp;&amp; JSON_END.test(data))&#13;
          data = fromJson(data, true);&#13;
      }&#13;
      return data;&#13;
    }],&#13;
&#13;
    // transform outgoing request data&#13;
    transformRequest: [function(d) {&#13;
      return isObject(d) &amp;&amp; !isFile(d) ? toJson(d) : d;&#13;
    }],&#13;
&#13;
    // default headers&#13;
    headers: {&#13;
      common: {&#13;
        'Accept': 'application/json, text/plain, */*',&#13;
        'X-Requested-With': 'XMLHttpRequest'&#13;
      },&#13;
      post: {'Content-Type': 'application/json'},&#13;
      put:  {'Content-Type': 'application/json'}&#13;
    }&#13;
  };&#13;
&#13;
  var providerResponseInterceptors = this.responseInterceptors = [];&#13;
&#13;
  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',&#13;
      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {&#13;
&#13;
    var defaultCache = $cacheFactory('$http'),&#13;
        responseInterceptors = [];&#13;
&#13;
    forEach(providerResponseInterceptors, function(interceptor) {&#13;
      responseInterceptors.push(&#13;
          isString(interceptor)&#13;
              ? $injector.get(interceptor)&#13;
              : $injector.invoke(interceptor)&#13;
      );&#13;
    });&#13;
&#13;
&#13;
    /**&#13;
     * @ngdoc function&#13;
     * @name angular.module.ng.$http&#13;
     * @requires $httpBacked&#13;
     * @requires $browser&#13;
     * @requires $cacheFactory&#13;
     * @requires $rootScope&#13;
     * @requires $q&#13;
     * @requires $injector&#13;
     *&#13;
     * @description&#13;
     * The `$http` service is a core Angular service that facilitates communication with the remote&#13;
     * HTTP servers via browser's {@link https://developer.mozilla.org/en/xmlhttprequest&#13;
     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.&#13;
     *&#13;
     * For unit testing applications that use `$http` service, see&#13;
     * {@link angular.module.ngMock.$httpBackend $httpBackend mock}.&#13;
     *&#13;
     * For a higher level of abstraction, please check out the {@link angular.module.ngResource.$resource&#13;
     * $resource} service.&#13;
     *&#13;
     * The $http API is based on the {@link angular.module.ng.$q deferred/promise APIs} exposed by&#13;
     * the $q service. While for simple usage patters this doesn't matter much, for advanced usage,&#13;
     * it is important to familiarize yourself with these apis and guarantees they provide.&#13;
     *&#13;
     *&#13;
     * # General usage&#13;
     * The `$http` service is a function which takes a single argument â€" a configuration object â€"&#13;
     * that is used to generate an http request and returns  a {@link angular.module.ng.$q promise}&#13;
     * with two $http specific methods: `success` and `error`.&#13;
     *&#13;
     * &lt;pre&gt;&#13;
     *   $http({method: 'GET', url: '/someUrl'}).&#13;
     *     success(function(data, status, headers, config) {&#13;
     *       // this callback will be called asynchronously&#13;
     *       // when the response is available&#13;
     *     }).&#13;
     *     error(function(data, status, headers, config) {&#13;
     *       // called asynchronously if an error occurs&#13;
     *       // or server returns response with status&#13;
     *       // code outside of the &lt;200, 400) range&#13;
     *     });&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * Since the returned value of calling the $http function is a Promise object, you can also use&#13;
     * the `then` method to register callbacks, and these callbacks will receive a single argument â€"&#13;
     * an object representing the response. See the api signature and type info below for more&#13;
     * details.&#13;
     *&#13;
     *&#13;
     * # Shortcut methods&#13;
     *&#13;
     * Since all invocation of the $http service require definition of the http method and url and&#13;
     * POST and PUT requests require response body/data to be provided as well, shortcut methods&#13;
     * were created to simplify using the api:&#13;
     *&#13;
     * &lt;pre&gt;&#13;
     *   $http.get('/someUrl').success(successCallback);&#13;
     *   $http.post('/someUrl', data).success(successCallback);&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * Complete list of shortcut methods:&#13;
     *&#13;
     * - {@link angular.module.ng.$http#get $http.get}&#13;
     * - {@link angular.module.ng.$http#head $http.head}&#13;
     * - {@link angular.module.ng.$http#post $http.post}&#13;
     * - {@link angular.module.ng.$http#put $http.put}&#13;
     * - {@link angular.module.ng.$http#delete $http.delete}&#13;
     * - {@link angular.module.ng.$http#jsonp $http.jsonp}&#13;
     *&#13;
     *&#13;
     * # Setting HTTP Headers&#13;
     *&#13;
     * The $http service will automatically add certain http headers to all requests. These defaults&#13;
     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration&#13;
     * object, which currently contains this default configuration:&#13;
     *&#13;
     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):&#13;
     *   - `Accept: application/json, text/plain, * / *`&#13;
     *   - `X-Requested-With: XMLHttpRequest`&#13;
     * - `$httpProvider.defaults.headers.post`: (header defaults for HTTP POST requests)&#13;
     *   - `Content-Type: application/json`&#13;
     * - `$httpProvider.defaults.headers.put` (header defaults for HTTP PUT requests)&#13;
     *   - `Content-Type: application/json`&#13;
     *&#13;
     * To add or overwrite these defaults, simply add or remove a property from this configuration&#13;
     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object&#13;
     * with name equal to the lower-cased http method name, e.g.&#13;
     * `$httpProvider.defaults.headers.get['My-Header']='value'`.&#13;
     *&#13;
     *&#13;
     * # Transforming Requests and Responses&#13;
     *&#13;
     * Both requests and responses can be transformed using transform functions. By default, Angular&#13;
     * applies these transformations:&#13;
     *&#13;
     * Request transformations:&#13;
     *&#13;
     * - if the `data` property of the request config object contains an object, serialize it into&#13;
     *   JSON format.&#13;
     *&#13;
     * Response transformations:&#13;
     *&#13;
     *  - if XSRF prefix is detected, strip it (see Security Considerations section below)&#13;
     *  - if json response is detected, deserialize it using a JSON parser&#13;
     *&#13;
     * To override these transformation locally, specify transform functions as `transformRequest`&#13;
     * and/or `transformResponse` properties of the config object. To globally override the default&#13;
     * transforms, override the `$httpProvider.defaults.transformRequest` and&#13;
     * `$httpProvider.defaults.transformResponse` properties of the `$httpProvider`.&#13;
     *&#13;
     *&#13;
     * # Caching&#13;
     *&#13;
     * To enable caching set the configuration property `cache` to `true`. When the cache is&#13;
     * enabled, `$http` stores the response from the server in local cache. Next time the&#13;
     * response is served from the cache without sending a request to the server.&#13;
     *&#13;
     * Note that even if the response is served from cache, delivery of the data is asynchronous in&#13;
     * the same way that real requests are.&#13;
     *&#13;
     * If there are multiple GET requests for the same url that should be cached using the same&#13;
     * cache, but the cache is not populated yet, only one request to the server will be made and&#13;
     * the remaining requests will be fulfilled using the response for the first request.&#13;
     *&#13;
     *&#13;
     * # Response interceptors&#13;
     *&#13;
     * Before you start creating interceptors, be sure to understand the&#13;
     * {@link angular.module.ng.$q $q and deferred/promise APIs}.&#13;
     *&#13;
     * For purposes of global error handling, authentication or any kind of synchronous or&#13;
     * asynchronous preprocessing of received responses, it is desirable to be able to intercept&#13;
     * responses for http requests before they are handed over to the application code that&#13;
     * initiated these requests. The response interceptors leverage the {@link angular.module.ng.$q&#13;
     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.&#13;
     *&#13;
     * The interceptors are service factories that are registered with the $httpProvider by&#13;
     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and&#13;
     * injected with dependencies (if specified) and returns the interceptor  â€" a function that&#13;
     * takes a {@link angular.module.ng.$q promise} and returns the original or a new promise.&#13;
     *&#13;
     * &lt;pre&gt;&#13;
     *   // register the interceptor as a service&#13;
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {&#13;
     *     return function(promise) {&#13;
     *       return promise.then(function(response) {&#13;
     *         // do something on success&#13;
     *       }, function(response) {&#13;
     *         // do something on error&#13;
     *         if (canRecover(response)) {&#13;
     *           return responseOrNewPromise&#13;
     *         }&#13;
     *         return $q.reject(response);&#13;
     *       });&#13;
     *     }&#13;
     *   });&#13;
     *&#13;
     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');&#13;
     *&#13;
     *&#13;
     *   // register the interceptor via an anonymous factory&#13;
     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {&#13;
     *     return function(promise) {&#13;
     *       // same as above&#13;
     *     }&#13;
     *   });&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     *&#13;
     * # Security Considerations&#13;
     *&#13;
     * When designing web applications, consider security threats from:&#13;
     *&#13;
     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx&#13;
     *   JSON Vulnerability}&#13;
     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}&#13;
     *&#13;
     * Both server and the client must cooperate in order to eliminate these threats. Angular comes&#13;
     * pre-configured with strategies that address these issues, but for this to work backend server&#13;
     * cooperation is required.&#13;
     *&#13;
     * ## JSON Vulnerability Protection&#13;
     *&#13;
     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx&#13;
     * JSON Vulnerability} allows third party web-site to turn your JSON resource URL into&#13;
     * {@link http://en.wikipedia.org/wiki/JSON#JSONP JSONP} request under some conditions. To&#13;
     * counter this your server can prefix all JSON requests with following string `")]}',\n"`.&#13;
     * Angular will automatically strip the prefix before processing it as JSON.&#13;
     *&#13;
     * For example if your server needs to return:&#13;
     * &lt;pre&gt;&#13;
     * ['one','two']&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * which is vulnerable to attack, your server can return:&#13;
     * &lt;pre&gt;&#13;
     * )]}',&#13;
     * ['one','two']&#13;
     * &lt;/pre&gt;&#13;
     *&#13;
     * Angular will strip the prefix, before processing the JSON.&#13;
     *&#13;
     *&#13;
     * ## Cross Site Request Forgery (XSRF) Protection&#13;
     *&#13;
     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which&#13;
     * an unauthorized site can gain your user's private data. Angular provides following mechanism&#13;
     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie&#13;
     * called `XSRF-TOKEN` and sets it as the HTTP header `X-XSRF-TOKEN`. Since only JavaScript that&#13;
     * runs on your domain could read the cookie, your server can be assured that the XHR came from&#13;
     * JavaScript running on your domain.&#13;
     *&#13;
     * To take advantage of this, your server needs to set a token in a JavaScript readable session&#13;
     * cookie called `XSRF-TOKEN` on first HTTP GET request. On subsequent non-GET requests the&#13;
     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure&#13;
     * that only JavaScript running on your domain could have read the token. The token must be&#13;
     * unique for each user and must be verifiable by the server (to prevent the JavaScript making&#13;
     * up its own tokens). We recommend that the token is a digest of your site's authentication&#13;
     * cookie with {@link http://en.wikipedia.org/wiki/Rainbow_table salt for added security}.&#13;
     *&#13;
     *&#13;
     * @param {object} config Object describing the request to be made and how it should be&#13;
     *    processed. The object has following properties:&#13;
     *&#13;
     *    - **method** â€" `{string}` â€" HTTP method (e.g. 'GET', 'POST', etc)&#13;
     *    - **url** â€" `{string}` â€" Absolute or relative URL of the resource that is being requested.&#13;
     *    - **params** â€" `{Object.&lt;string|Object&gt;}` â€" Map of strings or objects which will be turned to&#13;
     *      `?key1=value1&amp;key2=value2` after the url. If the value is not a string, it will be JSONified.&#13;
     *    - **data** â€" `{string|Object}` â€" Data to be sent as the request message data.&#13;
     *    - **headers** â€" `{Object}` â€" Map of strings representing HTTP headers to send to the server.&#13;
     *    - **transformRequest** â€" `{function(data, headersGetter)|Array.&lt;function(data, headersGetter)&gt;}` â€"&#13;
     *      transform function or an array of such functions. The transform function takes the http&#13;
     *      request body and headers and returns its transformed (typically serialized) version.&#13;
     *    - **transformResponse** â€" `{function(data, headersGetter)|Array.&lt;function(data, headersGetter)&gt;}` â€"&#13;
     *      transform function or an array of such functions. The transform function takes the http&#13;
     *      response body and headers and returns its transformed (typically deserialized) version.&#13;
     *    - **cache** â€" `{boolean|Cache}` â€" If true, a default $http cache will be used to cache the&#13;
     *      GET request, otherwise if a cache instance built with&#13;
     *      {@link angular.module.ng.$cacheFactory $cacheFactory}, this cache will be used for&#13;
     *      caching.&#13;
     *    - **timeout** â€" `{number}` â€" timeout in milliseconds.&#13;
     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the&#13;
     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5&#13;
     *      requests with credentials} for more information.&#13;
     *&#13;
     * @returns {HttpPromise} Returns a {@link angular.module.ng.$q promise} object with the&#13;
     *   standard `then` method and two http specific methods: `success` and `error`. The `then`&#13;
     *   method takes two arguments a success and an error callback which will be called with a&#13;
     *   response object. The `success` and `error` methods take a single argument - a function that&#13;
     *   will be called when the request succeeds or fails respectively. The arguments passed into&#13;
     *   these functions are destructured representation of the response object passed into the&#13;
     *   `then` method. The response object has these properties:&#13;
     *&#13;
     *   - **data** â€" `{string|Object}` â€" The response body transformed with the transform functions.&#13;
     *   - **status** â€" `{number}` â€" HTTP status code of the response.&#13;
     *   - **headers** â€" `{function([headerName])}` â€" Header getter function.&#13;
     *   - **config** â€" `{Object}` â€" The configuration object that was used to generate the request.&#13;
     *&#13;
     * @property {Array.&lt;Object&gt;} pendingRequests Array of config objects for currently pending&#13;
     *   requests. This is primarily meant to be used for debugging purposes.&#13;
     *&#13;
     *&#13;
     * @example&#13;
        &lt;doc:example&gt;&#13;
          &lt;doc:source jsfiddle="false"&gt;&#13;
            &lt;script&gt;&#13;
              function FetchCtrl($scope, $http) {&#13;
                $scope.method = 'GET';&#13;
                $scope.url = 'examples/http-hello.html';&#13;
&#13;
                $scope.fetch = function() {&#13;
                  $scope.code = null;&#13;
                  $scope.response = null;&#13;
&#13;
                  $http({method: $scope.method, url: $scope.url}).&#13;
                    success(function(data, status) {&#13;
                      $scope.status = status;&#13;
                      $scope.data = data;&#13;
                    }).&#13;
                    error(function(data, status) {&#13;
                      $scope.data = data || "Request failed";&#13;
                      $scope.status = status;&#13;
                  });&#13;
                };&#13;
&#13;
                $scope.updateModel = function(method, url) {&#13;
                  $scope.method = method;&#13;
                  $scope.url = url;&#13;
                };&#13;
              }&#13;
            &lt;/script&gt;&#13;
            &lt;div ng-controller="FetchCtrl"&gt;&#13;
              &lt;select ng-model="method"&gt;&#13;
                &lt;option&gt;GET&lt;/option&gt;&#13;
                &lt;option&gt;JSONP&lt;/option&gt;&#13;
              &lt;/select&gt;&#13;
              &lt;input type="text" ng-model="url" size="80"/&gt;&#13;
              &lt;button ng-click="fetch()"&gt;fetch&lt;/button&gt;&lt;br&gt;&#13;
              &lt;button ng-click="updateModel('GET', 'examples/http-hello.html')"&gt;Sample GET&lt;/button&gt;&#13;
              &lt;button ng-click="updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&amp;name=Super%20Hero')"&gt;Sample JSONP&lt;/button&gt;&#13;
              &lt;button ng-click="updateModel('JSONP', 'http://angularjs.org/doesntexist&amp;callback=JSON_CALLBACK')"&gt;Invalid JSONP&lt;/button&gt;&#13;
              &lt;pre&gt;http status code: {{status}}&lt;/pre&gt;&#13;
              &lt;pre&gt;http response data: {{data}}&lt;/pre&gt;&#13;
            &lt;/div&gt;&#13;
          &lt;/doc:source&gt;&#13;
          &lt;doc:scenario&gt;&#13;
            it('should make an xhr GET request', function() {&#13;
              element(':button:contains("Sample GET")').click();&#13;
              element(':button:contains("fetch")').click();&#13;
              expect(binding('status')).toBe('200');&#13;
              expect(binding('data')).toBe('Hello, $http!\n');&#13;
            });&#13;
&#13;
            it('should make a JSONP request to angularjs.org', function() {&#13;
              element(':button:contains("Sample JSONP")').click();&#13;
              element(':button:contains("fetch")').click();&#13;
              expect(binding('status')).toBe('200');&#13;
              expect(binding('data')).toMatch(/Super Hero!/);&#13;
            });&#13;
&#13;
            it('should make JSONP request to invalid URL and invoke the error handler',&#13;
                function() {&#13;
              element(':button:contains("Invalid JSONP")').click();&#13;
              element(':button:contains("fetch")').click();&#13;
              expect(binding('status')).toBe('0');&#13;
              expect(binding('data')).toBe('Request failed');&#13;
            });&#13;
          &lt;/doc:scenario&gt;&#13;
        &lt;/doc:example&gt;&#13;
     */&#13;
    function $http(config) {&#13;
      config.method = uppercase(config.method);&#13;
&#13;
      var reqTransformFn = config.transformRequest || $config.transformRequest,&#13;
          respTransformFn = config.transformResponse || $config.transformResponse,&#13;
          defHeaders = $config.headers,&#13;
          reqHeaders = extend({'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN']},&#13;
              defHeaders.common, defHeaders[lowercase(config.method)], config.headers),&#13;
          reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn),&#13;
          promise;&#13;
&#13;
      // strip content-type if data is undefined&#13;
      if (isUndefined(config.data)) {&#13;
        delete reqHeaders['Content-Type'];&#13;
      }&#13;
&#13;
      // send request&#13;
      promise = sendReq(config, reqData, reqHeaders);&#13;
&#13;
&#13;
      // transform future response&#13;
      promise = promise.then(transformResponse, transformResponse);&#13;
&#13;
      // apply interceptors&#13;
      forEach(responseInterceptors, function(interceptor) {&#13;
        promise = interceptor(promise);&#13;
      });&#13;
&#13;
      promise.success = function(fn) {&#13;
        promise.then(function(response) {&#13;
          fn(response.data, response.status, response.headers, config);&#13;
        });&#13;
        return promise;&#13;
      };&#13;
&#13;
      promise.error = function(fn) {&#13;
        promise.then(null, function(response) {&#13;
          fn(response.data, response.status, response.headers, config);&#13;
        });&#13;
        return promise;&#13;
      };&#13;
&#13;
      return promise;&#13;
&#13;
      function transformResponse(response) {&#13;
        // make a copy since the response must be cacheable&#13;
        var resp = extend({}, response, {&#13;
          data: transformData(response.data, response.headers, respTransformFn)&#13;
        });&#13;
        return (isSuccess(response.status))&#13;
          ? resp&#13;
          : $q.reject(resp);&#13;
      }&#13;
    }&#13;
&#13;
    $http.pendingRequests = [];&#13;
&#13;
    /**&#13;
     * @ngdoc method&#13;
     * @name angular.module.ng.$http#get&#13;
     * @methodOf angular.module.ng.$http&#13;
     *&#13;
     * @description&#13;
     * Shortcut method to perform `GET` request&#13;
     *&#13;
     * @param {string} url Relative or absolute URL specifying the destination of the request&#13;
     * @param {Object=} config Optional configuration object&#13;
     * @returns {HttpPromise} Future object&#13;
     */&#13;
&#13;
    /**&#13;
     * @ngdoc method&#13;
     * @name angular.module.ng.$http#delete&#13;
     * @methodOf angular.module.ng.$http&#13;
     *&#13;
     * @description&#13;
     * Shortcut method to perform `DELETE` request&#13;
     *&#13;
     * @param {string} url Relative or absolute URL specifying the destination of the request&#13;
     * @param {Object=} config Optional configuration object&#13;
     * @returns {HttpPromise} Future object&#13;
     */&#13;
&#13;
    /**&#13;
     * @ngdoc method&#13;
     * @name angular.module.ng.$http#head&#13;
     * @methodOf angular.module.ng.$http&#13;
     *&#13;
     * @description&#13;
     * Shortcut method to perform `HEAD` request&#13;
     *&#13;
     * @param {string} url Relative or absolute URL specifying the destination of the request&#13;
     * @param {Object=} config Optional configuration object&#13;
     * @returns {XhrFuture} Future object&#13;
     */&#13;
&#13;
    /**&#13;
     * @ngdoc method&#13;
     * @name angular.module.ng.$http#jsonp&#13;
     * @methodOf angular.module.ng.$http&#13;
     *&#13;
     * @description&#13;
     * Shortcut method to perform `JSONP` request&#13;
     *&#13;
     * @param {string} url Relative or absolute URL specifying the destination of the request.&#13;
     *                     Should contain `JSON_CALLBACK` string.&#13;
     * @param {Object=} config Optional configuration object&#13;
     * @returns {XhrFuture} Future object&#13;
     */&#13;
    createShortMethods('get', 'delete', 'head', 'jsonp');&#13;
&#13;
    /**&#13;
     * @ngdoc method&#13;
     * @name angular.module.ng.$http#post&#13;
     * @methodOf angular.module.ng.$http&#13;
     *&#13;
     * @description&#13;
     * Shortcut method to perform `POST` request&#13;
     *&#13;
     * @param {string} url Relative or absolute URL specifying the destination of the request&#13;
     * @param {*} data Request content&#13;
     * @param {Object=} config Optional configuration object&#13;
     * @returns {HttpPromise} Future object&#13;
     */&#13;
&#13;
    /**&#13;
     * @ngdoc method&#13;
     * @name angular.module.ng.$http#put&#13;
     * @methodOf angular.module.ng.$http&#13;
     *&#13;
     * @description&#13;
     * Shortcut method to perform `PUT` request&#13;
     *&#13;
     * @param {string} url Relative or absolute URL specifying the destination of the request&#13;
     * @param {*} data Request content&#13;
     * @param {Object=} config Optional configuration object&#13;
     * @returns {XhrFuture} Future object&#13;
     */&#13;
    createShortMethodsWithData('post', 'put');&#13;
&#13;
&#13;
    return $http;&#13;
&#13;
&#13;
    function createShortMethods(names) {&#13;
      forEach(arguments, function(name) {&#13;
        $http[name] = function(url, config) {&#13;
          return $http(extend(config || {}, {&#13;
            method: name,&#13;
            url: url&#13;
          }));&#13;
        };&#13;
      });&#13;
    }&#13;
&#13;
&#13;
    function createShortMethodsWithData(name) {&#13;
      forEach(arguments, function(name) {&#13;
        $http[name] = function(url, data, config) {&#13;
          return $http(extend(config || {}, {&#13;
            method: name,&#13;
            url: url,&#13;
            data: data&#13;
          }));&#13;
        };&#13;
      });&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * Makes the request&#13;
     *&#13;
     * !!! ACCESSES CLOSURE VARS:&#13;
     * $httpBackend, $config, $log, $rootScope, defaultCache, $http.pendingRequests&#13;
     */&#13;
    function sendReq(config, reqData, reqHeaders) {&#13;
      var deferred = $q.defer(),&#13;
          promise = deferred.promise,&#13;
          cache,&#13;
          cachedResp,&#13;
          url = buildUrl(config.url, config.params);&#13;
&#13;
      $http.pendingRequests.push(config);&#13;
      promise.then(removePendingReq, removePendingReq);&#13;
&#13;
&#13;
      if (config.cache &amp;&amp; config.method == 'GET') {&#13;
        cache = isObject(config.cache) ? config.cache : defaultCache;&#13;
      }&#13;
&#13;
      if (cache) {&#13;
        cachedResp = cache.get(url);&#13;
        if (cachedResp) {&#13;
          if (cachedResp.then) {&#13;
            // cached request has already been sent, but there is no response yet&#13;
            cachedResp.then(removePendingReq, removePendingReq);&#13;
            return cachedResp;&#13;
          } else {&#13;
            // serving from cache&#13;
            if (isArray(cachedResp)) {&#13;
              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));&#13;
            } else {&#13;
              resolvePromise(cachedResp, 200, {});&#13;
            }&#13;
          }&#13;
        } else {&#13;
          // put the promise for the non-transformed response into cache as a placeholder&#13;
          cache.put(url, promise);&#13;
        }&#13;
      }&#13;
&#13;
      // if we won't have the response in cache, send the request to the backend&#13;
      if (!cachedResp) {&#13;
        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,&#13;
            config.withCredentials);&#13;
      }&#13;
&#13;
      return promise;&#13;
&#13;
&#13;
      /**&#13;
       * Callback registered to $httpBackend():&#13;
       *  - caches the response if desired&#13;
       *  - resolves the raw $http promise&#13;
       *  - calls $apply&#13;
       */&#13;
      function done(status, response, headersString) {&#13;
        if (cache) {&#13;
          if (isSuccess(status)) {&#13;
            cache.put(url, [status, response, parseHeaders(headersString)]);&#13;
          } else {&#13;
            // remove promise from the cache&#13;
            cache.remove(url);&#13;
          }&#13;
        }&#13;
&#13;
        resolvePromise(response, status, headersString);&#13;
        $rootScope.$apply();&#13;
      }&#13;
&#13;
&#13;
      /**&#13;
       * Resolves the raw $http promise.&#13;
       */&#13;
      function resolvePromise(response, status, headers) {&#13;
        // normalize internal statuses to 0&#13;
        status = Math.max(status, 0);&#13;
&#13;
        (isSuccess(status) ? deferred.resolve : deferred.reject)({&#13;
          data: response,&#13;
          status: status,&#13;
          headers: headersGetter(headers),&#13;
          config: config&#13;
        });&#13;
      }&#13;
&#13;
&#13;
      function removePendingReq() {&#13;
        var idx = indexOf($http.pendingRequests, config);&#13;
        if (idx !== -1) $http.pendingRequests.splice(idx, 1);&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    function buildUrl(url, params) {&#13;
          if (!params) return url;&#13;
          var parts = [];&#13;
          forEachSorted(params, function(value, key) {&#13;
            if (value == null || value == undefined) return;&#13;
            if (isObject(value)) {&#13;
              value = toJson(value);&#13;
            }&#13;
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));&#13;
          });&#13;
          return url + ((url.indexOf('?') == -1) ? '?' : '&amp;') + parts.join('&amp;');&#13;
        }&#13;
&#13;
&#13;
  }];&#13;
}&#13;
var XHR = window.XMLHttpRequest || function() {&#13;
  try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); } catch (e1) {}&#13;
  try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); } catch (e2) {}&#13;
  try { return new ActiveXObject("Msxml2.XMLHTTP"); } catch (e3) {}&#13;
  throw new Error("This browser does not support XMLHttpRequest.");&#13;
};&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$httpBackend&#13;
 * @requires $browser&#13;
 * @requires $window&#13;
 * @requires $document&#13;
 *&#13;
 * @description&#13;
 * HTTP backend used by the {@link angular.module.ng.$http service} that delegates to&#13;
 * XMLHttpRequest object or JSONP and deals with browser incompatibilities.&#13;
 *&#13;
 * You should never need to use this service directly, instead use the higher-level abstractions:&#13;
 * {@link angular.module.ng.$http $http} or {@link angular.module.ngResource.$resource $resource}.&#13;
 *&#13;
 * During testing this implementation is swapped with {@link angular.module.ngMock.$httpBackend mock&#13;
 * $httpBackend} which can be trained with responses.&#13;
 */&#13;
function $HttpBackendProvider() {&#13;
  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {&#13;
    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,&#13;
        $document[0].body, $window.location.protocol.replace(':', ''));&#13;
  }];&#13;
}&#13;
&#13;
function createHttpBackend($browser, XHR, $browserDefer, callbacks, body, locationProtocol) {&#13;
  // TODO(vojta): fix the signature&#13;
  return function(method, url, post, callback, headers, timeout, withCredentials) {&#13;
    $browser.$$incOutstandingRequestCount();&#13;
    url = url || $browser.url();&#13;
&#13;
    if (lowercase(method) == 'jsonp') {&#13;
      var callbackId = '_' + (callbacks.counter++).toString(36);&#13;
      callbacks[callbackId] = function(data) {&#13;
        callbacks[callbackId].data = data;&#13;
      };&#13;
&#13;
      var script = $browser.addJs(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),&#13;
          function() {&#13;
        if (callbacks[callbackId].data) {&#13;
          completeRequest(callback, 200, callbacks[callbackId].data);&#13;
        } else {&#13;
          completeRequest(callback, -2);&#13;
        }&#13;
        delete callbacks[callbackId];&#13;
        body.removeChild(script);&#13;
      });&#13;
    } else {&#13;
      var xhr = new XHR();&#13;
      xhr.open(method, url, true);&#13;
      forEach(headers, function(value, key) {&#13;
        if (value) xhr.setRequestHeader(key, value);&#13;
      });&#13;
&#13;
      var status;&#13;
&#13;
      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the&#13;
      // response is in the cache. the promise api will ensure that to the app code the api is&#13;
      // always async&#13;
      xhr.onreadystatechange = function() {&#13;
        if (xhr.readyState == 4) {&#13;
          completeRequest(&#13;
              callback, status || xhr.status, xhr.responseText, xhr.getAllResponseHeaders());&#13;
        }&#13;
      };&#13;
&#13;
      if (withCredentials) {&#13;
        xhr.withCredentials = true;&#13;
      }&#13;
&#13;
      xhr.send(post || '');&#13;
&#13;
      if (timeout &gt; 0) {&#13;
        $browserDefer(function() {&#13;
          status = -1;&#13;
          xhr.abort();&#13;
        }, timeout);&#13;
      }&#13;
    }&#13;
&#13;
&#13;
    function completeRequest(callback, status, response, headersString) {&#13;
      // URL_MATCH is defined in src/service/location.js&#13;
      var protocol = (url.match(URL_MATCH) || ['', locationProtocol])[1];&#13;
&#13;
      // fix status code for file protocol (it's always 0)&#13;
      status = (protocol == 'file') ? (response ? 200 : 404) : status;&#13;
&#13;
      // normalize IE bug (http://bugs.jquery.com/ticket/1450)&#13;
      status = status == 1223 ? 204 : status;&#13;
&#13;
      callback(status, response, headersString);&#13;
      $browser.$$completeOutstandingRequest(noop);&#13;
    }&#13;
  };&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$locale&#13;
 *&#13;
 * @description&#13;
 * $locale service provides localization rules for various Angular components. As of right now the&#13;
 * only public api is:&#13;
 *&#13;
 * * `id` â€" `{string}` â€" locale id formatted as `languageId-countryId` (e.g. `en-us`)&#13;
 */&#13;
function $LocaleProvider(){&#13;
  this.$get = function() {&#13;
    return {&#13;
      id: 'en-us',&#13;
&#13;
      NUMBER_FORMATS: {&#13;
        DECIMAL_SEP: '.',&#13;
        GROUP_SEP: ',',&#13;
        PATTERNS: [&#13;
          { // Decimal Pattern&#13;
            minInt: 1,&#13;
            minFrac: 0,&#13;
            maxFrac: 3,&#13;
            posPre: '',&#13;
            posSuf: '',&#13;
            negPre: '-',&#13;
            negSuf: '',&#13;
            gSize: 3,&#13;
            lgSize: 3&#13;
          },{ //Currency Pattern&#13;
            minInt: 1,&#13;
            minFrac: 2,&#13;
            maxFrac: 2,&#13;
            posPre: '\u00A4',&#13;
            posSuf: '',&#13;
            negPre: '(\u00A4',&#13;
            negSuf: ')',&#13;
            gSize: 3,&#13;
            lgSize: 3&#13;
          }&#13;
        ],&#13;
        CURRENCY_SYM: '$'&#13;
      },&#13;
&#13;
      DATETIME_FORMATS: {&#13;
        MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'&#13;
                .split(','),&#13;
        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),&#13;
        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),&#13;
        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),&#13;
        AMPMS: ['AM','PM'],&#13;
        medium: 'MMM d, y h:mm:ss a',&#13;
        short: 'M/d/yy h:mm a',&#13;
        fullDate: 'EEEE, MMMM d, y',&#13;
        longDate: 'MMMM d, y',&#13;
        mediumDate: 'MMM d, y',&#13;
        shortDate: 'M/d/yy',&#13;
        mediumTime: 'h:mm:ss a',&#13;
        shortTime: 'h:mm a'&#13;
      },&#13;
&#13;
      pluralCat: function(num) {&#13;
        if (num === 1) {&#13;
          return 'one';&#13;
        }&#13;
        return 'other';&#13;
      }&#13;
    };&#13;
  };&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$filterProvider&#13;
 * @description&#13;
 *&#13;
 * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To&#13;
 * achieve this a filter definition consists of a factory function which is annotated with dependencies and is&#13;
 * responsible for creating a the filter function.&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 *   // Filter registration&#13;
 *   function MyModule($provide, $filterProvider) {&#13;
 *     // create a service to demonstrate injection (not always needed)&#13;
 *     $provide.value('greet', function(name){&#13;
 *       return 'Hello ' + name + '!':&#13;
 *     });&#13;
 *&#13;
 *     // register a filter factory which uses the&#13;
 *     // greet service to demonstrate DI.&#13;
 *     $filterProvider.register('greet', function(greet){&#13;
 *       // return the filter function which uses the greet service&#13;
 *       // to generate salutation&#13;
 *       return function(text) {&#13;
 *         // filters need to be forgiving so check input validity&#13;
 *         return text &amp;&amp; greet(text) || text;&#13;
 *       };&#13;
 *     };&#13;
 *   }&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * The filter function is registered with the `$injector` under the filter name suffixe with `Filter`.&#13;
 * &lt;pre&gt;&#13;
 *   it('should be the same instance', inject(&#13;
 *     function($filterProvider) {&#13;
 *       $filterProvider.register('reverse', function(){&#13;
 *         return ...;&#13;
 *       });&#13;
 *     },&#13;
 *     function($filter, reverseFilter) {&#13;
 *       expect($filter('reverse')).toBe(reverseFilter);&#13;
 *     });&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 *&#13;
 * For more information about how angular filters work, and how to create your own filters, see&#13;
 * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer&#13;
 * Guide.&#13;
 */&#13;
/**&#13;
 * @ngdoc method&#13;
 * @name angular.module.ng.$filterProvider#register&#13;
 * @methodOf angular.module.ng.$filterProvider&#13;
 * @description&#13;
 * Register filter factory function.&#13;
 *&#13;
 * @param {String} name Name of the filter.&#13;
 * @param {function} fn The filter factory function which is injectable.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$filter&#13;
 * @function&#13;
 * @description&#13;
 * Filters are used for formatting data displayed to the user.&#13;
 *&#13;
 * The general syntax in templates is as follows:&#13;
 *&#13;
 *         {{ expression | [ filter_name ] }}&#13;
 *&#13;
 * @param {String} name Name of the filter function to retrieve&#13;
 * @return {Function} the filter function&#13;
 */&#13;
$FilterProvider.$inject = ['$provide'];&#13;
function $FilterProvider($provide) {&#13;
  var suffix = 'Filter';&#13;
&#13;
  function register(name, factory) {&#13;
    return $provide.factory(name + suffix, factory);&#13;
  }&#13;
  this.register = register;&#13;
&#13;
  this.$get = ['$injector', function($injector) {&#13;
    return function(name) {&#13;
      return $injector.get(name + suffix);&#13;
    }&#13;
  }];&#13;
&#13;
  ////////////////////////////////////////&#13;
&#13;
  register('currency', currencyFilter);&#13;
  register('date', dateFilter);&#13;
  register('filter', filterFilter);&#13;
  register('json', jsonFilter);&#13;
  register('limitTo', limitToFilter);&#13;
  register('linky', linkyFilter);&#13;
  register('lowercase', lowercaseFilter);&#13;
  register('number', numberFilter);&#13;
  register('orderBy', orderByFilter);&#13;
  register('uppercase', uppercaseFilter);&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.filter&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Selects a subset of items from `array` and returns it as a new array.&#13;
 *&#13;
 * Note: This function is used to augment the `Array` type in Angular expressions. See&#13;
 * {@link angular.module.ng.$filter} for more information about Angular arrays.&#13;
 *&#13;
 * @param {Array} array The source array.&#13;
 * @param {string|Object|function()} expression The predicate to be used for selecting items from&#13;
 *   `array`.&#13;
 *&#13;
 *   Can be one of:&#13;
 *&#13;
 *   - `string`: Predicate that results in a substring match using the value of `expression`&#13;
 *     string. All strings or objects with string properties in `array` that contain this string&#13;
 *     will be returned. The predicate can be negated by prefixing the string with `!`.&#13;
 *&#13;
 *   - `Object`: A pattern object can be used to filter specific properties on objects contained&#13;
 *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items&#13;
 *     which have property `name` containing "M" and property `phone` containing "1". A special&#13;
 *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any&#13;
 *     property of the object. That's equivalent to the simple substring match with a `string`&#13;
 *     as described above.&#13;
 *&#13;
 *   - `function`: A predicate function can be used to write arbitrary filters. The function is&#13;
 *     called for each element of `array`. The final result is an array of those elements that&#13;
 *     the predicate returned true for.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;div ng-init="friends = [{name:'John', phone:'555-1276'},&#13;
                                {name:'Mary', phone:'800-BIG-MARY'},&#13;
                                {name:'Mike', phone:'555-4321'},&#13;
                                {name:'Adam', phone:'555-5678'},&#13;
                                {name:'Julie', phone:'555-8765'}]"&gt;&lt;/div&gt;&#13;
&#13;
       Search: &lt;input ng-model="searchText"&gt;&#13;
       &lt;table id="searchTextResults"&gt;&#13;
         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;tr&gt;&#13;
         &lt;tr ng-repeat="friend in friends | filter:searchText"&gt;&#13;
           &lt;td&gt;{{friend.name}}&lt;/td&gt;&#13;
           &lt;td&gt;{{friend.phone}}&lt;/td&gt;&#13;
         &lt;tr&gt;&#13;
       &lt;/table&gt;&#13;
       &lt;hr&gt;&#13;
       Any: &lt;input ng-model="search.$"&gt; &lt;br&gt;&#13;
       Name only &lt;input ng-model="search.name"&gt;&lt;br&gt;&#13;
       Phone only &lt;input ng-model="search.phone"Ã¥&gt;&lt;br&gt;&#13;
       &lt;table id="searchObjResults"&gt;&#13;
         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;tr&gt;&#13;
         &lt;tr ng-repeat="friend in friends | filter:search"&gt;&#13;
           &lt;td&gt;{{friend.name}}&lt;/td&gt;&#13;
           &lt;td&gt;{{friend.phone}}&lt;/td&gt;&#13;
         &lt;tr&gt;&#13;
       &lt;/table&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should search across all fields when filtering with a string', function() {&#13;
         input('searchText').enter('m');&#13;
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).&#13;
           toEqual(['Mary', 'Mike', 'Adam']);&#13;
&#13;
         input('searchText').enter('76');&#13;
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).&#13;
           toEqual(['John', 'Julie']);&#13;
       });&#13;
&#13;
       it('should search in specific fields when filtering with a predicate object', function() {&#13;
         input('search.$').enter('i');&#13;
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).&#13;
           toEqual(['Mary', 'Mike', 'Julie']);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
function filterFilter() {&#13;
  return function(array, expression) {&#13;
    if (!(array instanceof Array)) return array;&#13;
    var predicates = [];&#13;
    predicates.check = function(value) {&#13;
      for (var j = 0; j &lt; predicates.length; j++) {&#13;
        if(!predicates[j](value)) {&#13;
          return false;&#13;
        }&#13;
      }&#13;
      return true;&#13;
    };&#13;
    var search = function(obj, text){&#13;
      if (text.charAt(0) === '!') {&#13;
        return !search(obj, text.substr(1));&#13;
      }&#13;
      switch (typeof obj) {&#13;
        case "boolean":&#13;
        case "number":&#13;
        case "string":&#13;
          return ('' + obj).toLowerCase().indexOf(text) &gt; -1;&#13;
        case "object":&#13;
          for ( var objKey in obj) {&#13;
            if (objKey.charAt(0) !== '$' &amp;&amp; search(obj[objKey], text)) {&#13;
              return true;&#13;
            }&#13;
          }&#13;
          return false;&#13;
        case "array":&#13;
          for ( var i = 0; i &lt; obj.length; i++) {&#13;
            if (search(obj[i], text)) {&#13;
              return true;&#13;
            }&#13;
          }&#13;
          return false;&#13;
        default:&#13;
          return false;&#13;
      }&#13;
    };&#13;
    switch (typeof expression) {&#13;
      case "boolean":&#13;
      case "number":&#13;
      case "string":&#13;
        expression = {$:expression};&#13;
      case "object":&#13;
        for (var key in expression) {&#13;
          if (key == '$') {&#13;
            (function() {&#13;
              var text = (''+expression[key]).toLowerCase();&#13;
              if (!text) return;&#13;
              predicates.push(function(value) {&#13;
                return search(value, text);&#13;
              });&#13;
            })();&#13;
          } else {&#13;
            (function() {&#13;
              var path = key;&#13;
              var text = (''+expression[key]).toLowerCase();&#13;
              if (!text) return;&#13;
              predicates.push(function(value) {&#13;
                return search(getter(value, path), text);&#13;
              });&#13;
            })();&#13;
          }&#13;
        }&#13;
        break;&#13;
      case 'function':&#13;
        predicates.push(expression);&#13;
        break;&#13;
      default:&#13;
        return array;&#13;
    }&#13;
    var filtered = [];&#13;
    for ( var j = 0; j &lt; array.length; j++) {&#13;
      var value = array[j];&#13;
      if (predicates.check(value)) {&#13;
        filtered.push(value);&#13;
      }&#13;
    }&#13;
    return filtered;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.currency&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default&#13;
 * symbol for current locale is used.&#13;
 *&#13;
 * @param {number} amount Input to filter.&#13;
 * @param {string=} symbol Currency symbol or identifier to be displayed.&#13;
 * @returns {string} Formatted number.&#13;
 *&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.amount = 1234.56;&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         &lt;input type="number" ng-model="amount"&gt; &lt;br&gt;&#13;
         default currency symbol ($): {{amount | currency}}&lt;br&gt;&#13;
         custom currency identifier (USD$): {{amount | currency:"USD$"}}&#13;
       &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should init with 1234.56', function() {&#13;
         expect(binding('amount | currency')).toBe('$1,234.56');&#13;
         expect(binding('amount | currency:"USD$"')).toBe('USD$1,234.56');&#13;
       });&#13;
       it('should update', function() {&#13;
         input('amount').enter('-1234');&#13;
         expect(binding('amount | currency')).toBe('($1,234.00)');&#13;
         expect(binding('amount | currency:"USD$"')).toBe('(USD$1,234.00)');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
currencyFilter.$inject = ['$locale'];&#13;
function currencyFilter($locale) {&#13;
  var formats = $locale.NUMBER_FORMATS;&#13;
  return function(amount, currencySymbol){&#13;
    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;&#13;
    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).&#13;
                replace(/\u00A4/g, currencySymbol);&#13;
  };&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.number&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Formats a number as text.&#13;
 *&#13;
 * If the input is not a number an empty string is returned.&#13;
 *&#13;
 * @param {number|string} number Number to format.&#13;
 * @param {(number|string)=} [fractionSize=2] Number of decimal places to round the number to.&#13;
 * @returns {string} Number rounded to decimalPlaces and places a â€œ,â€&#157; after each third digit.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.val = 1234.56789;&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         Enter number: &lt;input ng-model='val'&gt;&lt;br&gt;&#13;
         Default formatting: {{val | number}}&lt;br&gt;&#13;
         No fractions: {{val | number:0}}&lt;br&gt;&#13;
         Negative number: {{-val | number:4}}&#13;
       &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should format numbers', function() {&#13;
         expect(binding('val | number')).toBe('1,234.568');&#13;
         expect(binding('val | number:0')).toBe('1,235');&#13;
         expect(binding('-val | number:4')).toBe('-1,234.5679');&#13;
       });&#13;
&#13;
       it('should update', function() {&#13;
         input('val').enter('3374.333');&#13;
         expect(binding('val | number')).toBe('3,374.333');&#13;
         expect(binding('val | number:0')).toBe('3,374');&#13;
         expect(binding('-val | number:4')).toBe('-3,374.3330');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
&#13;
&#13;
numberFilter.$inject = ['$locale'];&#13;
function numberFilter($locale) {&#13;
  var formats = $locale.NUMBER_FORMATS;&#13;
  return function(number, fractionSize) {&#13;
    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,&#13;
      fractionSize);&#13;
  };&#13;
}&#13;
&#13;
var DECIMAL_SEP = '.';&#13;
function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {&#13;
  if (isNaN(number) || !isFinite(number)) return '';&#13;
&#13;
  var isNegative = number &lt; 0;&#13;
  number = Math.abs(number);&#13;
  var numStr = number + '',&#13;
      formatedText = '',&#13;
      parts = [];&#13;
&#13;
  if (numStr.indexOf('e') !== -1) {&#13;
    formatedText = numStr;&#13;
  } else {&#13;
    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;&#13;
&#13;
    // determine fractionSize if it is not specified&#13;
    if (isUndefined(fractionSize)) {&#13;
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);&#13;
    }&#13;
&#13;
    var pow = Math.pow(10, fractionSize);&#13;
    number = Math.round(number * pow) / pow;&#13;
    var fraction = ('' + number).split(DECIMAL_SEP);&#13;
    var whole = fraction[0];&#13;
    fraction = fraction[1] || '';&#13;
&#13;
    var pos = 0,&#13;
        lgroup = pattern.lgSize,&#13;
        group = pattern.gSize;&#13;
&#13;
    if (whole.length &gt;= (lgroup + group)) {&#13;
      pos = whole.length - lgroup;&#13;
      for (var i = 0; i &lt; pos; i++) {&#13;
        if ((pos - i)%group === 0 &amp;&amp; i !== 0) {&#13;
          formatedText += groupSep;&#13;
        }&#13;
        formatedText += whole.charAt(i);&#13;
      }&#13;
    }&#13;
&#13;
    for (i = pos; i &lt; whole.length; i++) {&#13;
      if ((whole.length - i)%lgroup === 0 &amp;&amp; i !== 0) {&#13;
        formatedText += groupSep;&#13;
      }&#13;
      formatedText += whole.charAt(i);&#13;
    }&#13;
&#13;
    // format fraction part.&#13;
    while(fraction.length &lt; fractionSize) {&#13;
      fraction += '0';&#13;
    }&#13;
&#13;
    if (fractionSize) formatedText += decimalSep + fraction.substr(0, fractionSize);&#13;
  }&#13;
&#13;
  parts.push(isNegative ? pattern.negPre : pattern.posPre);&#13;
  parts.push(formatedText);&#13;
  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);&#13;
  return parts.join('');&#13;
}&#13;
&#13;
function padNumber(num, digits, trim) {&#13;
  var neg = '';&#13;
  if (num &lt; 0) {&#13;
    neg =  '-';&#13;
    num = -num;&#13;
  }&#13;
  num = '' + num;&#13;
  while(num.length &lt; digits) num = '0' + num;&#13;
  if (trim)&#13;
    num = num.substr(num.length - digits);&#13;
  return neg + num;&#13;
}&#13;
&#13;
&#13;
function dateGetter(name, size, offset, trim) {&#13;
  return function(date) {&#13;
    var value = date['get' + name]();&#13;
    if (offset &gt; 0 || value &gt; -offset)&#13;
      value += offset;&#13;
    if (value === 0 &amp;&amp; offset == -12 ) value = 12;&#13;
    return padNumber(value, size, trim);&#13;
  };&#13;
}&#13;
&#13;
function dateStrGetter(name, shortForm) {&#13;
  return function(date, formats) {&#13;
    var value = date['get' + name]();&#13;
    var get = uppercase(shortForm ? ('SHORT' + name) : name);&#13;
&#13;
    return formats[get][value];&#13;
  };&#13;
}&#13;
&#13;
function timeZoneGetter(date) {&#13;
  var offset = date.getTimezoneOffset();&#13;
  return padNumber(offset / 60, 2) + padNumber(Math.abs(offset % 60), 2);&#13;
}&#13;
&#13;
function ampmGetter(date, formats) {&#13;
  return date.getHours() &lt; 12 ? formats.AMPMS[0] : formats.AMPMS[1];&#13;
}&#13;
&#13;
var DATE_FORMATS = {&#13;
  yyyy: dateGetter('FullYear', 4),&#13;
    yy: dateGetter('FullYear', 2, 0, true),&#13;
     y: dateGetter('FullYear', 1),&#13;
  MMMM: dateStrGetter('Month'),&#13;
   MMM: dateStrGetter('Month', true),&#13;
    MM: dateGetter('Month', 2, 1),&#13;
     M: dateGetter('Month', 1, 1),&#13;
    dd: dateGetter('Date', 2),&#13;
     d: dateGetter('Date', 1),&#13;
    HH: dateGetter('Hours', 2),&#13;
     H: dateGetter('Hours', 1),&#13;
    hh: dateGetter('Hours', 2, -12),&#13;
     h: dateGetter('Hours', 1, -12),&#13;
    mm: dateGetter('Minutes', 2),&#13;
     m: dateGetter('Minutes', 1),&#13;
    ss: dateGetter('Seconds', 2),&#13;
     s: dateGetter('Seconds', 1),&#13;
  EEEE: dateStrGetter('Day'),&#13;
   EEE: dateStrGetter('Day', true),&#13;
     a: ampmGetter,&#13;
     Z: timeZoneGetter&#13;
};&#13;
&#13;
var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,&#13;
    NUMBER_STRING = /^\d+$/;&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.date&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 *   Formats `date` to a string based on the requested `format`.&#13;
 *&#13;
 *   `format` string can be composed of the following elements:&#13;
 *&#13;
 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 =&gt; 0001, AD 2010 =&gt; 2010)&#13;
 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 =&gt; 01, AD 2010 =&gt; 10)&#13;
 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 =&gt; 1, AD 199 =&gt; 199)&#13;
 *   * `'MMMM'`: Month in year (January-December)&#13;
 *   * `'MMM'`: Month in year (Jan-Dec)&#13;
 *   * `'MM'`: Month in year, padded (01-12)&#13;
 *   * `'M'`: Month in year (1-12)&#13;
 *   * `'dd'`: Day in month, padded (01-31)&#13;
 *   * `'d'`: Day in month (1-31)&#13;
 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)&#13;
 *   * `'EEE'`: Day in Week, (Sun-Sat)&#13;
 *   * `'HH'`: Hour in day, padded (00-23)&#13;
 *   * `'H'`: Hour in day (0-23)&#13;
 *   * `'hh'`: Hour in am/pm, padded (01-12)&#13;
 *   * `'h'`: Hour in am/pm, (1-12)&#13;
 *   * `'mm'`: Minute in hour, padded (00-59)&#13;
 *   * `'m'`: Minute in hour (0-59)&#13;
 *   * `'ss'`: Second in minute, padded (00-59)&#13;
 *   * `'s'`: Second in minute (0-59)&#13;
 *   * `'a'`: am/pm marker&#13;
 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-1200)&#13;
 *&#13;
 *   `format` string can also be one of the following predefined&#13;
 *   {@link guide/dev_guide.i18n localizable formats}:&#13;
 *&#13;
 *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale&#13;
 *     (e.g. Sep 3, 2010 12:05:08 pm)&#13;
 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)&#13;
 *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale&#13;
 *     (e.g. Friday, September 3, 2010)&#13;
 *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010&#13;
 *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)&#13;
 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)&#13;
 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)&#13;
 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)&#13;
 *&#13;
 *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.&#13;
 *   `"h 'in the morning'"`). In order to output single quote, use two single quotes in a sequence&#13;
 *   (e.g. `"h o''clock"`).&#13;
 *&#13;
 * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or&#13;
 *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and it's&#13;
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ).&#13;
 * @param {string=} format Formatting rules (see Description). If not specified,&#13;
 *    `mediumDate` is used.&#13;
 * @returns {string} Formatted string or the input if input is not recognized as date/millis.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'medium'}}&lt;/span&gt;:&#13;
           {{1288323623006 | date:'medium'}}&lt;br&gt;&#13;
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}&lt;/span&gt;:&#13;
          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}&lt;br&gt;&#13;
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}&lt;/span&gt;:&#13;
          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}&lt;br&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should format date', function() {&#13;
         expect(binding("1288323623006 | date:'medium'")).&#13;
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);&#13;
         expect(binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).&#13;
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} \-?\d{4}/);&#13;
         expect(binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).&#13;
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
dateFilter.$inject = ['$locale'];&#13;
function dateFilter($locale) {&#13;
&#13;
&#13;
  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;&#13;
  function jsonStringToDate(string){&#13;
    var match;&#13;
    if (match = string.match(R_ISO8601_STR)) {&#13;
      var date = new Date(0),&#13;
          tzHour = 0,&#13;
          tzMin  = 0;&#13;
      if (match[9]) {&#13;
        tzHour = int(match[9] + match[10]);&#13;
        tzMin = int(match[9] + match[11]);&#13;
      }&#13;
      date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));&#13;
      date.setUTCHours(int(match[4]||0) - tzHour, int(match[5]||0) - tzMin, int(match[6]||0), int(match[7]||0));&#13;
      return date;&#13;
    }&#13;
    return string;&#13;
  }&#13;
&#13;
&#13;
  return function(date, format) {&#13;
    var text = '',&#13;
        parts = [],&#13;
        fn, match;&#13;
&#13;
    format = format || 'mediumDate'&#13;
    format = $locale.DATETIME_FORMATS[format] || format;&#13;
    if (isString(date)) {&#13;
      if (NUMBER_STRING.test(date)) {&#13;
        date = int(date);&#13;
      } else {&#13;
        date = jsonStringToDate(date);&#13;
      }&#13;
    }&#13;
&#13;
    if (isNumber(date)) {&#13;
      date = new Date(date);&#13;
    }&#13;
&#13;
    if (!isDate(date)) {&#13;
      return date;&#13;
    }&#13;
&#13;
    while(format) {&#13;
      match = DATE_FORMATS_SPLIT.exec(format);&#13;
      if (match) {&#13;
        parts = concat(parts, match, 1);&#13;
        format = parts.pop();&#13;
      } else {&#13;
        parts.push(format);&#13;
        format = null;&#13;
      }&#13;
    }&#13;
&#13;
    forEach(parts, function(value){&#13;
      fn = DATE_FORMATS[value];&#13;
      text += fn ? fn(date, $locale.DATETIME_FORMATS)&#13;
                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");&#13;
    });&#13;
&#13;
    return text;&#13;
  };&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.json&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 *   Allows you to convert a JavaScript object into JSON string.&#13;
 *&#13;
 *   This filter is mostly useful for debugging. When using the double curly {{value}} notation&#13;
 *   the binding is automatically converted to JSON.&#13;
 *&#13;
 * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.&#13;
 * @returns {string} JSON string.&#13;
 *&#13;
 * @css ng-monospace Always applied to the encapsulating element.&#13;
 *&#13;
 * @example:&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;pre&gt;{{ {'name':'value'} | json }}&lt;/pre&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should jsonify filtered objects', function() {&#13;
         expect(binding("{'name':'value'}")).toMatch(/\{\n  "name": ?"value"\n}/);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 *&#13;
 */&#13;
function jsonFilter() {&#13;
  return function(object) {&#13;
    return toJson(object, true);&#13;
  };&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.lowercase&#13;
 * @function&#13;
 * @description&#13;
 * Converts string to lowercase.&#13;
 * @see angular.lowercase&#13;
 */&#13;
var lowercaseFilter = valueFn(lowercase);&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.uppercase&#13;
 * @function&#13;
 * @description&#13;
 * Converts string to uppercase.&#13;
 * @see angular.uppercase&#13;
 */&#13;
var uppercaseFilter = valueFn(uppercase);&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc filter&#13;
 * @name angular.module.ng.$filter.linky&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 *   Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and&#13;
 *   plain email address links.&#13;
 *&#13;
 * @param {string} text Input text.&#13;
 * @returns {string} Html-linkified text.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.snippet =&#13;
             'Pretty text with some links:\n'+&#13;
             'http://angularjs.org/,\n'+&#13;
             'mailto:us@somewhere.org,\n'+&#13;
             'another@somewhere.org,\n'+&#13;
             'and one more: ftp://127.0.0.1/.';&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
       Snippet: &lt;textarea ng-model="snippet" cols="60" rows="3"&gt;&lt;/textarea&gt;&#13;
       &lt;table&gt;&#13;
         &lt;tr&gt;&#13;
           &lt;td&gt;Filter&lt;/td&gt;&#13;
           &lt;td&gt;Source&lt;/td&gt;&#13;
           &lt;td&gt;Rendered&lt;/td&gt;&#13;
         &lt;/tr&gt;&#13;
         &lt;tr id="linky-filter"&gt;&#13;
           &lt;td&gt;linky filter&lt;/td&gt;&#13;
           &lt;td&gt;&#13;
             &lt;pre&gt;&amp;lt;div ng-bind-html="snippet | linky"&amp;gt;&lt;br&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&#13;
           &lt;/td&gt;&#13;
           &lt;td&gt;&#13;
             &lt;div ng-bind-html="snippet | linky"&gt;&lt;/div&gt;&#13;
           &lt;/td&gt;&#13;
         &lt;/tr&gt;&#13;
         &lt;tr id="escaped-html"&gt;&#13;
           &lt;td&gt;no filter&lt;/td&gt;&#13;
           &lt;td&gt;&lt;pre&gt;&amp;lt;div ng-bind="snippet"&amp;gt;&lt;br&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;/td&gt;&#13;
           &lt;td&gt;&lt;div ng-bind="snippet"&gt;&lt;/div&gt;&lt;/td&gt;&#13;
         &lt;/tr&gt;&#13;
       &lt;/table&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should linkify the snippet with urls', function() {&#13;
         expect(using('#linky-filter').binding('snippet | linky')).&#13;
           toBe('Pretty text with some links:&amp;#10;' +&#13;
                '&lt;a href="http://angularjs.org/"&gt;http://angularjs.org/&lt;/a&gt;,&amp;#10;' +&#13;
                '&lt;a href="mailto:us@somewhere.org"&gt;us@somewhere.org&lt;/a&gt;,&amp;#10;' +&#13;
                '&lt;a href="mailto:another@somewhere.org"&gt;another@somewhere.org&lt;/a&gt;,&amp;#10;' +&#13;
                'and one more: &lt;a href="ftp://127.0.0.1/"&gt;ftp://127.0.0.1/&lt;/a&gt;.');&#13;
       });&#13;
&#13;
       it ('should not linkify snippet without the linky filter', function() {&#13;
         expect(using('#escaped-html').binding('snippet')).&#13;
           toBe("Pretty text with some links:\n" +&#13;
                "http://angularjs.org/,\n" +&#13;
                "mailto:us@somewhere.org,\n" +&#13;
                "another@somewhere.org,\n" +&#13;
                "and one more: ftp://127.0.0.1/.");&#13;
       });&#13;
&#13;
       it('should update', function() {&#13;
         input('snippet').enter('new http://link.');&#13;
         expect(using('#linky-filter').binding('snippet | linky')).&#13;
           toBe('new &lt;a href="http://link"&gt;http://link&lt;/a&gt;.');&#13;
         expect(using('#escaped-html').binding('snippet')).toBe('new http://link.');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
function linkyFilter() {&#13;
  var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s\.\;\,\(\)\{\}\&lt;\&gt;]/,&#13;
      MAILTO_REGEXP = /^mailto:/;&#13;
&#13;
  return function(text) {&#13;
    if (!text) return text;&#13;
    var match;&#13;
    var raw = text;&#13;
    var html = [];&#13;
    var writer = htmlSanitizeWriter(html);&#13;
    var url;&#13;
    var i;&#13;
    while ((match = raw.match(LINKY_URL_REGEXP))) {&#13;
      // We can not end in these as they are sometimes found at the end of the sentence&#13;
      url = match[0];&#13;
      // if we did not match ftp/http/mailto then assume mailto&#13;
      if (match[2] == match[3]) url = 'mailto:' + url;&#13;
      i = match.index;&#13;
      writer.chars(raw.substr(0, i));&#13;
      writer.start('a', {href:url});&#13;
      writer.chars(match[0].replace(MAILTO_REGEXP, ''));&#13;
      writer.end('a');&#13;
      raw = raw.substring(i + match[0].length);&#13;
    }&#13;
    writer.chars(raw);&#13;
    return html.join('');&#13;
  };&#13;
};&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$filter.limitTo&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Creates a new array containing only a specified number of elements in an array. The elements&#13;
 * are taken from either the beginning or the end of the source array, as specified by the&#13;
 * value and sign (positive or negative) of `limit`.&#13;
 *&#13;
 * Note: This function is used to augment the `Array` type in Angular expressions. See&#13;
 * {@link angular.module.ng.$filter} for more information about Angular arrays.&#13;
 *&#13;
 * @param {Array} array Source array to be limited.&#13;
 * @param {string|Number} limit The length of the returned array. If the `limit` number is&#13;
 *     positive, `limit` number of items from the beginning of the source array are copied.&#13;
 *     If the number is negative, `limit` number  of items from the end of the source array are&#13;
 *     copied. The `limit` will be trimmed if it exceeds `array.length`&#13;
 * @returns {Array} A new sub-array of length `limit` or less if input array had less than `limit`&#13;
 *     elements.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.numbers = [1,2,3,4,5,6,7,8,9];&#13;
           $scope.limit = 3;&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         Limit {{numbers}} to: &lt;input type="integer" ng-model="limit"&gt;&#13;
         &lt;p&gt;Output: {{ numbers | limitTo:limit }}&lt;/p&gt;&#13;
       &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should limit the numer array to first three items', function() {&#13;
         expect(element('.doc-example-live input[ng-model=limit]').val()).toBe('3');&#13;
         expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3]');&#13;
       });&#13;
&#13;
       it('should update the output when -3 is entered', function() {&#13;
         input('limit').enter(-3);&#13;
         expect(binding('numbers | limitTo:limit')).toEqual('[7,8,9]');&#13;
       });&#13;
&#13;
       it('should not exceed the maximum size of input array', function() {&#13;
         input('limit').enter(100);&#13;
         expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3,4,5,6,7,8,9]');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
function limitToFilter(){&#13;
  return function(array, limit) {&#13;
    if (!(array instanceof Array)) return array;&#13;
    limit = int(limit);&#13;
    var out = [],&#13;
      i, n;&#13;
&#13;
    // check that array is iterable&#13;
    if (!array || !(array instanceof Array))&#13;
      return out;&#13;
&#13;
    // if abs(limit) exceeds maximum length, trim it&#13;
    if (limit &gt; array.length)&#13;
      limit = array.length;&#13;
    else if (limit &lt; -array.length)&#13;
      limit = -array.length;&#13;
&#13;
    if (limit &gt; 0) {&#13;
      i = 0;&#13;
      n = limit;&#13;
    } else {&#13;
      i = array.length + limit;&#13;
      n = array.length;&#13;
    }&#13;
&#13;
    for (; i&lt;n; i++) {&#13;
      out.push(array[i]);&#13;
    }&#13;
&#13;
    return out;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc function&#13;
 * @name angular.module.ng.$filter.orderBy&#13;
 * @function&#13;
 *&#13;
 * @description&#13;
 * Orders a specified `array` by the `expression` predicate.&#13;
 *&#13;
 * Note: this function is used to augment the `Array` type in Angular expressions. See&#13;
 * {@link angular.module.ng.$filter} for more informaton about Angular arrays.&#13;
 *&#13;
 * @param {Array} array The array to sort.&#13;
 * @param {function(*)|string|Array.&lt;(function(*)|string)&gt;} expression A predicate to be&#13;
 *    used by the comparator to determine the order of elements.&#13;
 *&#13;
 *    Can be one of:&#13;
 *&#13;
 *    - `function`: Getter function. The result of this function will be sorted using the&#13;
 *      `&lt;`, `=`, `&gt;` operator.&#13;
 *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'&#13;
 *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control&#13;
 *      ascending or descending sort order (for example, +name or -name).&#13;
 *    - `Array`: An array of function or string predicates. The first predicate in the array&#13;
 *      is used for sorting, but when two items are equivalent, the next predicate is used.&#13;
 *&#13;
 * @param {boolean=} reverse Reverse the order the array.&#13;
 * @returns {Array} Sorted copy of the source array.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.friends =&#13;
               [{name:'John', phone:'555-1212', age:10},&#13;
                {name:'Mary', phone:'555-9876', age:19},&#13;
                {name:'Mike', phone:'555-4321', age:21},&#13;
                {name:'Adam', phone:'555-5678', age:35},&#13;
                {name:'Julie', phone:'555-8765', age:29}]&#13;
           $scope.predicate = '-age';&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         &lt;pre&gt;Sorting predicate = {{predicate}}; reverse = {{reverse}}&lt;/pre&gt;&#13;
         &lt;hr/&gt;&#13;
         [ &lt;a href="" ng-click="predicate=''"&gt;unsorted&lt;/a&gt; ]&#13;
         &lt;table class="friend"&gt;&#13;
           &lt;tr&gt;&#13;
             &lt;th&gt;&lt;a href="" ng-click="predicate = 'name'; reverse=false"&gt;Name&lt;/a&gt;&#13;
                 (&lt;a href ng-click="predicate = '-name'; reverse=false"&gt;^&lt;/a&gt;)&lt;/th&gt;&#13;
             &lt;th&gt;&lt;a href="" ng-click="predicate = 'phone'; reverse=!reverse"&gt;Phone Number&lt;/a&gt;&lt;/th&gt;&#13;
             &lt;th&gt;&lt;a href="" ng-click="predicate = 'age'; reverse=!reverse"&gt;Age&lt;/a&gt;&lt;/th&gt;&#13;
           &lt;tr&gt;&#13;
           &lt;tr ng-repeat="friend in friends | orderBy:predicate:reverse"&gt;&#13;
             &lt;td&gt;{{friend.name}}&lt;/td&gt;&#13;
             &lt;td&gt;{{friend.phone}}&lt;/td&gt;&#13;
             &lt;td&gt;{{friend.age}}&lt;/td&gt;&#13;
           &lt;tr&gt;&#13;
         &lt;/table&gt;&#13;
       &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should be reverse ordered by aged', function() {&#13;
         expect(binding('predicate')).toBe('-age');&#13;
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).&#13;
           toEqual(['35', '29', '21', '19', '10']);&#13;
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).&#13;
           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);&#13;
       });&#13;
&#13;
       it('should reorder the table when user selects different predicate', function() {&#13;
         element('.doc-example-live a:contains("Name")').click();&#13;
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).&#13;
           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);&#13;
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).&#13;
           toEqual(['35', '10', '29', '19', '21']);&#13;
&#13;
         element('.doc-example-live a:contains("Phone")').click();&#13;
         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).&#13;
           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);&#13;
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).&#13;
           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
orderByFilter.$inject = ['$parse'];&#13;
function orderByFilter($parse){&#13;
  return function(array, sortPredicate, reverseOrder) {&#13;
    if (!(array instanceof Array)) return array;&#13;
    if (!sortPredicate) return array;&#13;
    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];&#13;
    sortPredicate = map(sortPredicate, function(predicate){&#13;
      var descending = false, get = predicate || identity;&#13;
      if (isString(predicate)) {&#13;
        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {&#13;
          descending = predicate.charAt(0) == '-';&#13;
          predicate = predicate.substring(1);&#13;
        }&#13;
        get = $parse(predicate);&#13;
      }&#13;
      return reverseComparator(function(a,b){&#13;
        return compare(get(a),get(b));&#13;
      }, descending);&#13;
    });&#13;
    var arrayCopy = [];&#13;
    for ( var i = 0; i &lt; array.length; i++) { arrayCopy.push(array[i]); }&#13;
    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));&#13;
&#13;
    function comparator(o1, o2){&#13;
      for ( var i = 0; i &lt; sortPredicate.length; i++) {&#13;
        var comp = sortPredicate[i](o1, o2);&#13;
        if (comp !== 0) return comp;&#13;
      }&#13;
      return 0;&#13;
    }&#13;
    function reverseComparator(comp, descending) {&#13;
      return toBoolean(descending)&#13;
          ? function(a,b){return comp(b,a);}&#13;
          : comp;&#13;
    }&#13;
    function compare(v1, v2){&#13;
      var t1 = typeof v1;&#13;
      var t2 = typeof v2;&#13;
      if (t1 == t2) {&#13;
        if (t1 == "string") v1 = v1.toLowerCase();&#13;
        if (t1 == "string") v2 = v2.toLowerCase();&#13;
        if (v1 === v2) return 0;&#13;
        return v1 &lt; v2 ? -1 : 1;&#13;
      } else {&#13;
        return t1 &lt; t2 ? -1 : 1;&#13;
      }&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
function ngDirective(directive) {&#13;
  if (isFunction(directive)) {&#13;
    directive = {&#13;
      link: directive&#13;
    }&#13;
  }&#13;
  directive.restrict = directive.restrict || 'AC';&#13;
  return valueFn(directive);&#13;
};&#13;
&#13;
/*&#13;
 * Modifies the default behavior of html A tag, so that the default action is prevented when href&#13;
 * attribute is empty.&#13;
 *&#13;
 * The reasoning for this change is to allow easy creation of action links with ng-click without&#13;
 * changing the location or causing page reloads, e.g.:&#13;
 * &lt;a href="" ng-click="model.$save()"&gt;Save&lt;/a&gt;&#13;
 */&#13;
var htmlAnchorDirective = valueFn({&#13;
  restrict: 'E',&#13;
  compile: function(element, attr) {&#13;
    // turn &lt;a href ng-click=".."&gt;link&lt;/a&gt; into a link in IE&#13;
    // but only if it doesn't have name attribute, in which case it's an anchor&#13;
    if (!attr.href) {&#13;
      attr.$set('href', '');&#13;
    }&#13;
&#13;
    return function(scope, element) {&#13;
      element.bind('click', function(event){&#13;
        // if we have no href url, then don't navigate anywhere.&#13;
        if (!element.attr('href')) {&#13;
          event.preventDefault();&#13;
        }&#13;
      });&#13;
    }&#13;
  }&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-href&#13;
 * @restrict A&#13;
 *&#13;
 * @description&#13;
 * Using &lt;angular/&gt; markup like {{hash}} in an href attribute makes&#13;
 * the page open to a wrong URL, if the user clicks that link before&#13;
 * angular has a chance to replace the {{hash}} with actual URL, the&#13;
 * link will be broken and will most likely return a 404 error.&#13;
 * The `ng-href` solves this problem by placing the `href` in the&#13;
 * `ng-` namespace.&#13;
 *&#13;
 * The buggy way to write it:&#13;
 * &lt;pre&gt;&#13;
 * &lt;a href="http://www.gravatar.com/avatar/{{hash}}"/&gt;&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * The correct way to write it:&#13;
 * &lt;pre&gt;&#13;
 * &lt;a ng-href="http://www.gravatar.com/avatar/{{hash}}"/&gt;&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * @element A&#13;
 * @param {template} ng-href any string which can contain `{{}}` markup.&#13;
 *&#13;
 * @example&#13;
 * This example uses `link` variable inside `href` attribute:&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        &lt;input ng-model="value" /&gt;&lt;br /&gt;&#13;
        &lt;a id="link-1" href ng-click="value = 1"&gt;link 1&lt;/a&gt; (link, don't reload)&lt;br /&gt;&#13;
        &lt;a id="link-2" href="" ng-click="value = 2"&gt;link 2&lt;/a&gt; (link, don't reload)&lt;br /&gt;&#13;
        &lt;a id="link-3" ng-href="/{{'123'}}" ng-ext-link&gt;link 3&lt;/a&gt; (link, reload!)&lt;br /&gt;&#13;
        &lt;a id="link-4" href="" name="xx" ng-click="value = 4"&gt;anchor&lt;/a&gt; (link, don't reload)&lt;br /&gt;&#13;
        &lt;a id="link-5" name="xxx" ng-click="value = 5"&gt;anchor&lt;/a&gt; (no link)&lt;br /&gt;&#13;
        &lt;a id="link-6" ng-href="/{{value}}" ng-ext-link&gt;link&lt;/a&gt; (link, change hash)&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should execute ng-click but not reload when href without value', function() {&#13;
          element('#link-1').click();&#13;
          expect(input('value').val()).toEqual('1');&#13;
          expect(element('#link-1').attr('href')).toBe("");&#13;
        });&#13;
&#13;
        it('should execute ng-click but not reload when href empty string', function() {&#13;
          element('#link-2').click();&#13;
          expect(input('value').val()).toEqual('2');&#13;
          expect(element('#link-2').attr('href')).toBe("");&#13;
        });&#13;
&#13;
        it('should execute ng-click and change url when ng-href specified', function() {&#13;
          expect(element('#link-3').attr('href')).toBe("/123");&#13;
&#13;
          element('#link-3').click();&#13;
          expect(browser().window().path()).toEqual('/123');&#13;
        });&#13;
&#13;
        it('should execute ng-click but not reload when href empty string and name specified', function() {&#13;
          element('#link-4').click();&#13;
          expect(input('value').val()).toEqual('4');&#13;
          expect(element('#link-4').attr('href')).toBe("");&#13;
        });&#13;
&#13;
        it('should execute ng-click but not reload when no href but name specified', function() {&#13;
          element('#link-5').click();&#13;
          expect(input('value').val()).toEqual('5');&#13;
          expect(element('#link-5').attr('href')).toBe("");&#13;
        });&#13;
&#13;
        it('should only change url when only ng-href', function() {&#13;
          input('value').enter('6');&#13;
          expect(element('#link-6').attr('href')).toBe("/6");&#13;
&#13;
          element('#link-6').click();&#13;
          expect(browser().window().path()).toEqual('/6');&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-src&#13;
 * @restrict A&#13;
 *&#13;
 * @description&#13;
 * Using &lt;angular/&gt; markup like `{{hash}}` in a `src` attribute doesn't&#13;
 * work right: The browser will fetch from the URL with the literal&#13;
 * text `{{hash}}` until &lt;angular/&gt; replaces the expression inside&#13;
 * `{{hash}}`. The `ng-src` attribute solves this problem by placing&#13;
 *  the `src` attribute in the `ng-` namespace.&#13;
 *&#13;
 * The buggy way to write it:&#13;
 * &lt;pre&gt;&#13;
 * &lt;img src="http://www.gravatar.com/avatar/{{hash}}"/&gt;&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * The correct way to write it:&#13;
 * &lt;pre&gt;&#13;
 * &lt;img ng-src="http://www.gravatar.com/avatar/{{hash}}"/&gt;&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * @element IMG&#13;
 * @param {template} ng-src any string which can contain `{{}}` markup.&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-disabled&#13;
 * @restrict A&#13;
 *&#13;
 * @description&#13;
 *&#13;
 * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:&#13;
 * &lt;pre&gt;&#13;
 * &lt;div ng-init="scope = { isDisabled: false }"&gt;&#13;
 *  &lt;button disabled="{{scope.isDisabled}}"&gt;Disabled&lt;/button&gt;&#13;
 * &lt;/div&gt;&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * The HTML specs do not require browsers to preserve the special attributes such as disabled.&#13;
 * (The presence of them means true and absence means false)&#13;
 * This prevents the angular compiler from correctly retrieving the binding expression.&#13;
 * To solve this problem, we introduce ng-disabled.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        Click me to toggle: &lt;input type="checkbox" ng-model="checked"&gt;&lt;br/&gt;&#13;
        &lt;button ng-model="button" ng-disabled="checked"&gt;Button&lt;/button&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should toggle button', function() {&#13;
          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();&#13;
          input('checked').check();&#13;
          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 *&#13;
 * @element INPUT&#13;
 * @param {string} expression Angular expression that will be evaluated.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-checked&#13;
 * @restrict A&#13;
 *&#13;
 * @description&#13;
 * The HTML specs do not require browsers to preserve the special attributes such as checked.&#13;
 * (The presence of them means true and absence means false)&#13;
 * This prevents the angular compiler from correctly retrieving the binding expression.&#13;
 * To solve this problem, we introduce ng-checked.&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        Check me to check both: &lt;input type="checkbox" ng-model="master"&gt;&lt;br/&gt;&#13;
        &lt;input id="checkSlave" type="checkbox" ng-checked="master"&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should check both checkBoxes', function() {&#13;
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();&#13;
          input('master').check();&#13;
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 *&#13;
 * @element INPUT&#13;
 * @param {string} expression Angular expression that will be evaluated.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-multiple&#13;
 * @restrict A&#13;
 *&#13;
 * @description&#13;
 * The HTML specs do not require browsers to preserve the special attributes such as multiple.&#13;
 * (The presence of them means true and absence means false)&#13;
 * This prevents the angular compiler from correctly retrieving the binding expression.&#13;
 * To solve this problem, we introduce ng-multiple.&#13;
 *&#13;
 * @example&#13;
     &lt;doc:example&gt;&#13;
       &lt;doc:source&gt;&#13;
         Check me check multiple: &lt;input type="checkbox" ng-model="checked"&gt;&lt;br/&gt;&#13;
         &lt;select id="select" ng-multiple="checked"&gt;&#13;
           &lt;option&gt;Misko&lt;/option&gt;&#13;
           &lt;option&gt;Igor&lt;/option&gt;&#13;
           &lt;option&gt;Vojta&lt;/option&gt;&#13;
           &lt;option&gt;Di&lt;/option&gt;&#13;
         &lt;/select&gt;&#13;
       &lt;/doc:source&gt;&#13;
       &lt;doc:scenario&gt;&#13;
         it('should toggle multiple', function() {&#13;
           expect(element('.doc-example-live #select').prop('multiple')).toBeFalsy();&#13;
           input('checked').check();&#13;
           expect(element('.doc-example-live #select').prop('multiple')).toBeTruthy();&#13;
         });&#13;
       &lt;/doc:scenario&gt;&#13;
     &lt;/doc:example&gt;&#13;
 *&#13;
 * @element SELECT&#13;
 * @param {string} expression Angular expression that will be evaluated.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-readonly&#13;
 * @restrict A&#13;
 *&#13;
 * @description&#13;
 * The HTML specs do not require browsers to preserve the special attributes such as readonly.&#13;
 * (The presence of them means true and absence means false)&#13;
 * This prevents the angular compiler from correctly retrieving the binding expression.&#13;
 * To solve this problem, we introduce ng-readonly.&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        Check me to make text readonly: &lt;input type="checkbox" ng-model="checked"&gt;&lt;br/&gt;&#13;
        &lt;input type="text" ng-readonly="checked" value="I'm Angular"/&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should toggle readonly attr', function() {&#13;
          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();&#13;
          input('checked').check();&#13;
          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 *&#13;
 * @element INPUT&#13;
 * @param {string} expression Angular expression that will be evaluated.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-selected&#13;
 * @restrict A&#13;
 *&#13;
 * @description&#13;
 * The HTML specs do not require browsers to preserve the special attributes such as selected.&#13;
 * (The presence of them means true and absence means false)&#13;
 * This prevents the angular compiler from correctly retrieving the binding expression.&#13;
 * To solve this problem, we introduce ng-selected.&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        Check me to select: &lt;input type="checkbox" ng-model="selected"&gt;&lt;br/&gt;&#13;
        &lt;select&gt;&#13;
          &lt;option&gt;Hello!&lt;/option&gt;&#13;
          &lt;option id="greet" ng-selected="selected"&gt;Greetings!&lt;/option&gt;&#13;
        &lt;/select&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should select Greetings!', function() {&#13;
          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();&#13;
          input('selected').check();&#13;
          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 *&#13;
 * @element OPTION&#13;
 * @param {string} expression Angular expression that will be evaluated.&#13;
 */&#13;
&#13;
&#13;
var ngAttributeAliasDirectives = {};&#13;
&#13;
&#13;
// boolean attrs are evaluated&#13;
forEach(BOOLEAN_ATTR, function(propName, attrName) {&#13;
  var normalized = directiveNormalize('ng-' + attrName);&#13;
  ngAttributeAliasDirectives[normalized] = function() {&#13;
    return {&#13;
      priority: 100,&#13;
      compile: function(tpl, attr) {&#13;
        return function(scope, element, attr) {&#13;
          attr.$$observers[attrName] = [];&#13;
          scope.$watch(attr[normalized], function(value) {&#13;
            attr.$set(attrName, !!value);&#13;
          });&#13;
        };&#13;
      }&#13;
    };&#13;
  };&#13;
});&#13;
&#13;
&#13;
// ng-src, ng-href are interpolated&#13;
forEach(['src', 'href'], function(attrName) {&#13;
  var normalized = directiveNormalize('ng-' + attrName);&#13;
  ngAttributeAliasDirectives[normalized] = function() {&#13;
    return {&#13;
      priority: 99, // it needs to run after the attributes are interpolated&#13;
      compile: function(tpl, attr) {&#13;
        return function(scope, element, attr) {&#13;
          var value = attr[normalized];&#13;
          if (value == undefined) {&#13;
            // undefined value means that the directive is being interpolated&#13;
            // so just register observer&#13;
            attr.$$observers[attrName] = [];&#13;
            attr.$observe(normalized, function(value) {&#13;
              attr.$set(attrName, value);&#13;
            });&#13;
          } else {&#13;
            // value present means that no interpolation, so copy to native attribute.&#13;
            attr.$set(attrName, value);&#13;
          }&#13;
        };&#13;
      }&#13;
    };&#13;
  };&#13;
});&#13;
&#13;
var nullFormCtrl = {&#13;
  $addControl: noop,&#13;
  $removeControl: noop,&#13;
  $setValidity: noop,&#13;
  $setDirty: noop&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$compileProvider.directive.form.FormController&#13;
 *&#13;
 * @property {boolean} $pristine True if user has not interacted with the form yet.&#13;
 * @property {boolean} $dirty True if user has already interacted with the form.&#13;
 * @property {boolean} $valid True if all of the containg forms and controls are valid.&#13;
 * @property {boolean} $invalid True if at least one containing control or form is invalid.&#13;
 *&#13;
 * @property {Object} $error Is an object hash, containing references to all invalid controls or&#13;
 *  forms, where:&#13;
 *&#13;
 *  - keys are validation tokens (error names) â€" such as `REQUIRED`, `URL` or `EMAIL`),&#13;
 *  - values are arrays of controls or forms that are invalid with given error.&#13;
 *&#13;
 * @description&#13;
 * `FormController` keeps track of all its controls and nested forms as well as state of them,&#13;
 * such as being valid/invalid or dirty/pristine.&#13;
 *&#13;
 * Each {@link angular.module.ng.$compileProvider.directive.form form} directive creates an instance&#13;
 * of `FormController`.&#13;
 *&#13;
 */&#13;
//asks for $scope to fool the BC controller module&#13;
FormController.$inject = ['$element', '$attrs', '$scope'];&#13;
function FormController(element, attrs) {&#13;
  var form = this,&#13;
      parentForm = element.parent().controller('form') || nullFormCtrl,&#13;
      invalidCount = 0, // used to easily determine if we are valid&#13;
      errors = form.$error = {};&#13;
&#13;
  // init state&#13;
  form.$name = attrs.name;&#13;
  form.$dirty = false;&#13;
  form.$pristine = true;&#13;
  form.$valid = true;&#13;
  form.$invalid = false;&#13;
&#13;
  parentForm.$addControl(form);&#13;
&#13;
  // Setup initial state of the control&#13;
  element.addClass(PRISTINE_CLASS);&#13;
  toggleValidCss(true);&#13;
&#13;
  // convenience method for easy toggling of classes&#13;
  function toggleValidCss(isValid, validationErrorKey) {&#13;
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';&#13;
    element.&#13;
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).&#13;
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);&#13;
  }&#13;
&#13;
  form.$addControl = function(control) {&#13;
    if (control.$name &amp;&amp; !form.hasOwnProperty(control.$name)) {&#13;
      form[control.$name] = control;&#13;
    }&#13;
  };&#13;
&#13;
  form.$removeControl = function(control) {&#13;
    if (control.$name &amp;&amp; form[control.$name] === control) {&#13;
      delete form[control.$name];&#13;
    }&#13;
    forEach(errors, function(queue, validationToken) {&#13;
      form.$setValidity(validationToken, true, control);&#13;
    });&#13;
  };&#13;
&#13;
  form.$setValidity = function(validationToken, isValid, control) {&#13;
    var queue = errors[validationToken];&#13;
&#13;
    if (isValid) {&#13;
      if (queue) {&#13;
        arrayRemove(queue, control);&#13;
        if (!queue.length) {&#13;
          invalidCount--;&#13;
          if (!invalidCount) {&#13;
            toggleValidCss(isValid);&#13;
            form.$valid = true;&#13;
            form.$invalid = false;&#13;
          }&#13;
          errors[validationToken] = false;&#13;
          toggleValidCss(true, validationToken);&#13;
          parentForm.$setValidity(validationToken, true, form);&#13;
        }&#13;
      }&#13;
&#13;
    } else {&#13;
      if (!invalidCount) {&#13;
        toggleValidCss(isValid);&#13;
      }&#13;
      if (queue) {&#13;
        if (includes(queue, control)) return;&#13;
      } else {&#13;
        errors[validationToken] = queue = [];&#13;
        invalidCount++;&#13;
        toggleValidCss(false, validationToken);&#13;
        parentForm.$setValidity(validationToken, false, form);&#13;
      }&#13;
      queue.push(control);&#13;
&#13;
      form.$valid = false;&#13;
      form.$invalid = true;&#13;
    }&#13;
  };&#13;
&#13;
  form.$setDirty = function() {&#13;
    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);&#13;
    form.$dirty = true;&#13;
    form.$pristine = false;&#13;
  };&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-form&#13;
 * @restrict EAC&#13;
 *&#13;
 * @description&#13;
 * Nestable alias of {@link angular.module.ng.$compileProvider.directive.form `form`} directive. HTML&#13;
 * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a&#13;
 * sub-group of controls needs to be determined.&#13;
 *&#13;
 * @param {string=} ng-form|name Name of the form. If specified, the form controller will be published into&#13;
 *                       related scope, under this name.&#13;
 *&#13;
 */&#13;
&#13;
 /**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.form&#13;
 * @restrict E&#13;
 *&#13;
 * @description&#13;
 * Directive that instantiates&#13;
 * {@link angular.module.ng.$compileProvider.directive.form.FormController FormController}.&#13;
 *&#13;
 * If `name` attribute is specified, the form controller is published onto the current scope under&#13;
 * this name.&#13;
 *&#13;
 * # Alias: {@link angular.module.ng.$compileProvider.directive.ng-form `ng-form`}&#13;
 *&#13;
 * In angular forms can be nested. This means that the outer form is valid when all of the child&#13;
 * forms are valid as well. However browsers do not allow nesting of `&lt;form&gt;` elements, for this&#13;
 * reason angular provides {@link angular.module.ng.$compileProvider.directive.ng-form `ng-form`} alias&#13;
 * which behaves identical to `&lt;form&gt;` but allows form nesting.&#13;
 *&#13;
 *&#13;
 * # CSS classes&#13;
 *  - `ng-valid` Is set if the form is valid.&#13;
 *  - `ng-invalid` Is set if the form is invalid.&#13;
 *  - `ng-pristine` Is set if the form is pristine.&#13;
 *  - `ng-dirty` Is set if the form is dirty.&#13;
 *&#13;
 *&#13;
 * # Submitting a form and preventing default action&#13;
 *&#13;
 * Since the role of forms in client-side Angular applications is different than in classical&#13;
 * roundtrip apps, it is desirable for the browser not to translate the form submission into a full&#13;
 * page reload that sends the data to the server. Instead some javascript logic should be triggered&#13;
 * to handle the form submission in application specific way.&#13;
 *&#13;
 * For this reason, Angular prevents the default action (form submission to the server) unless the&#13;
 * `&lt;form&gt;` element has an `action` attribute specified.&#13;
 *&#13;
 * You can use one of the following two ways to specify what javascript method should be called when&#13;
 * a form is submitted:&#13;
 *&#13;
 * - ng-submit on the form element (add link to ng-submit)&#13;
 * - ng-click on the first button or input field of type submit (input[type=submit])&#13;
 *&#13;
 * To prevent double execution of the handler, use only one of ng-submit or ng-click. This is&#13;
 * because of the following form submission rules coming from the html spec:&#13;
 *&#13;
 * - If a form has only one input field then hitting enter in this field triggers form submit&#13;
 * (`ng-submit`)&#13;
 * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter&#13;
 * doesn't trigger submit&#13;
 * - if a form has one or more input fields and one or more buttons or input[type=submit] then&#13;
 * hitting enter in any of the input fields will trigger the click handler on the *first* button or&#13;
 * input[type=submit] (`ng-click`) *and* a submit handler on the enclosing form (`ng-submit`)&#13;
 *&#13;
 * @param {string=} name Name of the form. If specified, the form controller will be published into&#13;
 *                       related scope, under this name.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.userType = 'guest';&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
         userType: &lt;input name="input" ng-model="userType" required&gt;&#13;
         &lt;span class="error" ng-show="myForm.input.$error.REQUIRED"&gt;Required!&lt;/span&gt;&lt;br&gt;&#13;
         &lt;tt&gt;userType = {{userType}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.$error.REQUIRED = {{!!myForm.$error.REQUIRED}}&lt;/tt&gt;&lt;br&gt;&#13;
        &lt;/form&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should initialize to model', function() {&#13;
         expect(binding('userType')).toEqual('guest');&#13;
         expect(binding('myForm.input.$valid')).toEqual('true');&#13;
        });&#13;
&#13;
        it('should be invalid if empty', function() {&#13;
         input('userType').enter('');&#13;
         expect(binding('userType')).toEqual('');&#13;
         expect(binding('myForm.input.$valid')).toEqual('false');&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
var formDirectiveDir = {&#13;
  name: 'form',&#13;
  restrict: 'E',&#13;
  controller: FormController,&#13;
  compile: function() {&#13;
    return {&#13;
      pre: function(scope, formElement, attr, controller) {&#13;
        if (!attr.action) {&#13;
          formElement.bind('submit', function(event) {&#13;
            event.preventDefault();&#13;
          });&#13;
        }&#13;
&#13;
        var parentFormCtrl = formElement.parent().controller('form'),&#13;
            alias = attr.name || attr.ngForm;&#13;
&#13;
        if (alias) {&#13;
          scope[alias] = controller;&#13;
        }&#13;
        if (parentFormCtrl) {&#13;
          formElement.bind('$destroy', function() {&#13;
            parentFormCtrl.$removeControl(controller);&#13;
            if (alias) {&#13;
              scope[alias] = undefined;&#13;
            }&#13;
            extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards&#13;
          });&#13;
        }&#13;
      }&#13;
    };&#13;
  }&#13;
};&#13;
&#13;
var formDirective = valueFn(formDirectiveDir);&#13;
var ngFormDirective = valueFn(extend(copy(formDirectiveDir), {restrict: 'EAC'}));&#13;
&#13;
var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?$/;&#13;
var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;&#13;
var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;&#13;
&#13;
var inputType = {&#13;
&#13;
  /**&#13;
   * @ngdoc inputType&#13;
   * @name angular.module.ng.$compileProvider.directive.input.text&#13;
   *&#13;
   * @description&#13;
   * Standard HTML text input with angular data binding.&#13;
   *&#13;
   * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
   * @param {string=} name Property name of the form under which the control is published.&#13;
   * @param {string=} required Sets `required` validation error key if the value is not entered.&#13;
   * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than&#13;
   *    minlength.&#13;
   * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than&#13;
   *    maxlength.&#13;
   * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the&#13;
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for&#13;
   *    patterns defined as scope expressions.&#13;
   * @param {string=} ng-change Angular expression to be executed when input changes due to user&#13;
   *    interaction with the input element.&#13;
   *&#13;
   * @example&#13;
      &lt;doc:example&gt;&#13;
        &lt;doc:source&gt;&#13;
         &lt;script&gt;&#13;
           function Ctrl($scope) {&#13;
             $scope.text = 'guest';&#13;
             $scope.word = /^\w*$/;&#13;
           }&#13;
         &lt;/script&gt;&#13;
         &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
           Single word: &lt;input type="text" name="input" ng-model="text"&#13;
                               ng-pattern="word" required&gt;&#13;
           &lt;span class="error" ng-show="myForm.input.$error.required"&gt;&#13;
             Required!&lt;/span&gt;&#13;
           &lt;span class="error" ng-show="myForm.input.$error.pattern"&gt;&#13;
             Single word only!&lt;/span&gt;&#13;
&#13;
           &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;&#13;
          &lt;/form&gt;&#13;
        &lt;/doc:source&gt;&#13;
        &lt;doc:scenario&gt;&#13;
          it('should initialize to model', function() {&#13;
            expect(binding('text')).toEqual('guest');&#13;
            expect(binding('myForm.input.$valid')).toEqual('true');&#13;
          });&#13;
&#13;
          it('should be invalid if empty', function() {&#13;
            input('text').enter('');&#13;
            expect(binding('text')).toEqual('');&#13;
            expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
&#13;
          it('should be invalid if multi word', function() {&#13;
            input('text').enter('hello world');&#13;
            expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
        &lt;/doc:scenario&gt;&#13;
      &lt;/doc:example&gt;&#13;
   */&#13;
  'text': textInputType,&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc inputType&#13;
   * @name angular.module.ng.$compileProvider.directive.input.number&#13;
   *&#13;
   * @description&#13;
   * Text input with number validation and transformation. Sets the `number` validation&#13;
   * error if not a valid number.&#13;
   *&#13;
   * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
   * @param {string=} name Property name of the form under which the control is published.&#13;
   * @param {string=} min Sets the `min` validation error key if the value entered is less then `min`.&#13;
   * @param {string=} max Sets the `max` validation error key if the value entered is greater then `min`.&#13;
   * @param {string=} required Sets `required` validation error key if the value is not entered.&#13;
   * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than&#13;
   *    minlength.&#13;
   * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than&#13;
   *    maxlength.&#13;
   * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the&#13;
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for&#13;
   *    patterns defined as scope expressions.&#13;
   * @param {string=} ng-change Angular expression to be executed when input changes due to user&#13;
   *    interaction with the input element.&#13;
   *&#13;
   * @example&#13;
      &lt;doc:example&gt;&#13;
        &lt;doc:source&gt;&#13;
         &lt;script&gt;&#13;
           function Ctrl($scope) {&#13;
             $scope.value = 12;&#13;
           }&#13;
         &lt;/script&gt;&#13;
         &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
           Number: &lt;input type="number" name="input" ng-model="value"&#13;
                          min="0" max="99" required&gt;&#13;
           &lt;span class="error" ng-show="myForm.list.$error.required"&gt;&#13;
             Required!&lt;/span&gt;&#13;
           &lt;span class="error" ng-show="myForm.list.$error.number"&gt;&#13;
             Not valid number!&lt;/span&gt;&#13;
           &lt;tt&gt;value = {{value}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;&#13;
          &lt;/form&gt;&#13;
        &lt;/doc:source&gt;&#13;
        &lt;doc:scenario&gt;&#13;
          it('should initialize to model', function() {&#13;
           expect(binding('value')).toEqual('12');&#13;
           expect(binding('myForm.input.$valid')).toEqual('true');&#13;
          });&#13;
&#13;
          it('should be invalid if empty', function() {&#13;
           input('value').enter('');&#13;
           expect(binding('value')).toEqual('');&#13;
           expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
&#13;
          it('should be invalid if over max', function() {&#13;
           input('value').enter('123');&#13;
           expect(binding('value')).toEqual('');&#13;
           expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
        &lt;/doc:scenario&gt;&#13;
      &lt;/doc:example&gt;&#13;
   */&#13;
  'number': numberInputType,&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc inputType&#13;
   * @name angular.module.ng.$compileProvider.directive.input.url&#13;
   *&#13;
   * @description&#13;
   * Text input with URL validation. Sets the `url` validation error key if the content is not a&#13;
   * valid URL.&#13;
   *&#13;
   * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
   * @param {string=} name Property name of the form under which the control is published.&#13;
   * @param {string=} required Sets `required` validation error key if the value is not entered.&#13;
   * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than&#13;
   *    minlength.&#13;
   * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than&#13;
   *    maxlength.&#13;
   * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the&#13;
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for&#13;
   *    patterns defined as scope expressions.&#13;
   * @param {string=} ng-change Angular expression to be executed when input changes due to user&#13;
   *    interaction with the input element.&#13;
   *&#13;
   * @example&#13;
      &lt;doc:example&gt;&#13;
        &lt;doc:source&gt;&#13;
         &lt;script&gt;&#13;
           function Ctrl($scope) {&#13;
             $scope.text = 'http://google.com';&#13;
           }&#13;
         &lt;/script&gt;&#13;
         &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
           URL: &lt;input type="url" name="input" ng-model="text" required&gt;&#13;
           &lt;span class="error" ng-show="myForm.input.$error.required"&gt;&#13;
             Required!&lt;/span&gt;&#13;
           &lt;span class="error" ng-show="myForm.input.$error.url"&gt;&#13;
             Not valid url!&lt;/span&gt;&#13;
           &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;myForm.$error.url = {{!!myForm.$error.url}}&lt;/tt&gt;&lt;br/&gt;&#13;
          &lt;/form&gt;&#13;
        &lt;/doc:source&gt;&#13;
        &lt;doc:scenario&gt;&#13;
          it('should initialize to model', function() {&#13;
            expect(binding('text')).toEqual('http://google.com');&#13;
            expect(binding('myForm.input.$valid')).toEqual('true');&#13;
          });&#13;
&#13;
          it('should be invalid if empty', function() {&#13;
            input('text').enter('');&#13;
            expect(binding('text')).toEqual('');&#13;
            expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
&#13;
          it('should be invalid if not url', function() {&#13;
            input('text').enter('xxx');&#13;
            expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
        &lt;/doc:scenario&gt;&#13;
      &lt;/doc:example&gt;&#13;
   */&#13;
  'url': urlInputType,&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc inputType&#13;
   * @name angular.module.ng.$compileProvider.directive.input.email&#13;
   *&#13;
   * @description&#13;
   * Text input with email validation. Sets the `email` validation error key if not a valid email&#13;
   * address.&#13;
   *&#13;
   * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
   * @param {string=} name Property name of the form under which the control is published.&#13;
   * @param {string=} required Sets `required` validation error key if the value is not entered.&#13;
   * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than&#13;
   *    minlength.&#13;
   * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than&#13;
   *    maxlength.&#13;
   * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the&#13;
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for&#13;
   *    patterns defined as scope expressions.&#13;
   *&#13;
   * @example&#13;
      &lt;doc:example&gt;&#13;
        &lt;doc:source&gt;&#13;
         &lt;script&gt;&#13;
           function Ctrl($scope) {&#13;
             $scope.text = 'me@example.com';&#13;
           }&#13;
         &lt;/script&gt;&#13;
           &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
             Email: &lt;input type="email" name="input" ng-model="text" required&gt;&#13;
             &lt;span class="error" ng-show="myForm.input.$error.required"&gt;&#13;
               Required!&lt;/span&gt;&#13;
             &lt;span class="error" ng-show="myForm.input.$error.email"&gt;&#13;
               Not valid email!&lt;/span&gt;&#13;
             &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;&#13;
             &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
             &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;&#13;
             &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
             &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;&#13;
             &lt;tt&gt;myForm.$error.email = {{!!myForm.$error.email}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;/form&gt;&#13;
        &lt;/doc:source&gt;&#13;
        &lt;doc:scenario&gt;&#13;
          it('should initialize to model', function() {&#13;
            expect(binding('text')).toEqual('me@example.com');&#13;
            expect(binding('myForm.input.$valid')).toEqual('true');&#13;
          });&#13;
&#13;
          it('should be invalid if empty', function() {&#13;
            input('text').enter('');&#13;
            expect(binding('text')).toEqual('');&#13;
            expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
&#13;
          it('should be invalid if not email', function() {&#13;
            input('text').enter('xxx');&#13;
            expect(binding('myForm.input.$valid')).toEqual('false');&#13;
          });&#13;
        &lt;/doc:scenario&gt;&#13;
      &lt;/doc:example&gt;&#13;
   */&#13;
  'email': emailInputType,&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc inputType&#13;
   * @name angular.module.ng.$compileProvider.directive.input.radio&#13;
   *&#13;
   * @description&#13;
   * HTML radio button.&#13;
   *&#13;
   * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
   * @param {string} value The value to which the expression should be set when selected.&#13;
   * @param {string=} name Property name of the form under which the control is published.&#13;
   * @param {string=} ng-change Angular expression to be executed when input changes due to user&#13;
   *    interaction with the input element.&#13;
   *&#13;
   * @example&#13;
      &lt;doc:example&gt;&#13;
        &lt;doc:source&gt;&#13;
         &lt;script&gt;&#13;
           function Ctrl($scope) {&#13;
             $scope.color = 'blue';&#13;
           }&#13;
         &lt;/script&gt;&#13;
         &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
           &lt;input type="radio" ng-model="color" value="red"&gt;  Red &lt;br/&gt;&#13;
           &lt;input type="radio" ng-model="color" value="green"&gt; Green &lt;br/&gt;&#13;
           &lt;input type="radio" ng-model="color" value="blue"&gt; Blue &lt;br/&gt;&#13;
           &lt;tt&gt;color = {{color}}&lt;/tt&gt;&lt;br/&gt;&#13;
          &lt;/form&gt;&#13;
        &lt;/doc:source&gt;&#13;
        &lt;doc:scenario&gt;&#13;
          it('should change state', function() {&#13;
            expect(binding('color')).toEqual('blue');&#13;
&#13;
            input('color').select('red');&#13;
            expect(binding('color')).toEqual('red');&#13;
          });&#13;
        &lt;/doc:scenario&gt;&#13;
      &lt;/doc:example&gt;&#13;
   */&#13;
  'radio': radioInputType,&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc inputType&#13;
   * @name angular.module.ng.$compileProvider.directive.input.checkbox&#13;
   *&#13;
   * @description&#13;
   * HTML checkbox.&#13;
   *&#13;
   * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
   * @param {string=} name Property name of the form under which the control is published.&#13;
   * @param {string=} ng-true-value The value to which the expression should be set when selected.&#13;
   * @param {string=} ng-false-value The value to which the expression should be set when not selected.&#13;
   * @param {string=} ng-change Angular expression to be executed when input changes due to user&#13;
   *    interaction with the input element.&#13;
   *&#13;
   * @example&#13;
      &lt;doc:example&gt;&#13;
        &lt;doc:source&gt;&#13;
         &lt;script&gt;&#13;
           function Ctrl($scope) {&#13;
             $scope.value1 = true;&#13;
             $scope.value2 = 'YES'&#13;
           }&#13;
         &lt;/script&gt;&#13;
         &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
           Value1: &lt;input type="checkbox" ng-model="value1"&gt; &lt;br/&gt;&#13;
           Value2: &lt;input type="checkbox" ng-model="value2"&#13;
                          ng-true-value="YES" ng-false-value="NO"&gt; &lt;br/&gt;&#13;
           &lt;tt&gt;value1 = {{value1}}&lt;/tt&gt;&lt;br/&gt;&#13;
           &lt;tt&gt;value2 = {{value2}}&lt;/tt&gt;&lt;br/&gt;&#13;
          &lt;/form&gt;&#13;
        &lt;/doc:source&gt;&#13;
        &lt;doc:scenario&gt;&#13;
          it('should change state', function() {&#13;
            expect(binding('value1')).toEqual('true');&#13;
            expect(binding('value2')).toEqual('YES');&#13;
&#13;
            input('value1').check();&#13;
            input('value2').check();&#13;
            expect(binding('value1')).toEqual('false');&#13;
            expect(binding('value2')).toEqual('NO');&#13;
          });&#13;
        &lt;/doc:scenario&gt;&#13;
      &lt;/doc:example&gt;&#13;
   */&#13;
  'checkbox': checkboxInputType,&#13;
&#13;
  'hidden': noop,&#13;
  'button': noop,&#13;
  'submit': noop,&#13;
  'reset': noop&#13;
};&#13;
&#13;
&#13;
function isEmpty(value) {&#13;
  return isUndefined(value) || value === '' || value === null || value !== value;&#13;
}&#13;
&#13;
&#13;
function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {&#13;
&#13;
  var listener = function() {&#13;
    var value = trim(element.val());&#13;
&#13;
    if (ctrl.$viewValue !== value) {&#13;
      scope.$apply(function() {&#13;
        ctrl.$setViewValue(value);&#13;
      });&#13;
    }&#13;
  };&#13;
&#13;
  // if the browser does support "input" event, we are fine&#13;
  if ($sniffer.hasEvent('input')) {&#13;
    element.bind('input', listener);&#13;
  } else {&#13;
    var timeout;&#13;
&#13;
    element.bind('keydown', function(event) {&#13;
      var key = event.keyCode;&#13;
&#13;
      // ignore&#13;
      //    command            modifiers                   arrows&#13;
      if (key === 91 || (15 &lt; key &amp;&amp; key &lt; 19) || (37 &lt;= key &amp;&amp; key &lt;= 40)) return;&#13;
&#13;
      if (!timeout) {&#13;
        timeout = $browser.defer(function() {&#13;
          listener();&#13;
          timeout = null;&#13;
        });&#13;
      }&#13;
    });&#13;
&#13;
    // if user paste into input using mouse, we need "change" event to catch it&#13;
    element.bind('change', listener);&#13;
  }&#13;
&#13;
&#13;
  ctrl.$render = function() {&#13;
    element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);&#13;
  };&#13;
&#13;
  // pattern validator&#13;
  var pattern = attr.ngPattern,&#13;
      patternValidator;&#13;
&#13;
  var validate = function(regexp, value) {&#13;
    if (isEmpty(value) || regexp.test(value)) {&#13;
      ctrl.$setValidity('pattern', true);&#13;
      return value;&#13;
    } else {&#13;
      ctrl.$setValidity('pattern', false);&#13;
      return undefined;&#13;
    }&#13;
  };&#13;
&#13;
  if (pattern) {&#13;
    if (pattern.match(/^\/(.*)\/$/)) {&#13;
      pattern = new RegExp(pattern.substr(1, pattern.length - 2));&#13;
      patternValidator = function(value) {&#13;
        return validate(pattern, value)&#13;
      };&#13;
    } else {&#13;
      patternValidator = function(value) {&#13;
        var patternObj = scope.$eval(pattern);&#13;
&#13;
        if (!patternObj || !patternObj.test) {&#13;
          throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);&#13;
        }&#13;
        return validate(patternObj, value);&#13;
      };&#13;
    }&#13;
&#13;
    ctrl.$formatters.push(patternValidator);&#13;
    ctrl.$parsers.push(patternValidator);&#13;
  }&#13;
&#13;
  // min length validator&#13;
  if (attr.ngMinlength) {&#13;
    var minlength = int(attr.ngMinlength);&#13;
    var minLengthValidator = function(value) {&#13;
      if (!isEmpty(value) &amp;&amp; value.length &lt; minlength) {&#13;
        ctrl.$setValidity('minlength', false);&#13;
        return undefined;&#13;
      } else {&#13;
        ctrl.$setValidity('minlength', true);&#13;
        return value;&#13;
      }&#13;
    };&#13;
&#13;
    ctrl.$parsers.push(minLengthValidator);&#13;
    ctrl.$formatters.push(minLengthValidator);&#13;
  }&#13;
&#13;
  // max length validator&#13;
  if (attr.ngMaxlength) {&#13;
    var maxlength = int(attr.ngMaxlength);&#13;
    var maxLengthValidator = function(value) {&#13;
      if (!isEmpty(value) &amp;&amp; value.length &gt; maxlength) {&#13;
        ctrl.$setValidity('maxlength', false);&#13;
        return undefined;&#13;
      } else {&#13;
        ctrl.$setValidity('maxlength', true);&#13;
        return value;&#13;
      }&#13;
    };&#13;
&#13;
    ctrl.$parsers.push(maxLengthValidator);&#13;
    ctrl.$formatters.push(maxLengthValidator);&#13;
  }&#13;
};&#13;
&#13;
function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {&#13;
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);&#13;
&#13;
  ctrl.$parsers.push(function(value) {&#13;
    var empty = isEmpty(value);&#13;
    if (empty || NUMBER_REGEXP.test(value)) {&#13;
      ctrl.$setValidity('number', true);&#13;
      return value === '' ? null : (empty ? value : parseFloat(value));&#13;
    } else {&#13;
      ctrl.$setValidity('number', false);&#13;
      return undefined;&#13;
    }&#13;
  });&#13;
&#13;
  ctrl.$formatters.push(function(value) {&#13;
    return isEmpty(value) ? '' : '' + value;&#13;
  });&#13;
&#13;
  if (attr.min) {&#13;
    var min = parseFloat(attr.min);&#13;
    var minValidator = function(value) {&#13;
      if (!isEmpty(value) &amp;&amp; value &lt; min) {&#13;
        ctrl.$setValidity('min', false);&#13;
        return undefined;&#13;
      } else {&#13;
        ctrl.$setValidity('min', true);&#13;
        return value;&#13;
      }&#13;
    };&#13;
&#13;
    ctrl.$parsers.push(minValidator);&#13;
    ctrl.$formatters.push(minValidator);&#13;
  }&#13;
&#13;
  if (attr.max) {&#13;
    var max = parseFloat(attr.max);&#13;
    var maxValidator = function(value) {&#13;
      if (!isEmpty(value) &amp;&amp; value &gt; max) {&#13;
        ctrl.$setValidity('max', false);&#13;
        return undefined;&#13;
      } else {&#13;
        ctrl.$setValidity('max', true);&#13;
        return value;&#13;
      }&#13;
    };&#13;
&#13;
    ctrl.$parsers.push(maxValidator);&#13;
    ctrl.$formatters.push(maxValidator);&#13;
  }&#13;
&#13;
  ctrl.$formatters.push(function(value) {&#13;
&#13;
    if (isEmpty(value) || isNumber(value)) {&#13;
      ctrl.$setValidity('number', true);&#13;
      return value;&#13;
    } else {&#13;
      ctrl.$setValidity('number', false);&#13;
      return undefined;&#13;
    }&#13;
  });&#13;
}&#13;
&#13;
function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {&#13;
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);&#13;
&#13;
  var urlValidator = function(value) {&#13;
    if (isEmpty(value) || URL_REGEXP.test(value)) {&#13;
      ctrl.$setValidity('url', true);&#13;
      return value;&#13;
    } else {&#13;
      ctrl.$setValidity('url', false);&#13;
      return undefined;&#13;
    }&#13;
  };&#13;
&#13;
  ctrl.$formatters.push(urlValidator);&#13;
  ctrl.$parsers.push(urlValidator);&#13;
}&#13;
&#13;
function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {&#13;
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);&#13;
&#13;
  var emailValidator = function(value) {&#13;
    if (isEmpty(value) || EMAIL_REGEXP.test(value)) {&#13;
      ctrl.$setValidity('email', true);&#13;
      return value;&#13;
    } else {&#13;
      ctrl.$setValidity('email', false);&#13;
      return undefined;&#13;
    }&#13;
  };&#13;
&#13;
  ctrl.$formatters.push(emailValidator);&#13;
  ctrl.$parsers.push(emailValidator);&#13;
}&#13;
&#13;
function radioInputType(scope, element, attr, ctrl) {&#13;
  // correct the name&#13;
  element.attr('name', attr.id + '@' + attr.name);&#13;
&#13;
  element.bind('click', function() {&#13;
    if (element[0].checked) {&#13;
      scope.$apply(function() {&#13;
        ctrl.$setViewValue(attr.value);&#13;
      });&#13;
    };&#13;
  });&#13;
&#13;
  ctrl.$render = function() {&#13;
    var value = attr.value;&#13;
    element[0].checked = (value == ctrl.$viewValue);&#13;
  };&#13;
&#13;
  attr.$observe('value', ctrl.$render);&#13;
}&#13;
&#13;
function checkboxInputType(scope, element, attr, ctrl) {&#13;
  var trueValue = attr.ngTrueValue,&#13;
      falseValue = attr.ngFalseValue;&#13;
&#13;
  if (!isString(trueValue)) trueValue = true;&#13;
  if (!isString(falseValue)) falseValue = false;&#13;
&#13;
  element.bind('click', function() {&#13;
    scope.$apply(function() {&#13;
      ctrl.$setViewValue(element[0].checked);&#13;
    });&#13;
  });&#13;
&#13;
  ctrl.$render = function() {&#13;
    element[0].checked = ctrl.$viewValue;&#13;
  };&#13;
&#13;
  ctrl.$formatters.push(function(value) {&#13;
    return value === trueValue;&#13;
  });&#13;
&#13;
  ctrl.$parsers.push(function(value) {&#13;
    return value ? trueValue : falseValue;&#13;
  });&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.textarea&#13;
 *&#13;
 * @description&#13;
 * HTML textarea element control with angular data-binding. The data-binding and validation&#13;
 * properties of this element are exactly the same as those of the&#13;
 * {@link angular.module.ng.$compileProvider.directive.input input element}.&#13;
 *&#13;
 * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
 * @param {string=} name Property name of the form under which the control is published.&#13;
 * @param {string=} required Sets `required` validation error key if the value is not entered.&#13;
 * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than&#13;
 *    minlength.&#13;
 * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than&#13;
 *    maxlength.&#13;
 * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the&#13;
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for&#13;
 *    patterns defined as scope expressions.&#13;
 * @param {string=} ng-change Angular expression to be executed when input changes due to user&#13;
 *    interaction with the input element.&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.input&#13;
 * @restrict E&#13;
 *&#13;
 * @description&#13;
 * HTML input element control with angular data-binding. Input control follows HTML5 input types&#13;
 * and polyfills the HTML5 validation behavior for older browsers.&#13;
 *&#13;
 * @param {string} ng-model Assignable angular expression to data-bind to.&#13;
 * @param {string=} name Property name of the form under which the control is published.&#13;
 * @param {string=} required Sets `required` validation error key if the value is not entered.&#13;
 * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than&#13;
 *    minlength.&#13;
 * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than&#13;
 *    maxlength.&#13;
 * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the&#13;
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for&#13;
 *    patterns defined as scope expressions.&#13;
 * @param {string=} ng-change Angular expression to be executed when input changes due to user&#13;
 *    interaction with the input element.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.user = {name: 'guest', last: 'visitor'};&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         &lt;form name="myForm"&gt;&#13;
           User name: &lt;input type="text" name="userName" ng-model="user.name" required&gt;&#13;
           &lt;span class="error" ng-show="myForm.userName.$error.required"&gt;&#13;
             Required!&lt;/span&gt;&lt;br&gt;&#13;
           Last name: &lt;input type="text" name="lastName" ng-model="user.last"&#13;
             ng-minlength="3" ng-maxlength="10"&gt;&#13;
           &lt;span class="error" ng-show="myForm.lastName.$error.minlength"&gt;&#13;
             Too short!&lt;/span&gt;&#13;
           &lt;span class="error" ng-show="myForm.lastName.$error.maxlength"&gt;&#13;
             Too long!&lt;/span&gt;&lt;br&gt;&#13;
         &lt;/form&gt;&#13;
         &lt;hr&gt;&#13;
         &lt;tt&gt;user = {{user}}&lt;/tt&gt;&lt;br/&gt;&#13;
         &lt;tt&gt;myForm.userName.$valid = {{myForm.userName.$valid}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.userName.$error = {{myForm.userName.$error}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.lastName.$valid = {{myForm.lastName.$valid}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.userName.$error = {{myForm.lastName.$error}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.$error.minlength = {{!!myForm.$error.minlength}}&lt;/tt&gt;&lt;br&gt;&#13;
         &lt;tt&gt;myForm.$error.maxlength = {{!!myForm.$error.maxlength}}&lt;/tt&gt;&lt;br&gt;&#13;
       &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should initialize to model', function() {&#13;
          expect(binding('user')).toEqual('{"name":"guest","last":"visitor"}');&#13;
          expect(binding('myForm.userName.$valid')).toEqual('true');&#13;
          expect(binding('myForm.$valid')).toEqual('true');&#13;
        });&#13;
&#13;
        it('should be invalid if empty when required', function() {&#13;
          input('user.name').enter('');&#13;
          expect(binding('user')).toEqual('{"last":"visitor"}');&#13;
          expect(binding('myForm.userName.$valid')).toEqual('false');&#13;
          expect(binding('myForm.$valid')).toEqual('false');&#13;
        });&#13;
&#13;
        it('should be valid if empty when min length is set', function() {&#13;
          input('user.last').enter('');&#13;
          expect(binding('user')).toEqual('{"name":"guest","last":""}');&#13;
          expect(binding('myForm.lastName.$valid')).toEqual('true');&#13;
          expect(binding('myForm.$valid')).toEqual('true');&#13;
        });&#13;
&#13;
        it('should be invalid if less than required min length', function() {&#13;
          input('user.last').enter('xx');&#13;
          expect(binding('user')).toEqual('{"name":"guest"}');&#13;
          expect(binding('myForm.lastName.$valid')).toEqual('false');&#13;
          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);&#13;
          expect(binding('myForm.$valid')).toEqual('false');&#13;
        });&#13;
&#13;
        it('should be invalid if longer than max length', function() {&#13;
          input('user.last').enter('some ridiculously long name');&#13;
          expect(binding('user'))&#13;
            .toEqual('{"name":"guest"}');&#13;
          expect(binding('myForm.lastName.$valid')).toEqual('false');&#13;
          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);&#13;
          expect(binding('myForm.$valid')).toEqual('false');&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
var inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {&#13;
  return {&#13;
    restrict: 'E',&#13;
    require: '?ngModel',&#13;
    link: function(scope, element, attr, ctrl) {&#13;
      if (ctrl) {&#13;
        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,&#13;
                                                            $browser);&#13;
      }&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
var VALID_CLASS = 'ng-valid',&#13;
    INVALID_CLASS = 'ng-invalid',&#13;
    PRISTINE_CLASS = 'ng-pristine',&#13;
    DIRTY_CLASS = 'ng-dirty';&#13;
&#13;
/**&#13;
 * @ngdoc object&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-model.NgModelController&#13;
 *&#13;
 * @property {string} $viewValue Actual string value in the view.&#13;
 * @property {*} $modelValue The value in the model, that the control is bound to.&#13;
 * @property {Array.&lt;Function&gt;} $parsers Whenever the control reads value from the DOM, it executes&#13;
 *     all of these functions to sanitize / convert the value as well as validate.&#13;
 *&#13;
 * @property {Array.&lt;Function&gt;} $formatters Whenever the model value changes, it executes all of&#13;
 *     these functions to convert the value as well as validate.&#13;
 *&#13;
 * @property {Object} $error An bject hash with all errors as keys.&#13;
 *&#13;
 * @property {boolean} $pristine True if user has not interacted with the control yet.&#13;
 * @property {boolean} $dirty True if user has already interacted with the control.&#13;
 * @property {boolean} $valid True if there is no error.&#13;
 * @property {boolean} $invalid True if at least one error on the control.&#13;
 *&#13;
 * @description&#13;
 *&#13;
 */&#13;
var NgModelController = ['$scope', '$exceptionHandler', '$attrs', 'ngModel', '$element',&#13;
    function($scope, $exceptionHandler, $attr, ngModel, $element) {&#13;
  this.$viewValue = Number.NaN;&#13;
  this.$modelValue = Number.NaN;&#13;
  this.$parsers = [];&#13;
  this.$formatters = [];&#13;
  this.$viewChangeListeners = [];&#13;
  this.$pristine = true;&#13;
  this.$dirty = false;&#13;
  this.$valid = true;&#13;
  this.$invalid = false;&#13;
  this.$render = noop;&#13;
  this.$name = $attr.name;&#13;
&#13;
  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,&#13;
      invalidCount = 0, // used to easily determine if we are valid&#13;
      $error = this.$error = {}; // keep invalid keys here&#13;
&#13;
&#13;
  // Setup initial state of the control&#13;
  $element.addClass(PRISTINE_CLASS);&#13;
  toggleValidCss(true);&#13;
&#13;
  // convenience method for easy toggling of classes&#13;
  function toggleValidCss(isValid, validationErrorKey) {&#13;
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';&#13;
    $element.&#13;
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).&#13;
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);&#13;
  }&#13;
&#13;
  /**&#13;
   * @ngdoc function&#13;
   * @name angular.module.ng.$compileProvider.directive.ng-model.NgModelController#$setValidity&#13;
   * @methodOf angular.module.ng.$compileProvider.directive.ng-model.NgModelController&#13;
   *&#13;
   * @description&#13;
   * Change the validity state, and notifies the form when the control changes validity. (i.e. it&#13;
   * does not notify form if given validator is already marked as invalid).&#13;
   *&#13;
   * This method should be called by validators - i.e. the parser or formatter functions.&#13;
   *&#13;
   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign&#13;
   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.&#13;
   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case&#13;
   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`&#13;
   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .&#13;
   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).&#13;
   */&#13;
  this.$setValidity = function(validationErrorKey, isValid) {&#13;
    if ($error[validationErrorKey] === !isValid) return;&#13;
&#13;
    if (isValid) {&#13;
      if ($error[validationErrorKey]) invalidCount--;&#13;
      if (!invalidCount) {&#13;
        toggleValidCss(true);&#13;
        this.$valid = true;&#13;
        this.$invalid = false;&#13;
      }&#13;
    } else {&#13;
      toggleValidCss(false)&#13;
      this.$invalid = true;&#13;
      this.$valid = false;&#13;
      invalidCount++;&#13;
    }&#13;
&#13;
    $error[validationErrorKey] = !isValid;&#13;
    toggleValidCss(isValid, validationErrorKey);&#13;
&#13;
    parentForm.$setValidity(validationErrorKey, isValid, this);&#13;
  };&#13;
&#13;
&#13;
  /**&#13;
   * @ngdoc function&#13;
   * @name angular.module.ng.$compileProvider.directive.ng-model.NgModelController#$setViewValue&#13;
   * @methodOf angular.module.ng.$compileProvider.directive.ng-model.NgModelController&#13;
   *&#13;
   * @description&#13;
   * Read a value from view.&#13;
   *&#13;
   * This method should be called from within a DOM event handler.&#13;
   * For example {@link angular.module.ng.$compileProvider.directive.input input} or&#13;
   * {@link angular.module.ng.$compileProvider.directive.select select} directives call it.&#13;
   *&#13;
   * It internally calls all `formatters` and if resulted value is valid, updates the model and&#13;
   * calls all registered change listeners.&#13;
   *&#13;
   * @param {string} value Value from the view.&#13;
   */&#13;
  this.$setViewValue = function(value) {&#13;
    this.$viewValue = value;&#13;
&#13;
    // change to dirty&#13;
    if (this.$pristine) {&#13;
      this.$dirty = true;&#13;
      this.$pristine = false;&#13;
      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);&#13;
      parentForm.$setDirty();&#13;
    }&#13;
&#13;
    forEach(this.$parsers, function(fn) {&#13;
      value = fn(value);&#13;
    });&#13;
&#13;
    if (this.$modelValue !== value) {&#13;
      this.$modelValue = value;&#13;
      ngModel(value);&#13;
      forEach(this.$viewChangeListeners, function(listener) {&#13;
        try {&#13;
          listener();&#13;
        } catch(e) {&#13;
          $exceptionHandler(e);&#13;
        }&#13;
      })&#13;
    }&#13;
  };&#13;
&#13;
  // model -&gt; value&#13;
  var ctrl = this;&#13;
  $scope.$watch(function() {&#13;
    return ngModel();&#13;
  }, function(value) {&#13;
&#13;
    // ignore change from view&#13;
    if (ctrl.$modelValue === value) return;&#13;
&#13;
    var formatters = ctrl.$formatters,&#13;
        idx = formatters.length;&#13;
&#13;
    ctrl.$modelValue = value;&#13;
    while(idx--) {&#13;
      value = formatters[idx](value);&#13;
    }&#13;
&#13;
    if (ctrl.$viewValue !== value) {&#13;
      ctrl.$viewValue = value;&#13;
      ctrl.$render();&#13;
    }&#13;
  });&#13;
}];&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-model&#13;
 *&#13;
 * @element input&#13;
 *&#13;
 * @description&#13;
 * Is directive that tells Angular to do two-way data binding. It works together with `input`,&#13;
 * `select`, `textarea`. You can easily write your own directives to use `ng-model` as well.&#13;
 *&#13;
 * `ng-model` is responsible for:&#13;
 *&#13;
 * - binding the view into the model, which other directives such as `input`, `textarea` or `select`&#13;
 *   require,&#13;
 * - providing validation behavior (i.e. required, number, email, url),&#13;
 * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),&#13;
 * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),&#13;
 * - register the control with parent {@link angular.module.ng.$compileProvider.directive.form form}.&#13;
 *&#13;
 * For basic examples, how to use `ng-model`, see:&#13;
 *&#13;
 *  - {@link angular.module.ng.$compileProvider.directive.input input}&#13;
 *    - {@link angular.module.ng.$compileProvider.directive.input.text text}&#13;
 *    - {@link angular.module.ng.$compileProvider.directive.input.checkbox checkbox}&#13;
 *    - {@link angular.module.ng.$compileProvider.directive.input.radio radio}&#13;
 *    - {@link angular.module.ng.$compileProvider.directive.input.number number}&#13;
 *    - {@link angular.module.ng.$compileProvider.directive.input.email email}&#13;
 *    - {@link angular.module.ng.$compileProvider.directive.input.url url}&#13;
 *  - {@link angular.module.ng.$compileProvider.directive.select select}&#13;
 *  - {@link angular.module.ng.$compileProvider.directive.textarea textarea}&#13;
 *&#13;
 */&#13;
var ngModelDirective = [function() {&#13;
  return {&#13;
    inject: {&#13;
      ngModel: 'accessor'&#13;
    },&#13;
    require: ['ngModel', '^?form'],&#13;
    controller: NgModelController,&#13;
    link: function(scope, element, attr, ctrls) {&#13;
      // notify others, especially parent forms&#13;
&#13;
      var modelCtrl = ctrls[0],&#13;
          formCtrl = ctrls[1] || nullFormCtrl;&#13;
&#13;
      formCtrl.$addControl(modelCtrl);&#13;
&#13;
      element.bind('$destroy', function() {&#13;
        formCtrl.$removeControl(modelCtrl);&#13;
      });&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-change&#13;
 * @restrict E&#13;
 *&#13;
 * @description&#13;
 * Evaluate given expression when user changes the input.&#13;
 * The expression is not evaluated when the value change is coming from the model.&#13;
 *&#13;
 * Note, this directive requires `ng-model` to be present.&#13;
 *&#13;
 * @element input&#13;
 *&#13;
 * @example&#13;
 * &lt;doc:example&gt;&#13;
 *   &lt;doc:source&gt;&#13;
 *     &lt;script&gt;&#13;
 *       function Controller($scope) {&#13;
 *         $scope.counter = 0;&#13;
 *         $scope.change = function() {&#13;
 *           $scope.counter++;&#13;
 *         };&#13;
 *       }&#13;
 *     &lt;/script&gt;&#13;
 *     &lt;div ng-controller="Controller"&gt;&#13;
 *       &lt;input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" /&gt;&#13;
 *       &lt;input type="checkbox" ng-model="confirmed" id="ng-change-example2" /&gt;&#13;
 *       &lt;label for="ng-change-example2"&gt;Confirmed&lt;/label&gt;&lt;br /&gt;&#13;
 *       debug = {{confirmed}}&lt;br /&gt;&#13;
 *       counter = {{counter}}&#13;
 *     &lt;/div&gt;&#13;
 *   &lt;/doc:source&gt;&#13;
 *   &lt;doc:scenario&gt;&#13;
 *     it('should evaluate the expression if changing from view', function() {&#13;
 *       expect(binding('counter')).toEqual('0');&#13;
 *       element('#ng-change-example1').click();&#13;
 *       expect(binding('counter')).toEqual('1');&#13;
 *       expect(binding('confirmed')).toEqual('true');&#13;
 *     });&#13;
 *&#13;
 *     it('should not evaluate the expression if changing from model', function() {&#13;
 *       element('#ng-change-example2').click();&#13;
 *       expect(binding('counter')).toEqual('0');&#13;
 *       expect(binding('confirmed')).toEqual('true');&#13;
 *     });&#13;
 *   &lt;/doc:scenario&gt;&#13;
 * &lt;/doc:example&gt;&#13;
 */&#13;
var ngChangeDirective = valueFn({&#13;
  require: 'ngModel',&#13;
  link: function(scope, element, attr, ctrl) {&#13;
    ctrl.$viewChangeListeners.push(function() {&#13;
      scope.$eval(attr.ngChange);&#13;
    });&#13;
  }&#13;
});&#13;
&#13;
&#13;
var requiredDirective = [function() {&#13;
  return {&#13;
    require: '?ngModel',&#13;
    link: function(scope, elm, attr, ctrl) {&#13;
      if (!ctrl) return;&#13;
&#13;
      var validator = function(value) {&#13;
        if (attr.required &amp;&amp; (isEmpty(value) || value === false)) {&#13;
          ctrl.$setValidity('required', false);&#13;
          return;&#13;
        } else {&#13;
          ctrl.$setValidity('required', true);&#13;
          return value;&#13;
        }&#13;
      };&#13;
&#13;
      ctrl.$formatters.push(validator);&#13;
      ctrl.$parsers.unshift(validator);&#13;
&#13;
      attr.$observe('required', function() {&#13;
        validator(ctrl.$viewValue);&#13;
      });&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-list&#13;
 *&#13;
 * @description&#13;
 * Text input that converts between comma-seperated string into an array of strings.&#13;
 *&#13;
 * @element input&#13;
 * @param {string=} ng-list optional delimiter that should be used to split the value. If&#13;
 *   specified in form `/something/` then the value will be converted into a regular expression.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.names = ['igor', 'misko', 'vojta'];&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;form name="myForm" ng-controller="Ctrl"&gt;&#13;
         List: &lt;input name="namesInput" ng-model="names" ng-list required&gt;&#13;
         &lt;span class="error" ng-show="myForm.list.$error.required"&gt;&#13;
           Required!&lt;/span&gt;&#13;
         &lt;tt&gt;names = {{names}}&lt;/tt&gt;&lt;br/&gt;&#13;
         &lt;tt&gt;myForm.namesInput.$valid = {{myForm.namesInput.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
         &lt;tt&gt;myForm.namesInput.$error = {{myForm.namesInput.$error}}&lt;/tt&gt;&lt;br/&gt;&#13;
         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;&#13;
         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;&#13;
        &lt;/form&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should initialize to model', function() {&#13;
          expect(binding('names')).toEqual('["igor","misko","vojta"]');&#13;
          expect(binding('myForm.namesInput.$valid')).toEqual('true');&#13;
        });&#13;
&#13;
        it('should be invalid if empty', function() {&#13;
          input('names').enter('');&#13;
          expect(binding('names')).toEqual('[]');&#13;
          expect(binding('myForm.namesInput.$valid')).toEqual('false');&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
var ngListDirective = function() {&#13;
  return {&#13;
    require: 'ngModel',&#13;
    link: function(scope, element, attr, ctrl) {&#13;
      var match = /\/(.*)\//.exec(attr.ngList),&#13;
          separator = match &amp;&amp; new RegExp(match[1]) || attr.ngList || ',';&#13;
&#13;
      var parse = function(viewValue) {&#13;
        var list = [];&#13;
&#13;
        if (viewValue) {&#13;
          forEach(viewValue.split(separator), function(value) {&#13;
            if (value) list.push(trim(value));&#13;
          });&#13;
        }&#13;
&#13;
        return list;&#13;
      };&#13;
&#13;
      ctrl.$parsers.push(parse);&#13;
      ctrl.$formatters.push(function(value) {&#13;
        if (isArray(value) &amp;&amp; !equals(parse(ctrl.$viewValue), value)) {&#13;
          return value.join(', ');&#13;
        }&#13;
&#13;
        return undefined;&#13;
      });&#13;
    }&#13;
  };&#13;
};&#13;
&#13;
&#13;
var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;&#13;
&#13;
var ngValueDirective = [function() {&#13;
  return {&#13;
    priority: 100,&#13;
    compile: function(tpl, attr) {&#13;
      if (CONSTANT_VALUE_REGEXP.test(attr.ngValue)) {&#13;
        return function(scope) {&#13;
          attr.$set('value', scope.$eval(attr.ngValue));&#13;
        };&#13;
      } else {&#13;
        return function(scope, elm, attr) {&#13;
          attr.$$observers.value = [];&#13;
          scope.$watch(attr.ngValue, function(value) {&#13;
            attr.$set('value', value, false);&#13;
          });&#13;
        };&#13;
      }&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-bind&#13;
 *&#13;
 * @description&#13;
 * The `ng-bind` attribute tells Angular to replace the text content of the specified HTML element&#13;
 * with the value of a given expression, and to update the text content when the value of that&#13;
 * expression changes.&#13;
 *&#13;
 * Typically, you don't use `ng-bind` directly, but instead you use the double curly markup like&#13;
 * `{{ expression }}` and let the Angular compiler transform it to&#13;
 * `&lt;span ng-bind="expression"&gt;&lt;/span&gt;` when the template is compiled.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-bind {@link guide/dev_guide.expressions Expression} to evaluate.&#13;
 *&#13;
 * @example&#13;
 * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.name = 'Whirled';&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         Enter name: &lt;input type="text" ng-model="name"&gt;&lt;br&gt;&#13;
         Hello &lt;span ng-bind="name"&gt;&lt;/span&gt;!&#13;
       &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-bind', function() {&#13;
         expect(using('.doc-example-live').binding('name')).toBe('Whirled');&#13;
         using('.doc-example-live').input('name').enter('world');&#13;
         expect(using('.doc-example-live').binding('name')).toBe('world');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngBindDirective = ngDirective(function(scope, element, attr) {&#13;
  element.addClass('ng-binding').data('$binding', attr.ngBind);&#13;
  scope.$watch(attr.ngBind, function(value) {&#13;
    element.text(value == undefined ? '' : value);&#13;
  });&#13;
});&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-bind-html-unsafe&#13;
 *&#13;
 * @description&#13;
 * Creates a binding that will innerHTML the result of evaluating the `expression` into the current&#13;
 * element. *The innerHTML-ed content will not be sanitized!* You should use this directive only if&#13;
 * {@link angular.module.ng.$compileProvider.directive.ng-bind-html ng-bind-html} directive is too&#13;
 * restrictive and when you absolutely trust the source of the content you are binding to.&#13;
 *&#13;
 * See {@link angular.module.ng.$sanitize $sanitize} docs for examples.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-bind-html-unsafe {@link guide/dev_guide.expressions Expression} to evaluate.&#13;
 */&#13;
var ngBindHtmlUnsafeDirective = ngDirective(function(scope, element, attr) {&#13;
  element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);&#13;
  scope.$watch(attr.ngBindHtmlUnsafe, function(value) {&#13;
    element.html(value == undefined ? '' : value);&#13;
  });&#13;
});&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-bind-html&#13;
 *&#13;
 * @description&#13;
 * Creates a binding that will sanitize the result of evaluating the `expression` with the&#13;
 * {@link angular.module.ng.$sanitize $sanitize} service and innerHTML the result into the current&#13;
 * element.&#13;
 *&#13;
 * See {@link angular.module.ng.$sanitize $sanitize} docs for examples.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-bind-html {@link guide/dev_guide.expressions Expression} to evaluate.&#13;
 */&#13;
var ngBindHtmlDirective = ['$sanitize', function($sanitize) {&#13;
  return function(scope, element, attr) {&#13;
    element.addClass('ng-binding').data('$binding', attr.ngBindHtml);&#13;
    scope.$watch(attr.ngBindHtml, function(value) {&#13;
      if (value = $sanitize(value)) {&#13;
        element.html(value);&#13;
      }&#13;
    });&#13;
  }&#13;
}];&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-bind-template&#13;
 *&#13;
 * @description&#13;
 * The `ng-bind-template` attribute specifies that the element&#13;
 * text should be replaced with the template in ng-bind-template.&#13;
 * Unlike ng-bind the ng-bind-template can contain multiple `{{` `}}`&#13;
 * expressions. (This is required since some HTML elements&#13;
 * can not have SPAN elements such as TITLE, or OPTION to name a few.)&#13;
 *&#13;
 * @element ANY&#13;
 * @param {string} ng-bind-template template of form&#13;
 *   &lt;tt&gt;{{&lt;/tt&gt; &lt;tt&gt;expression&lt;/tt&gt; &lt;tt&gt;}}&lt;/tt&gt; to eval.&#13;
 *&#13;
 * @example&#13;
 * Try it here: enter text in text box and watch the greeting change.&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.salutation = 'Hello';&#13;
           $scope.name = 'World';&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
        Salutation: &lt;input type="text" ng-model="salutation"&gt;&lt;br&gt;&#13;
        Name: &lt;input type="text" ng-model="name"&gt;&lt;br&gt;&#13;
        &lt;pre ng-bind-template="{{salutation}} {{name}}!"&gt;&lt;/pre&gt;&#13;
       &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-bind', function() {&#13;
         expect(using('.doc-example-live').binding('salutation')).&#13;
           toBe('Hello');&#13;
         expect(using('.doc-example-live').binding('name')).&#13;
           toBe('World');&#13;
         using('.doc-example-live').input('salutation').enter('Greetings');&#13;
         using('.doc-example-live').input('name').enter('user');&#13;
         expect(using('.doc-example-live').binding('salutation')).&#13;
           toBe('Greetings');&#13;
         expect(using('.doc-example-live').binding('name')).&#13;
           toBe('user');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngBindTemplateDirective = ['$interpolate', function($interpolate) {&#13;
  return function(scope, element, attr) {&#13;
    // TODO: move this to scenario runner&#13;
    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));&#13;
    element.addClass('ng-binding').data('$binding', interpolateFn);&#13;
    attr.$observe('ngBindTemplate', function(value) {&#13;
      element.text(value);&#13;
    });&#13;
  }&#13;
}];&#13;
&#13;
function classDirective(name, selector) {&#13;
  name = 'ngClass' + name;&#13;
  return ngDirective(function(scope, element, attr) {&#13;
    scope.$watch(attr[name], function(newVal, oldVal) {&#13;
      if (selector === true || scope.$index % 2 === selector) {&#13;
        if (oldVal &amp;&amp; (newVal !== oldVal)) {&#13;
           if (isObject(oldVal) &amp;&amp; !isArray(oldVal))&#13;
             oldVal = map(oldVal, function(v, k) { if (v) return k });&#13;
           element.removeClass(isArray(oldVal) ? oldVal.join(' ') : oldVal);&#13;
         }&#13;
         if (isObject(newVal) &amp;&amp; !isArray(newVal))&#13;
            newVal = map(newVal, function(v, k) { if (v) return k });&#13;
         if (newVal) element.addClass(isArray(newVal) ? newVal.join(' ') : newVal);      }&#13;
    }, true);&#13;
  });&#13;
}&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-class&#13;
 *&#13;
 * @description&#13;
 * The `ng-class` allows you to set CSS class on HTML element dynamically by databinding an&#13;
 * expression that represents all classes to be added.&#13;
 *&#13;
 * The directive won't add duplicate classes if a particular class was already set.&#13;
 *&#13;
 * When the expression changes, the previously added classes are removed and only then the classes&#13;
 * new classes are added.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-class {@link guide/dev_guide.expressions Expression} to eval. The result&#13;
 *   of the evaluation can be a string representing space delimited class&#13;
 *   names, an array, or a map of class names to boolean values.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
      &lt;input type="button" value="set" ng-click="myVar='ng-invalid'"&gt;&#13;
      &lt;input type="button" value="clear" ng-click="myVar=''"&gt;&#13;
      &lt;br&gt;&#13;
      &lt;span ng-class="myVar"&gt;Sample Text &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-class', function() {&#13;
         expect(element('.doc-example-live span').prop('className')).not().&#13;
           toMatch(/ng-invalid/);&#13;
&#13;
         using('.doc-example-live').element(':button:first').click();&#13;
&#13;
         expect(element('.doc-example-live span').prop('className')).&#13;
           toMatch(/ng-invalid/);&#13;
&#13;
         using('.doc-example-live').element(':button:last').click();&#13;
&#13;
         expect(element('.doc-example-live span').prop('className')).not().&#13;
           toMatch(/ng-invalid/);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngClassDirective = classDirective('', true);&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-class-odd&#13;
 *&#13;
 * @description&#13;
 * The `ng-class-odd` and `ng-class-even` works exactly as&#13;
 * {@link angular.module.ng.$compileProvider.directive.ng-class ng-class}, except it works in conjunction with `ng-repeat` and&#13;
 * takes affect only on odd (even) rows.&#13;
 *&#13;
 * This directive can be applied only within a scope of an&#13;
 * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat}.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-class-odd {@link guide/dev_guide.expressions Expression} to eval. The result&#13;
 *   of the evaluation can be a string representing space delimited class names or an array.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
        &lt;ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']"&gt;&#13;
          &lt;li ng-repeat="name in names"&gt;&#13;
           &lt;span ng-class-odd="'ng-format-negative'"&#13;
                 ng-class-even="'ng-invalid'"&gt;&#13;
             {{name}} &amp;nbsp; &amp;nbsp; &amp;nbsp;&#13;
           &lt;/span&gt;&#13;
          &lt;/li&gt;&#13;
        &lt;/ol&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-class-odd and ng-class-even', function() {&#13;
         expect(element('.doc-example-live li:first span').prop('className')).&#13;
           toMatch(/ng-format-negative/);&#13;
         expect(element('.doc-example-live li:last span').prop('className')).&#13;
           toMatch(/ng-invalid/);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngClassOddDirective = classDirective('Odd', 0);&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-class-even&#13;
 *&#13;
 * @description&#13;
 * The `ng-class-odd` and `ng-class-even` works exactly as&#13;
 * {@link angular.module.ng.$compileProvider.directive.ng-class ng-class}, except it works in&#13;
 * conjunction with `ng-repeat` and takes affect only on odd (even) rows.&#13;
 *&#13;
 * This directive can be applied only within a scope of an&#13;
 * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat}.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-class-even {@link guide/dev_guide.expressions Expression} to eval. The&#13;
 *   result of the evaluation can be a string representing space delimited class names or an array.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
        &lt;ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']"&gt;&#13;
          &lt;li ng-repeat="name in names"&gt;&#13;
           &lt;span ng-class-odd="'odd'" ng-class-even="'even'"&gt;&#13;
             {{name}} &amp;nbsp; &amp;nbsp; &amp;nbsp;&#13;
           &lt;/span&gt;&#13;
          &lt;/li&gt;&#13;
        &lt;/ol&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-class-odd and ng-class-even', function() {&#13;
         expect(element('.doc-example-live li:first span').prop('className')).&#13;
           toMatch(/odd/);&#13;
         expect(element('.doc-example-live li:last span').prop('className')).&#13;
           toMatch(/even/);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngClassEvenDirective = classDirective('Even', 1);&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-cloak&#13;
 *&#13;
 * @description&#13;
 * The `ng-cloak` directive is used to prevent the Angular html template from being briefly&#13;
 * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this&#13;
 * directive to avoid the undesirable flicker effect caused by the html template display.&#13;
 *&#13;
 * The directive can be applied to the `&lt;body&gt;` element, but typically a fine-grained application is&#13;
 * prefered in order to benefit from progressive rendering of the browser view.&#13;
 *&#13;
 * `ng-cloak` works in cooperation with a css rule that is embedded within `angular.js` and&#13;
 *  `angular.min.js` files. Following is the css rule:&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 * [ng\:cloak], .ng-cloak {&#13;
 *   display: none;&#13;
 * }&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * When this css rule is loaded by the browser, all html elements (including their children) that&#13;
 * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive&#13;
 * during the compilation of the template it deletes the `ng-cloak` element attribute, which&#13;
 * makes the compiled element visible.&#13;
 *&#13;
 * For the best result, `angular.js` script must be loaded in the head section of the html file;&#13;
 * alternatively, the css rule (above) must be included in the external stylesheet of the&#13;
 * application.&#13;
 *&#13;
 * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they&#13;
 * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css&#13;
 * class `ng-cloak` in addition to `ng-cloak` directive as shown in the example below.&#13;
 *&#13;
 * @element ANY&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
        &lt;div id="template1" ng-cloak&gt;{{ 'hello' }}&lt;/div&gt;&#13;
        &lt;div id="template2" ng-cloak class="ng-cloak"&gt;{{ 'hello IE7' }}&lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should remove the template directive and css class', function() {&#13;
         expect(element('.doc-example-live #template1').attr('ng-cloak')).&#13;
           not().toBeDefined();&#13;
         expect(element('.doc-example-live #template2').attr('ng-cloak')).&#13;
           not().toBeDefined();&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 *&#13;
 */&#13;
var ngCloakDirective = ngDirective({&#13;
  compile: function(element, attr) {&#13;
    attr.$set('ngCloak', undefined);&#13;
    element.removeClass('ng-cloak');&#13;
  }&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-controller&#13;
 *&#13;
 * @description&#13;
 * The `ng-controller` directive assigns behavior to a scope. This is a key aspect of how angular&#13;
 * supports the principles behind the Model-View-Controller design pattern.&#13;
 *&#13;
 * MVC components in angular:&#13;
 *&#13;
 * * Model â€" The Model is data in scope properties; scopes are attached to the DOM.&#13;
 * * View â€" The template (HTML with data bindings) is rendered into the View.&#13;
 * * Controller â€" The `ng-controller` directive specifies a Controller class; the class has&#13;
 *   methods that typically express the business logic behind the application.&#13;
 *&#13;
 * Note that an alternative way to define controllers is via the `{@link angular.module.ng.$route}`&#13;
 * service.&#13;
 *&#13;
 * @element ANY&#13;
 * @scope&#13;
 * @param {expression} ng-controller Name of a globally accessible constructor function or an&#13;
 *     {@link guide/dev_guide.expressions expression} that on the current scope evaluates to a&#13;
 *     constructor function.&#13;
 *&#13;
 * @example&#13;
 * Here is a simple form for editing user contact information. Adding, removing, clearing, and&#13;
 * greeting are methods declared on the controller (see source tab). These methods can&#13;
 * easily be called from the angular markup. Notice that the scope becomes the `this` for the&#13;
 * controller's instance. This allows for easy access to the view data from the controller. Also&#13;
 * notice that any changes to the data are automatically reflected in the View without the need&#13;
 * for a manual update.&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
      &lt;script type="text/javascript"&gt;&#13;
        function SettingsController($scope) {&#13;
          $scope.name = "John Smith";&#13;
          $scope.contacts = [&#13;
            {type:'phone', value:'408 555 1212'},&#13;
            {type:'email', value:'john.smith@example.org'} ];&#13;
&#13;
          $scope.greet = function() {&#13;
           alert(this.name);&#13;
          };&#13;
&#13;
          $scope.addContact = function() {&#13;
           this.contacts.push({type:'email', value:'yourname@example.org'});&#13;
          };&#13;
&#13;
          $scope.removeContact = function(contactToRemove) {&#13;
           var index = this.contacts.indexOf(contactToRemove);&#13;
           this.contacts.splice(index, 1);&#13;
          };&#13;
&#13;
          $scope.clearContact = function(contact) {&#13;
           contact.type = 'phone';&#13;
           contact.value = '';&#13;
          };&#13;
        }&#13;
      &lt;/script&gt;&#13;
      &lt;div ng-controller="SettingsController"&gt;&#13;
        Name: &lt;input type="text" ng-model="name"/&gt;&#13;
        [ &lt;a href="" ng-click="greet()"&gt;greet&lt;/a&gt; ]&lt;br/&gt;&#13;
        Contact:&#13;
        &lt;ul&gt;&#13;
          &lt;li ng-repeat="contact in contacts"&gt;&#13;
            &lt;select ng-model="contact.type"&gt;&#13;
               &lt;option&gt;phone&lt;/option&gt;&#13;
               &lt;option&gt;email&lt;/option&gt;&#13;
            &lt;/select&gt;&#13;
            &lt;input type="text" ng-model="contact.value"/&gt;&#13;
            [ &lt;a href="" ng-click="clearContact(contact)"&gt;clear&lt;/a&gt;&#13;
            | &lt;a href="" ng-click="removeContact(contact)"&gt;X&lt;/a&gt; ]&#13;
          &lt;/li&gt;&#13;
          &lt;li&gt;[ &lt;a href="" ng-click="addContact()"&gt;add&lt;/a&gt; ]&lt;/li&gt;&#13;
       &lt;/ul&gt;&#13;
      &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check controller', function() {&#13;
         expect(element('.doc-example-live div&gt;:input').val()).toBe('John Smith');&#13;
         expect(element('.doc-example-live li:nth-child(1) input').val())&#13;
           .toBe('408 555 1212');&#13;
         expect(element('.doc-example-live li:nth-child(2) input').val())&#13;
           .toBe('john.smith@example.org');&#13;
&#13;
         element('.doc-example-live li:first a:contains("clear")').click();&#13;
         expect(element('.doc-example-live li:first input').val()).toBe('');&#13;
&#13;
         element('.doc-example-live li:last a:contains("add")').click();&#13;
         expect(element('.doc-example-live li:nth-child(3) input').val())&#13;
           .toBe('yourname@example.org');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngControllerDirective = [function() {&#13;
  return {&#13;
    scope: true,&#13;
    controller: '@'&#13;
  };&#13;
}];&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-click&#13;
 *&#13;
 * @description&#13;
 * The ng-click allows you to specify custom behavior when&#13;
 * element is clicked.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-click {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * click. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
      &lt;button ng-click="count = count + 1" ng-init="count=0"&gt;&#13;
        Increment&#13;
      &lt;/button&gt;&#13;
      count: {{count}}&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-click', function() {&#13;
         expect(binding('count')).toBe('0');&#13;
         element('.doc-example-live :button').click();&#13;
         expect(binding('count')).toBe('1');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
/*&#13;
 * A directive that allows creation of custom onclick handlers that are defined as angular&#13;
 * expressions and are compiled and executed within the current scope.&#13;
 *&#13;
 * Events that are handled via these handler are always configured not to propagate further.&#13;
 */&#13;
var ngEventDirectives = {};&#13;
forEach(&#13;
  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave'.split(' '),&#13;
  function(name) {&#13;
    var directiveName = directiveNormalize('ng-' + name);&#13;
    ngEventDirectives[directiveName] = ['$parse', function($parse) {&#13;
      return function(scope, element, attr) {&#13;
        var fn = $parse(attr[directiveName]);&#13;
        element.bind(lowercase(name), function(event) {&#13;
          scope.$apply(function() {&#13;
            fn(scope, {$event:event});&#13;
          });&#13;
        });&#13;
      };&#13;
    }];&#13;
  }&#13;
);&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-dblclick&#13;
 *&#13;
 * @description&#13;
 * The ng-dblclick allows you to specify custom behavior on dblclick event.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-dblclick {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * dblclick. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
 * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-mousedown&#13;
 *&#13;
 * @description&#13;
 * The ng-mousedown allows you to specify custom behavior on mousedown event.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-mousedown {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * mousedown. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
 * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-mouseup&#13;
 *&#13;
 * @description&#13;
 * Specify custom behavior on mouseup event.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-mouseup {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * mouseup. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
 * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}&#13;
 */&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-mouseover&#13;
 *&#13;
 * @description&#13;
 * Specify custom behavior on mouseover event.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-mouseover {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * mouseover. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
 * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-mouseenter&#13;
 *&#13;
 * @description&#13;
 * Specify custom behavior on mouseenter event.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-mouseenter {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * mouseenter. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
 * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-mouseleave&#13;
 *&#13;
 * @description&#13;
 * Specify custom behavior on mouseleave event.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-mouseleave {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * mouseleave. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
 * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-mousemove&#13;
 *&#13;
 * @description&#13;
 * Specify custom behavior on mousemove event.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-mousemove {@link guide/dev_guide.expressions Expression} to evaluate upon&#13;
 * mousemove. (Event object is available as `$event`)&#13;
 *&#13;
 * @example&#13;
 * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-submit&#13;
 *&#13;
 * @description&#13;
 * Enables binding angular expressions to onsubmit events.&#13;
 *&#13;
 * Additionally it prevents the default action (which for form means sending the request to the&#13;
 * server and reloading the current page).&#13;
 *&#13;
 * @element form&#13;
 * @param {expression} ng-submit {@link guide/dev_guide.expressions Expression} to eval.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
      &lt;script&gt;&#13;
        function Ctrl($scope) {&#13;
          $scope.list = [];&#13;
          $scope.text = 'hello';&#13;
          $scope.submit = function() {&#13;
            if (this.text) {&#13;
              this.list.push(this.text);&#13;
              this.text = '';&#13;
            }&#13;
          };&#13;
        }&#13;
      &lt;/script&gt;&#13;
      &lt;form ng-submit="submit()" ng-controller="Ctrl"&gt;&#13;
        Enter text and hit enter:&#13;
        &lt;input type="text" ng-model="text" name="text" /&gt;&#13;
        &lt;input type="submit" id="submit" value="Submit" /&gt;&#13;
        &lt;pre&gt;list={{list}}&lt;/pre&gt;&#13;
      &lt;/form&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-submit', function() {&#13;
         expect(binding('list')).toBe('[]');&#13;
         element('.doc-example-live #submit').click();&#13;
         expect(binding('list')).toBe('["hello"]');&#13;
         expect(input('text').val()).toBe('');&#13;
       });&#13;
       it('should ignore empty strings', function() {&#13;
         expect(binding('list')).toBe('[]');&#13;
         element('.doc-example-live #submit').click();&#13;
         element('.doc-example-live #submit').click();&#13;
         expect(binding('list')).toBe('["hello"]');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngSubmitDirective = ngDirective(function(scope, element, attrs) {&#13;
  element.bind('submit', function() {&#13;
    scope.$apply(attrs.ngSubmit);&#13;
  });&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-include&#13;
 * @restrict ECA&#13;
 *&#13;
 * @description&#13;
 * Fetches, compiles and includes an external HTML fragment.&#13;
 *&#13;
 * Keep in mind that Same Origin Policy applies to included resources&#13;
 * (e.g. ng-include won't work for file:// access).&#13;
 *&#13;
 * @scope&#13;
 *&#13;
 * @param {string} ng-include|src angular expression evaluating to URL. If the source is a string constant,&#13;
 *                 make sure you wrap it in quotes, e.g. `src="'myPartialTemplate.html'"`.&#13;
 * @param {string=} onload Expression to evaluate when a new partial is loaded.&#13;
 *&#13;
 * @param {string=} autoscroll Whether `ng-include` should call {@link angular.module.ng.$anchorScroll&#13;
 *                  $anchorScroll} to scroll the viewport after the content is loaded.&#13;
 *&#13;
 *                  - If the attribute is not set, disable scrolling.&#13;
 *                  - If the attribute is set without value, enable scrolling.&#13;
 *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source jsfiddle="false"&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.templates =&#13;
             [ { name: 'template1.html', url: 'examples/ng-include/template1.html'}&#13;
             , { name: 'template2.html', url: 'examples/ng-include/template2.html'} ];&#13;
           $scope.template = $scope.templates[0];&#13;
         }&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         &lt;select ng-model="template" ng-options="t.name for t in templates"&gt;&#13;
          &lt;option value=""&gt;(blank)&lt;/option&gt;&#13;
         &lt;/select&gt;&#13;
         url of the template: &lt;tt&gt;&lt;a href="{{template.url}}"&gt;{{template.url}}&lt;/a&gt;&lt;/tt&gt;&#13;
         &lt;hr/&gt;&#13;
         &lt;div ng-include src="template.url"&gt;&lt;/div&gt;&#13;
       &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should load template1.html', function() {&#13;
         expect(element('.doc-example-live [ng-include]').text()).&#13;
           toBe('Content of template1.html\n');&#13;
        });&#13;
        it('should load template2.html', function() {&#13;
         select('template').option('1');&#13;
         expect(element('.doc-example-live [ng-include]').text()).&#13;
           toBe('Content of template2.html\n');&#13;
        });&#13;
        it('should change to blank', function() {&#13;
         select('template').option('');&#13;
         expect(element('.doc-example-live [ng-include]').text()).toEqual('');&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc event&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-include#$includeContentLoaded&#13;
 * @eventOf angular.module.ng.$compileProvider.directive.ng-include&#13;
 * @eventType emit on the current ng-include scope&#13;
 * @description&#13;
 * Emitted every time the ng-include content is reloaded.&#13;
 */&#13;
var ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile',&#13;
                  function($http,   $templateCache,   $anchorScroll,   $compile) {&#13;
  return {&#13;
    restrict: 'ECA',&#13;
    terminal: true,&#13;
    compile: function(element, attr) {&#13;
      var srcExp = attr.ngInclude || attr.src,&#13;
          onloadExp = attr.onload || '',&#13;
          autoScrollExp = attr.autoscroll;&#13;
&#13;
      return function(scope, element, attr) {&#13;
        var changeCounter = 0,&#13;
            childScope;&#13;
&#13;
        var clearContent = function() {&#13;
          if (childScope) {&#13;
            childScope.$destroy();&#13;
            childScope = null;&#13;
          }&#13;
&#13;
          element.html('');&#13;
        };&#13;
&#13;
        scope.$watch(srcExp, function(src) {&#13;
          var thisChangeId = ++changeCounter;&#13;
&#13;
          if (src) {&#13;
            $http.get(src, {cache: $templateCache}).success(function(response) {&#13;
              if (thisChangeId !== changeCounter) return;&#13;
&#13;
              if (childScope) childScope.$destroy();&#13;
              childScope = scope.$new();&#13;
&#13;
              element.html(response);&#13;
              $compile(element.contents())(childScope);&#13;
&#13;
              if (isDefined(autoScrollExp) &amp;&amp; (!autoScrollExp || scope.$eval(autoScrollExp))) {&#13;
                $anchorScroll();&#13;
              }&#13;
&#13;
              childScope.$emit('$includeContentLoaded');&#13;
              scope.$eval(onloadExp);&#13;
            }).error(function() {&#13;
              if (thisChangeId === changeCounter) clearContent();&#13;
            });&#13;
          } else clearContent();&#13;
        });&#13;
      };&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-init&#13;
 *&#13;
 * @description&#13;
 * The `ng-init` attribute specifies initialization tasks to be executed&#13;
 *  before the template enters execution mode during bootstrap.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-init {@link guide/dev_guide.expressions Expression} to eval.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
    &lt;div ng-init="greeting='Hello'; person='World'"&gt;&#13;
      {{greeting}} {{person}}!&#13;
    &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check greeting', function() {&#13;
         expect(binding('greeting')).toBe('Hello');&#13;
         expect(binding('person')).toBe('World');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngInitDirective = ngDirective({&#13;
  compile: function() {&#13;
    return {&#13;
      pre: function(scope, element, attrs) {&#13;
        scope.$eval(attrs.ngInit);&#13;
      }&#13;
    }&#13;
  }&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-non-bindable&#13;
 * @priority 1000&#13;
 *&#13;
 * @description&#13;
 * Sometimes it is necessary to write code which looks like bindings but which should be left alone&#13;
 * by angular. Use `ng-non-bindable` to make angular ignore a chunk of HTML.&#13;
 *&#13;
 * @element ANY&#13;
 *&#13;
 * @example&#13;
 * In this example there are two location where a simple binding (`{{}}`) is present, but the one&#13;
 * wrapped in `ng-non-bindable` is left alone.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        &lt;div&gt;Normal: {{1 + 2}}&lt;/div&gt;&#13;
        &lt;div ng-non-bindable&gt;Ignored: {{1 + 2}}&lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
       it('should check ng-non-bindable', function() {&#13;
         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');&#13;
         expect(using('.doc-example-live').element('div:last').text()).&#13;
           toMatch(/1 \+ 2/);&#13;
       });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-pluralize&#13;
 * @restrict EA&#13;
 *&#13;
 * @description&#13;
 * # Overview&#13;
 * ng-pluralize is a directive that displays messages according to en-US localization rules.&#13;
 * These rules are bundled with angular.js and the rules can be overridden&#13;
 * (see {@link guide/dev_guide.i18n Angular i18n} dev guide). You configure ng-pluralize by&#13;
 * specifying the mappings between&#13;
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html&#13;
 * plural categories} and the strings to be displayed.&#13;
 *&#13;
 * # Plural categories and explicit number rules&#13;
 * There are two&#13;
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html&#13;
 * plural categories} in Angular's default en-US locale: "one" and "other".&#13;
 *&#13;
 * While a pural category may match many numbers (for example, in en-US locale, "other" can match&#13;
 * any number that is not 1), an explicit number rule can only match one number. For example, the&#13;
 * explicit number rule for "3" matches the number 3. You will see the use of plural categories&#13;
 * and explicit number rules throughout later parts of this documentation.&#13;
 *&#13;
 * # Configuring ng-pluralize&#13;
 * You configure ng-pluralize by providing 2 attributes: `count` and `when`.&#13;
 * You can also provide an optional attribute, `offset`.&#13;
 *&#13;
 * The value of the `count` attribute can be either a string or an {@link guide/dev_guide.expressions&#13;
 * Angular expression}; these are evaluated on the current scope for its binded value.&#13;
 *&#13;
 * The `when` attribute specifies the mappings between plural categories and the actual&#13;
 * string to be displayed. The value of the attribute should be a JSON object so that Angular&#13;
 * can interpret it correctly.&#13;
 *&#13;
 * The following example shows how to configure ng-pluralize:&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 * &lt;ng-pluralize count="personCount"&#13;
                 when="{'0': 'Nobody is viewing.',&#13;
 *                      'one': '1 person is viewing.',&#13;
 *                      'other': '{} people are viewing.'}"&gt;&#13;
 * &lt;/ng-pluralize&gt;&#13;
 *&lt;/pre&gt;&#13;
 *&#13;
 * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not&#13;
 * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"&#13;
 * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for&#13;
 * other numbers, for example 12, so that instead of showing "12 people are viewing", you can&#13;
 * show "a dozen people are viewing".&#13;
 *&#13;
 * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted&#13;
 * into pluralized strings. In the previous example, Angular will replace `{}` with&#13;
 * &lt;span ng-non-bindable&gt;`{{personCount}}`&lt;/span&gt;. The closed braces `{}` is a placeholder&#13;
 * for &lt;span ng-non-bindable&gt;{{numberExpression}}&lt;/span&gt;.&#13;
 *&#13;
 * # Configuring ng-pluralize with offset&#13;
 * The `offset` attribute allows further customization of pluralized text, which can result in&#13;
 * a better user experience. For example, instead of the message "4 people are viewing this document",&#13;
 * you might display "John, Kate and 2 others are viewing this document".&#13;
 * The offset attribute allows you to offset a number by any desired value.&#13;
 * Let's take a look at an example:&#13;
 *&#13;
 * &lt;pre&gt;&#13;
 * &lt;ng-pluralize count="personCount" offset=2&#13;
 *               when="{'0': 'Nobody is viewing.',&#13;
 *                      '1': '{{person1}} is viewing.',&#13;
 *                      '2': '{{person1}} and {{person2}} are viewing.',&#13;
 *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',&#13;
 *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}"&gt;&#13;
 * &lt;/ng-pluralize&gt;&#13;
 * &lt;/pre&gt;&#13;
 *&#13;
 * Notice that we are still using two plural categories(one, other), but we added&#13;
 * three explicit number rules 0, 1 and 2.&#13;
 * When one person, perhaps John, views the document, "John is viewing" will be shown.&#13;
 * When three people view the document, no explicit number rule is found, so&#13;
 * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.&#13;
 * In this case, plural category 'one' is matched and "John, Marry and one other person are viewing"&#13;
 * is shown.&#13;
 *&#13;
 * Note that when you specify offsets, you must provide explicit number rules for&#13;
 * numbers from 0 up to and including the offset. If you use an offset of 3, for example,&#13;
 * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for&#13;
 * plural categories "one" and "other".&#13;
 *&#13;
 * @param {string|expression} count The variable to be bounded to.&#13;
 * @param {string} when The mapping between plural category to its correspoding strings.&#13;
 * @param {number=} offset Offset to deduct from the total number.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        &lt;script&gt;&#13;
          function Ctrl($scope) {&#13;
            $scope.person1 = 'Igor';&#13;
            $scope.person2 = 'Misko';&#13;
            $scope.personCount = 1;&#13;
          }&#13;
        &lt;/script&gt;&#13;
        &lt;div ng-controller="Ctrl"&gt;&#13;
          Person 1:&lt;input type="text" ng-model="person1" value="Igor" /&gt;&lt;br/&gt;&#13;
          Person 2:&lt;input type="text" ng-model="person2" value="Misko" /&gt;&lt;br/&gt;&#13;
          Number of People:&lt;input type="text" ng-model="personCount" value="1" /&gt;&lt;br/&gt;&#13;
&#13;
          &lt;!--- Example with simple pluralization rules for en locale ---&gt;&#13;
          Without Offset:&#13;
          &lt;ng-pluralize count="personCount"&#13;
                        when="{'0': 'Nobody is viewing.',&#13;
                               'one': '1 person is viewing.',&#13;
                               'other': '{} people are viewing.'}"&gt;&#13;
          &lt;/ng-pluralize&gt;&lt;br&gt;&#13;
&#13;
          &lt;!--- Example with offset ---&gt;&#13;
          With Offset(2):&#13;
          &lt;ng-pluralize count="personCount" offset=2&#13;
                        when="{'0': 'Nobody is viewing.',&#13;
                               '1': '{{person1}} is viewing.',&#13;
                               '2': '{{person1}} and {{person2}} are viewing.',&#13;
                               'one': '{{person1}}, {{person2}} and one other person are viewing.',&#13;
                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}"&gt;&#13;
          &lt;/ng-pluralize&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should show correct pluralized string', function() {&#13;
          expect(element('.doc-example-live ng-pluralize:first').text()).&#13;
                                             toBe('1 person is viewing.');&#13;
          expect(element('.doc-example-live ng-pluralize:last').text()).&#13;
                                                toBe('Igor is viewing.');&#13;
&#13;
          using('.doc-example-live').input('personCount').enter('0');&#13;
          expect(element('.doc-example-live ng-pluralize:first').text()).&#13;
                                               toBe('Nobody is viewing.');&#13;
          expect(element('.doc-example-live ng-pluralize:last').text()).&#13;
                                              toBe('Nobody is viewing.');&#13;
&#13;
          using('.doc-example-live').input('personCount').enter('2');&#13;
          expect(element('.doc-example-live ng-pluralize:first').text()).&#13;
                                            toBe('2 people are viewing.');&#13;
          expect(element('.doc-example-live ng-pluralize:last').text()).&#13;
                              toBe('Igor and Misko are viewing.');&#13;
&#13;
          using('.doc-example-live').input('personCount').enter('3');&#13;
          expect(element('.doc-example-live ng-pluralize:first').text()).&#13;
                                            toBe('3 people are viewing.');&#13;
          expect(element('.doc-example-live ng-pluralize:last').text()).&#13;
                              toBe('Igor, Misko and one other person are viewing.');&#13;
&#13;
          using('.doc-example-live').input('personCount').enter('4');&#13;
          expect(element('.doc-example-live ng-pluralize:first').text()).&#13;
                                            toBe('4 people are viewing.');&#13;
          expect(element('.doc-example-live ng-pluralize:last').text()).&#13;
                              toBe('Igor, Misko and 2 other people are viewing.');&#13;
        });&#13;
&#13;
        it('should show data-binded names', function() {&#13;
          using('.doc-example-live').input('personCount').enter('4');&#13;
          expect(element('.doc-example-live ng-pluralize:last').text()).&#13;
              toBe('Igor, Misko and 2 other people are viewing.');&#13;
&#13;
          using('.doc-example-live').input('person1').enter('Di');&#13;
          using('.doc-example-live').input('person2').enter('Vojta');&#13;
          expect(element('.doc-example-live ng-pluralize:last').text()).&#13;
              toBe('Di, Vojta and 2 other people are viewing.');&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {&#13;
  var BRACE = /{}/g;&#13;
  return {&#13;
    restrict: 'EA',&#13;
    link: function(scope, element, attr) {&#13;
      var numberExp = attr.count,&#13;
          whenExp = element.attr(attr.$attr.when), // this is because we have {{}} in attrs&#13;
          offset = attr.offset || 0,&#13;
          whens = scope.$eval(whenExp),&#13;
          whensExpFns = {};&#13;
&#13;
      forEach(whens, function(expression, key) {&#13;
        whensExpFns[key] =&#13;
          $interpolate(expression.replace(BRACE, '{{' + numberExp + '-' + offset + '}}'));&#13;
      });&#13;
&#13;
      scope.$watch(function() {&#13;
        var value = parseFloat(scope.$eval(numberExp));&#13;
&#13;
        if (!isNaN(value)) {&#13;
          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,&#13;
          //check it against pluralization rules in $locale service&#13;
          if (!whens[value]) value = $locale.pluralCat(value - offset);&#13;
           return whensExpFns[value](scope, element, true);&#13;
        } else {&#13;
          return '';&#13;
        }&#13;
      }, function(newVal) {&#13;
        element.text(newVal);&#13;
      });&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-repeat&#13;
 *&#13;
 * @description&#13;
 * The `ng-repeat` directive instantiates a template once per item from a collection. Each template&#13;
 * instance gets its own scope, where the given loop variable is set to the current collection item,&#13;
 * and `$index` is set to the item index or key.&#13;
 *&#13;
 * Special properties are exposed on the local scope of each template instance, including:&#13;
 *&#13;
 *   * `$index` â€" `{number}` â€" iterator offset of the repeated element (0..length-1)&#13;
 *   * `$position` â€" `{string}` â€" position of the repeated element in the iterator. One of:&#13;
 *        * `'first'`,&#13;
 *        * `'middle'`&#13;
 *        * `'last'`&#13;
 *&#13;
 *&#13;
 * @element ANY&#13;
 * @scope&#13;
 * @priority 1000&#13;
 * @param {repeat_expression} ng-repeat The expression indicating how to enumerate a collection. Two&#13;
 *   formats are currently supported:&#13;
 *&#13;
 *   * `variable in expression` â€" where variable is the user defined loop variable and `expression`&#13;
 *     is a scope expression giving the collection to enumerate.&#13;
 *&#13;
 *     For example: `track in cd.tracks`.&#13;
 *&#13;
 *   * `(key, value) in expression` â€" where `key` and `value` can be any user defined identifiers,&#13;
 *     and `expression` is the scope expression giving the collection to enumerate.&#13;
 *&#13;
 *     For example: `(name, age) in {'adam':10, 'amalie':12}`.&#13;
 *&#13;
 * @example&#13;
 * This example initializes the scope to a list of names and&#13;
 * then uses `ng-repeat` to display every person:&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        &lt;div ng-init="friends = [{name:'John', age:25}, {name:'Mary', age:28}]"&gt;&#13;
          I have {{friends.length}} friends. They are:&#13;
          &lt;ul&gt;&#13;
            &lt;li ng-repeat="friend in friends"&gt;&#13;
              [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.&#13;
            &lt;/li&gt;&#13;
          &lt;/ul&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
         it('should check ng-repeat', function() {&#13;
           var r = using('.doc-example-live').repeater('ul li');&#13;
           expect(r.count()).toBe(2);&#13;
           expect(r.row(0)).toEqual(["1","John","25"]);&#13;
           expect(r.row(1)).toEqual(["2","Mary","28"]);&#13;
         });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
var ngRepeatDirective = ngDirective({&#13;
  transclude: 'element',&#13;
  priority: 1000,&#13;
  terminal: true,&#13;
  compile: function(element, attr, linker) {&#13;
    return function(scope, iterStartElement, attr){&#13;
      var expression = attr.ngRepeat;&#13;
      var match = expression.match(/^\s*(.+)\s+in\s+(.*)\s*$/),&#13;
        lhs, rhs, valueIdent, keyIdent;&#13;
      if (! match) {&#13;
        throw Error("Expected ng-repeat in form of '_item_ in _collection_' but got '" +&#13;
          expression + "'.");&#13;
      }&#13;
      lhs = match[1];&#13;
      rhs = match[2];&#13;
      match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);&#13;
      if (!match) {&#13;
        throw Error("'item' in 'item in collection' should be identifier or (key, value) but got '" +&#13;
            lhs + "'.");&#13;
      }&#13;
      valueIdent = match[3] || match[1];&#13;
      keyIdent = match[2];&#13;
&#13;
      // Store a list of elements from previous run. This is a hash where key is the item from the&#13;
      // iterator, and the value is an array of objects with following properties.&#13;
      //   - scope: bound scope&#13;
      //   - element: previous element.&#13;
      //   - index: position&#13;
      // We need an array of these objects since the same object can be returned from the iterator.&#13;
      // We expect this to be a rare case.&#13;
      var lastOrder = new HashQueueMap();&#13;
      scope.$watch(function(scope){&#13;
        var index, length,&#13;
            collection = scope.$eval(rhs),&#13;
            collectionLength = size(collection, true),&#13;
            childScope,&#13;
            // Same as lastOrder but it has the current state. It will become the&#13;
            // lastOrder on the next iteration.&#13;
            nextOrder = new HashQueueMap(),&#13;
            key, value, // key/value of iteration&#13;
            array, last,       // last object information {scope, element, index}&#13;
            cursor = iterStartElement;     // current position of the node&#13;
&#13;
        if (!isArray(collection)) {&#13;
          // if object, extract keys, sort them and use to determine order of iteration over obj props&#13;
          array = [];&#13;
          for(key in collection) {&#13;
            if (collection.hasOwnProperty(key) &amp;&amp; key.charAt(0) != '$') {&#13;
              array.push(key);&#13;
            }&#13;
          }&#13;
          array.sort();&#13;
        } else {&#13;
          array = collection || [];&#13;
        }&#13;
&#13;
        // we are not using forEach for perf reasons (trying to avoid #call)&#13;
        for (index = 0, length = array.length; index &lt; length; index++) {&#13;
          key = (collection === array) ? index : array[index];&#13;
          value = collection[key];&#13;
          last = lastOrder.shift(value);&#13;
          if (last) {&#13;
            // if we have already seen this object, then we need to reuse the&#13;
            // associated scope/element&#13;
            childScope = last.scope;&#13;
            nextOrder.push(value, last);&#13;
&#13;
            if (index === last.index) {&#13;
              // do nothing&#13;
              cursor = last.element;&#13;
            } else {&#13;
              // existing item which got moved&#13;
              last.index = index;&#13;
              // This may be a noop, if the element is next, but I don't know of a good way to&#13;
              // figure this out,  since it would require extra DOM access, so let's just hope that&#13;
              // the browsers realizes that it is noop, and treats it as such.&#13;
              cursor.after(last.element);&#13;
              cursor = last.element;&#13;
            }&#13;
          } else {&#13;
            // new item which we don't know about&#13;
            childScope = scope.$new();&#13;
          }&#13;
&#13;
          childScope[valueIdent] = value;&#13;
          if (keyIdent) childScope[keyIdent] = key;&#13;
          childScope.$index = index;&#13;
          childScope.$position = index === 0 ?&#13;
              'first' :&#13;
              (index == collectionLength - 1 ? 'last' : 'middle');&#13;
&#13;
          if (!last) {&#13;
            linker(childScope, function(clone){&#13;
              cursor.after(clone);&#13;
              last = {&#13;
                  scope: childScope,&#13;
                  element: (cursor = clone),&#13;
                  index: index&#13;
                };&#13;
              nextOrder.push(value, last);&#13;
            });&#13;
          }&#13;
        }&#13;
&#13;
        //shrink children&#13;
        for (key in lastOrder) {&#13;
          if (lastOrder.hasOwnProperty(key)) {&#13;
            array = lastOrder[key];&#13;
            while(array.length) {&#13;
              value = array.pop();&#13;
              value.element.remove();&#13;
              value.scope.$destroy();&#13;
            }&#13;
          }&#13;
        }&#13;
&#13;
        lastOrder = nextOrder;&#13;
      });&#13;
    };&#13;
  }&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-show&#13;
 *&#13;
 * @description&#13;
 * The `ng-show` and `ng-hide` directives show or hide a portion of the DOM tree (HTML)&#13;
 * conditionally.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-show If the {@link guide/dev_guide.expressions expression} is truthy&#13;
 *     then the element is shown or hidden respectively.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
        Click me: &lt;input type="checkbox" ng-model="checked"&gt;&lt;br/&gt;&#13;
        Show: &lt;span ng-show="checked"&gt;I show up when your checkbox is checked.&lt;/span&gt; &lt;br/&gt;&#13;
        Hide: &lt;span ng-hide="checked"&gt;I hide when your checkbox is checked.&lt;/span&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-show / ng-hide', function() {&#13;
         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);&#13;
         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);&#13;
&#13;
         input('checked').check();&#13;
&#13;
         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);&#13;
         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
//TODO(misko): refactor to remove element from the DOM&#13;
var ngShowDirective = ngDirective(function(scope, element, attr){&#13;
  scope.$watch(attr.ngShow, function(value){&#13;
    element.css('display', toBoolean(value) ? '' : 'none');&#13;
  });&#13;
});&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-hide&#13;
 *&#13;
 * @description&#13;
 * The `ng-hide` and `ng-show` directives hide or show a portion&#13;
 * of the HTML conditionally.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-hide If the {@link guide/dev_guide.expressions expression} truthy then&#13;
 *     the element is shown or hidden respectively.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
        Click me: &lt;input type="checkbox" ng-model="checked"&gt;&lt;br/&gt;&#13;
        Show: &lt;span ng-show="checked"&gt;I show up when you checkbox is checked?&lt;/span&gt; &lt;br/&gt;&#13;
        Hide: &lt;span ng-hide="checked"&gt;I hide when you checkbox is checked?&lt;/span&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-show / ng-hide', function() {&#13;
         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);&#13;
         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);&#13;
&#13;
         input('checked').check();&#13;
&#13;
         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);&#13;
         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
//TODO(misko): refactor to remove element from the DOM&#13;
var ngHideDirective = ngDirective(function(scope, element, attr){&#13;
  scope.$watch(attr.ngHide, function(value){&#13;
    element.css('display', toBoolean(value) ? 'none' : '');&#13;
  });&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-style&#13;
 *&#13;
 * @description&#13;
 * The ng-style allows you to set CSS style on an HTML element conditionally.&#13;
 *&#13;
 * @element ANY&#13;
 * @param {expression} ng-style {@link guide/dev_guide.expressions Expression} which evals to an&#13;
 *      object whose keys are CSS style names and values are corresponding values for those CSS&#13;
 *      keys.&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example&gt;&#13;
     &lt;doc:source&gt;&#13;
        &lt;input type="button" value="set" ng-click="myStyle={color:'red'}"&gt;&#13;
        &lt;input type="button" value="clear" ng-click="myStyle={}"&gt;&#13;
        &lt;br/&gt;&#13;
        &lt;span ng-style="myStyle"&gt;Sample Text&lt;/span&gt;&#13;
        &lt;pre&gt;myStyle={{myStyle}}&lt;/pre&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
       it('should check ng-style', function() {&#13;
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');&#13;
         element('.doc-example-live :button[value=set]').click();&#13;
         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');&#13;
         element('.doc-example-live :button[value=clear]').click();&#13;
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');&#13;
       });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 */&#13;
var ngStyleDirective = ngDirective(function(scope, element, attr) {&#13;
  scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {&#13;
    if (oldStyles &amp;&amp; (newStyles !== oldStyles)) {&#13;
      forEach(oldStyles, function(val, style) { element.css(style, '');});&#13;
    }&#13;
    if (newStyles) element.css(newStyles);&#13;
  }, true);&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-switch&#13;
 * @restrict EA&#13;
 *&#13;
 * @description&#13;
 * Conditionally change the DOM structure.&#13;
 *&#13;
 * @usageContent&#13;
 * &lt;any ng-switch-when="matchValue1"&gt;...&lt;/any&gt;&#13;
 *   &lt;any ng-switch-when="matchValue2"&gt;...&lt;/any&gt;&#13;
 *   ...&#13;
 *   &lt;any ng-switch-default&gt;...&lt;/any&gt;&#13;
 *&#13;
 * @scope&#13;
 * @param {*} ng-switch|on expression to match against &lt;tt&gt;ng-switch-when&lt;/tt&gt;.&#13;
 * @paramDescription&#13;
 * On child elments add:&#13;
 *&#13;
 * * `ng-switch-when`: the case statement to match against. If match then this&#13;
 *   case will be displayed.&#13;
 * * `ng-switch-default`: the default case when no other casses match.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        &lt;script&gt;&#13;
          function Ctrl($scope) {&#13;
            $scope.items = ['settings', 'home', 'other'];&#13;
            $scope.selection = $scope.items[0];&#13;
          }&#13;
        &lt;/script&gt;&#13;
        &lt;div ng-controller="Ctrl"&gt;&#13;
          &lt;select ng-model="selection" ng-options="item for item in items"&gt;&#13;
          &lt;/select&gt;&#13;
          &lt;tt&gt;selection={{selection}}&lt;/tt&gt;&#13;
          &lt;hr/&gt;&#13;
          &lt;div ng-switch on="selection" &gt;&#13;
            &lt;div ng-switch-when="settings"&gt;Settings Div&lt;/div&gt;&#13;
            &lt;span ng-switch-when="home"&gt;Home Span&lt;/span&gt;&#13;
            &lt;span ng-switch-default&gt;default&lt;/span&gt;&#13;
          &lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should start in settings', function() {&#13;
         expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);&#13;
        });&#13;
        it('should change to home', function() {&#13;
         select('selection').option('home');&#13;
         expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);&#13;
        });&#13;
        it('should select deafault', function() {&#13;
         select('selection').option('other');&#13;
         expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
var NG_SWITCH = 'ng-switch';&#13;
var ngSwitchDirective = valueFn({&#13;
  restrict: 'EA',&#13;
  compile: function(element, attr) {&#13;
    var watchExpr = attr.ngSwitch || attr.on,&#13;
        cases = {};&#13;
&#13;
    element.data(NG_SWITCH, cases);&#13;
    return function(scope, element){&#13;
      var selectedTransclude,&#13;
          selectedElement,&#13;
          selectedScope;&#13;
&#13;
      scope.$watch(watchExpr, function(value) {&#13;
        if (selectedElement) {&#13;
          selectedScope.$destroy();&#13;
          selectedElement.remove();&#13;
          selectedElement = selectedScope = null;&#13;
        }&#13;
        if ((selectedTransclude = cases['!' + value] || cases['?'])) {&#13;
          scope.$eval(attr.change);&#13;
          selectedScope = scope.$new();&#13;
          selectedTransclude(selectedScope, function(caseElement) {&#13;
            selectedElement = caseElement;&#13;
            element.append(caseElement);&#13;
          });&#13;
        }&#13;
      });&#13;
    };&#13;
  }&#13;
});&#13;
&#13;
var ngSwitchWhenDirective = ngDirective({&#13;
  transclude: 'element',&#13;
  priority: 500,&#13;
  compile: function(element, attrs, transclude) {&#13;
    var cases = element.inheritedData(NG_SWITCH);&#13;
    assertArg(cases);&#13;
    cases['!' + attrs.ngSwitchWhen] = transclude;&#13;
  }&#13;
});&#13;
&#13;
var ngSwitchDefaultDirective = ngDirective({&#13;
  transclude: 'element',&#13;
  priority: 500,&#13;
  compile: function(element, attrs, transclude) {&#13;
    var cases = element.inheritedData(NG_SWITCH);&#13;
    assertArg(cases);&#13;
    cases['?'] = transclude;&#13;
  }&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-transclude&#13;
 *&#13;
 * @description&#13;
 * Insert the transcluded DOM here.&#13;
 *&#13;
 * @element ANY&#13;
 *&#13;
 * @example&#13;
   &lt;doc:example module="transclude"&gt;&#13;
     &lt;doc:source&gt;&#13;
       &lt;script&gt;&#13;
         function Ctrl($scope) {&#13;
           $scope.title = 'Lorem Ipsum';&#13;
           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';&#13;
         }&#13;
&#13;
         angular.module('transclude', [])&#13;
          .directive('pane', function(){&#13;
             return {&#13;
               restrict: 'E',&#13;
               transclude: true,&#13;
               scope: 'isolate',&#13;
               locals: { title:'bind' },&#13;
               template: '&lt;div style="border: 1px solid black;"&gt;' +&#13;
                           '&lt;div style="background-color: gray"&gt;{{title}}&lt;/div&gt;' +&#13;
                           '&lt;div ng-transclude&gt;&lt;/div&gt;' +&#13;
                         '&lt;/div&gt;'&#13;
             };&#13;
         });&#13;
       &lt;/script&gt;&#13;
       &lt;div ng-controller="Ctrl"&gt;&#13;
         &lt;input ng-model="title"&gt;&lt;br&gt;&#13;
         &lt;textarea ng-model="text"&gt;&lt;/textarea&gt; &lt;br/&gt;&#13;
         &lt;pane title="{{title}}"&gt;{{text}}&lt;/pane&gt;&#13;
       &lt;/div&gt;&#13;
     &lt;/doc:source&gt;&#13;
     &lt;doc:scenario&gt;&#13;
        it('should have transcluded', function() {&#13;
          input('title').enter('TITLE');&#13;
          input('text').enter('TEXT');&#13;
          expect(binding('title')).toEqual('TITLE');&#13;
          expect(binding('text')).toEqual('TEXT');&#13;
        });&#13;
     &lt;/doc:scenario&gt;&#13;
   &lt;/doc:example&gt;&#13;
 *&#13;
 */&#13;
var ngTranscludeDirective = ngDirective({&#13;
  controller: ['$transclude', '$element', function($transclude, $element) {&#13;
    $transclude(function(clone) {&#13;
      $element.append(clone);&#13;
    });&#13;
  }]&#13;
});&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-view&#13;
 * @restrict ECA&#13;
 *&#13;
 * @description&#13;
 * # Overview&#13;
 * `ng-view` is a directive that complements the {@link angular.module.ng.$route $route} service by&#13;
 * including the rendered template of the current route into the main layout (`index.html`) file.&#13;
 * Every time the current route changes, the included view changes with it according to the&#13;
 * configuration of the `$route` service.&#13;
 *&#13;
 * @scope&#13;
 * @example&#13;
    &lt;doc:example module="ngView"&gt;&#13;
      &lt;doc:source&gt;&#13;
        &lt;script type="text/ng-template" id="examples/book.html"&gt;&#13;
          controller: {{name}}&lt;br /&gt;&#13;
          Book Id: {{params.bookId}}&lt;br /&gt;&#13;
        &lt;/script&gt;&#13;
&#13;
        &lt;script type="text/ng-template" id="examples/chapter.html"&gt;&#13;
          controller: {{name}}&lt;br /&gt;&#13;
          Book Id: {{params.bookId}}&lt;br /&gt;&#13;
          Chapter Id: {{params.chapterId}}&#13;
        &lt;/script&gt;&#13;
&#13;
        &lt;script&gt;&#13;
          angular.module('ngView', [], function($routeProvider, $locationProvider) {&#13;
            $routeProvider.when('/Book/:bookId', {&#13;
              template: 'examples/book.html',&#13;
              controller: BookCntl&#13;
            });&#13;
            $routeProvider.when('/Book/:bookId/ch/:chapterId', {&#13;
              template: 'examples/chapter.html',&#13;
              controller: ChapterCntl&#13;
            });&#13;
&#13;
            // configure html5 to get links working on jsfiddle&#13;
            $locationProvider.html5Mode(true);&#13;
          });&#13;
&#13;
          function MainCntl($scope, $route, $routeParams, $location) {&#13;
            $scope.$route = $route;&#13;
            $scope.$location = $location;&#13;
            $scope.$routeParams = $routeParams;&#13;
          }&#13;
&#13;
          function BookCntl($scope, $routeParams) {&#13;
            $scope.name = "BookCntl";&#13;
            $scope.params = $routeParams;&#13;
          }&#13;
&#13;
          function ChapterCntl($scope, $routeParams) {&#13;
            $scope.name = "ChapterCntl";&#13;
            $scope.params = $routeParams;&#13;
          }&#13;
        &lt;/script&gt;&#13;
&#13;
        &lt;div ng-controller="MainCntl"&gt;&#13;
          Choose:&#13;
          &lt;a href="/Book/Moby"&gt;Moby&lt;/a&gt; |&#13;
          &lt;a href="/Book/Moby/ch/1"&gt;Moby: Ch1&lt;/a&gt; |&#13;
          &lt;a href="/Book/Gatsby"&gt;Gatsby&lt;/a&gt; |&#13;
          &lt;a href="/Book/Gatsby/ch/4?key=value"&gt;Gatsby: Ch4&lt;/a&gt; |&#13;
          &lt;a href="/Book/Scarlet"&gt;Scarlet Letter&lt;/a&gt;&lt;br/&gt;&#13;
&#13;
          &lt;div ng-view&gt;&lt;/div&gt;&#13;
          &lt;hr /&gt;&#13;
&#13;
          &lt;pre&gt;$location.path() = {{$location.path()}}&lt;/pre&gt;&#13;
          &lt;pre&gt;$route.current.template = {{$route.current.template}}&lt;/pre&gt;&#13;
          &lt;pre&gt;$route.current.params = {{$route.current.params}}&lt;/pre&gt;&#13;
          &lt;pre&gt;$route.current.scope.name = {{$route.current.scope.name}}&lt;/pre&gt;&#13;
          &lt;pre&gt;$routeParams = {{$routeParams}}&lt;/pre&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
        it('should load and compile correct template', function() {&#13;
          element('a:contains("Moby: Ch1")').click();&#13;
          var content = element('.doc-example-live [ng-view]').text();&#13;
          expect(content).toMatch(/controller\: ChapterCntl/);&#13;
          expect(content).toMatch(/Book Id\: Moby/);&#13;
          expect(content).toMatch(/Chapter Id\: 1/);&#13;
&#13;
          element('a:contains("Scarlet")').click();&#13;
          content = element('.doc-example-live [ng-view]').text();&#13;
          expect(content).toMatch(/controller\: BookCntl/);&#13;
          expect(content).toMatch(/Book Id\: Scarlet/);&#13;
        });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * @ngdoc event&#13;
 * @name angular.module.ng.$compileProvider.directive.ng-view#$viewContentLoaded&#13;
 * @eventOf angular.module.ng.$compileProvider.directive.ng-view&#13;
 * @eventType emit on the current ng-view scope&#13;
 * @description&#13;
 * Emitted every time the ng-view content is reloaded.&#13;
 */&#13;
var ngViewDirective = ['$http', '$templateCache', '$route', '$anchorScroll', '$compile',&#13;
                       '$controller',&#13;
               function($http,   $templateCache,   $route,   $anchorScroll,   $compile,&#13;
                        $controller) {&#13;
  return {&#13;
    restrict: 'ECA',&#13;
    terminal: true,&#13;
    link: function(scope, element, attr) {&#13;
      var changeCounter = 0,&#13;
          lastScope,&#13;
          onloadExp = attr.onload || '';&#13;
&#13;
      scope.$on('$afterRouteChange', update);&#13;
      update();&#13;
&#13;
&#13;
      function destroyLastScope() {&#13;
        if (lastScope) {&#13;
          lastScope.$destroy();&#13;
          lastScope = null;&#13;
        }&#13;
      }&#13;
&#13;
      function update() {&#13;
        var template = $route.current &amp;&amp; $route.current.template,&#13;
            thisChangeId = ++changeCounter;&#13;
&#13;
        function clearContent() {&#13;
          // ignore callback if another route change occured since&#13;
          if (thisChangeId === changeCounter) {&#13;
            element.html('');&#13;
            destroyLastScope();&#13;
          }&#13;
        }&#13;
&#13;
        if (template) {&#13;
          $http.get(template, {cache: $templateCache}).success(function(response) {&#13;
            // ignore callback if another route change occured since&#13;
            if (thisChangeId === changeCounter) {&#13;
              element.html(response);&#13;
              destroyLastScope();&#13;
&#13;
              var link = $compile(element.contents()),&#13;
                  current = $route.current,&#13;
                  controller;&#13;
&#13;
              lastScope = current.scope = scope.$new();&#13;
              if (current.controller) {&#13;
                controller = $controller(current.controller, {$scope: lastScope});&#13;
                element.contents().data('$ngControllerController', controller);&#13;
              }&#13;
&#13;
              link(lastScope);&#13;
              lastScope.$emit('$viewContentLoaded');&#13;
              lastScope.$eval(onloadExp);&#13;
&#13;
              // $anchorScroll might listen on event...&#13;
              $anchorScroll();&#13;
            }&#13;
          }).error(clearContent);&#13;
        } else {&#13;
          clearContent();&#13;
        }&#13;
      }&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.script&#13;
 *&#13;
 * @description&#13;
 * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the&#13;
 * template can be used by `ng-include`, `ng-view` or directive templates.&#13;
 *&#13;
 * @restrict E&#13;
 * @param {'text/ng-template'} type must be set to `'text/ng-template'`&#13;
 *&#13;
 * @example&#13;
  &lt;doc:example&gt;&#13;
    &lt;doc:source&gt;&#13;
      &lt;script type="text/ng-template" id="/tpl.html"&gt;&#13;
        Content of the template.&#13;
      &lt;/script&gt;&#13;
&#13;
      &lt;a ng-click="currentTpl='/tpl.html'" id="tpl-link"&gt;Load inlined template&lt;/a&gt;&#13;
      &lt;div id="tpl-content" ng-include src="currentTpl"&gt;&lt;/div&gt;&#13;
    &lt;/doc:source&gt;&#13;
    &lt;doc:scenario&gt;&#13;
      it('should load template defined inside script tag', function() {&#13;
        element('#tpl-link').click();&#13;
        expect(element('#tpl-content').text()).toMatch(/Content of the template/);&#13;
      });&#13;
    &lt;/doc:scenario&gt;&#13;
  &lt;/doc:example&gt;&#13;
 */&#13;
var scriptDirective = ['$templateCache', function($templateCache) {&#13;
  return {&#13;
    restrict: 'E',&#13;
    terminal: true,&#13;
    compile: function(element, attr) {&#13;
      if (attr.type == 'text/ng-template') {&#13;
        var templateUrl = attr.id;&#13;
        $templateCache.put(templateUrl, element.text());&#13;
      }&#13;
    }&#13;
  };&#13;
}];&#13;
&#13;
/**&#13;
 * @ngdoc directive&#13;
 * @name angular.module.ng.$compileProvider.directive.select&#13;
 * @restrict E&#13;
 *&#13;
 * @description&#13;
 * HTML `SELECT` element with angular data-binding.&#13;
 *&#13;
 * # `ng-options`&#13;
 *&#13;
 * Optionally `ng-options` attribute can be used to dynamically generate a list of `&lt;option&gt;`&#13;
 * elements for a `&lt;select&gt;` element using an array or an object obtained by evaluating the&#13;
 * `ng-options` expression.&#13;
 *Ë&#157;Ë&#157;&#13;
 * When an item in the select menu is select, the value of array element or object property&#13;
 * represented by the selected option will be bound to the model identified by the `ng-model` attribute&#13;
 * of the parent select element.&#13;
 *&#13;
 * Optionally, a single hard-coded `&lt;option&gt;` element, with the value set to an empty string, can&#13;
 * be nested into the `&lt;select&gt;` element. This element will then represent `null` or "not selected"&#13;
 * option. See example below for demonstration.&#13;
 *&#13;
 * Note: `ng-options` provides iterator facility for `&lt;option&gt;` element which must be used instead&#13;
 * of {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat}. `ng-repeat` is not suitable for use with&#13;
 * `&lt;option&gt;` element because of the following reasons:&#13;
 *&#13;
 *   * value attribute of the option element that we need to bind to requires a string, but the&#13;
 *     source of data for the iteration might be in a form of array containing objects instead of&#13;
 *     strings&#13;
 *   * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat} unrolls after the select binds causing&#13;
 *     incorect rendering on most browsers.&#13;
 *   * binding to a value not in list confuses most browsers.&#13;
 *&#13;
 * @param {string} name assignable expression to data-bind to.&#13;
 * @param {string=} required The control is considered valid only if value is entered.&#13;
 * @param {comprehension_expression=} ng-options in one of the following forms:&#13;
 *&#13;
 *   * for array data sources:&#13;
 *     * `label` **`for`** `value` **`in`** `array`&#13;
 *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`&#13;
 *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`&#13;
 *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array`&#13;
 *   * for object data sources:&#13;
 *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`&#13;
 *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`&#13;
 *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`&#13;
 *     * `select` **`as`** `label` **`group by`** `group`&#13;
 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`&#13;
 *&#13;
 * Where:&#13;
 *&#13;
 *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.&#13;
 *   * `value`: local variable which will refer to each item in the `array` or each property value&#13;
 *      of `object` during iteration.&#13;
 *   * `key`: local variable which will refer to a property name in `object` during iteration.&#13;
 *   * `label`: The result of this expression will be the label for `&lt;option&gt;` element. The&#13;
 *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).&#13;
 *   * `select`: The result of this expression will be bound to the model of the parent `&lt;select&gt;`&#13;
 *      element. If not specified, `select` expression will default to `value`.&#13;
 *   * `group`: The result of this expression will be used to group options using the `&lt;optgroup&gt;`&#13;
 *      DOM element.&#13;
 *&#13;
 * @example&#13;
    &lt;doc:example&gt;&#13;
      &lt;doc:source&gt;&#13;
        &lt;script&gt;&#13;
        function MyCntrl($scope) {&#13;
          $scope.colors = [&#13;
            {name:'black', shade:'dark'},&#13;
            {name:'white', shade:'light'},&#13;
            {name:'red', shade:'dark'},&#13;
            {name:'blue', shade:'dark'},&#13;
            {name:'yellow', shade:'light'}&#13;
          ];&#13;
          $scope.color = $scope.colors[2]; // red&#13;
        }&#13;
        &lt;/script&gt;&#13;
        &lt;div ng-controller="MyCntrl"&gt;&#13;
          &lt;ul&gt;&#13;
            &lt;li ng-repeat="color in colors"&gt;&#13;
              Name: &lt;input ng-model="color.name"&gt;&#13;
              [&lt;a href ng-click="colors.$remove(color)"&gt;X&lt;/a&gt;]&#13;
            &lt;/li&gt;&#13;
            &lt;li&gt;&#13;
              [&lt;a href ng-click="colors.push({})"&gt;add&lt;/a&gt;]&#13;
            &lt;/li&gt;&#13;
          &lt;/ul&gt;&#13;
          &lt;hr/&gt;&#13;
          Color (null not allowed):&#13;
          &lt;select ng-model="color" ng-options="c.name for c in colors"&gt;&lt;/select&gt;&lt;br&gt;&#13;
&#13;
          Color (null allowed):&#13;
          &lt;div  class="nullable"&gt;&#13;
            &lt;select ng-model="color" ng-options="c.name for c in colors"&gt;&#13;
              &lt;option value=""&gt;-- chose color --&lt;/option&gt;&#13;
            &lt;/select&gt;&#13;
          &lt;/div&gt;&lt;br/&gt;&#13;
&#13;
          Color grouped by shade:&#13;
          &lt;select ng-model="color" ng-options="c.name group by c.shade for c in colors"&gt;&#13;
          &lt;/select&gt;&lt;br/&gt;&#13;
&#13;
&#13;
          Select &lt;a href ng-click="color={name:'not in list'}"&gt;bogus&lt;/a&gt;.&lt;br&gt;&#13;
          &lt;hr/&gt;&#13;
          Currently selected: {{ {selected_color:color}  }}&#13;
          &lt;div style="border:solid 1px black; height:20px"&#13;
               ng-style="{'background-color':color.name}"&gt;&#13;
          &lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/doc:source&gt;&#13;
      &lt;doc:scenario&gt;&#13;
         it('should check ng-options', function() {&#13;
           expect(binding('{selected_color:color}')).toMatch('red');&#13;
           select('color').option('0');&#13;
           expect(binding('{selected_color:color}')).toMatch('black');&#13;
           using('.nullable').select('color').option('');&#13;
           expect(binding('{selected_color:color}')).toMatch('null');&#13;
         });&#13;
      &lt;/doc:scenario&gt;&#13;
    &lt;/doc:example&gt;&#13;
 */&#13;
&#13;
var ngOptionsDirective = valueFn({ terminal: true });&#13;
var selectDirective = ['$compile', '$parse', function($compile,   $parse) {&#13;
                         //00001111100000000000222200000000000000000000003333000000000000044444444444444444000000000555555555555555550000000666666666666666660000000000000007777&#13;
  var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/;&#13;
&#13;
  return {&#13;
    restrict: 'E',&#13;
    require: '?ngModel',&#13;
    link: function(scope, element, attr, ctrl) {&#13;
      if (!ctrl) return;&#13;
&#13;
      var multiple = attr.multiple,&#13;
          optionsExp = attr.ngOptions;&#13;
&#13;
      // required validator&#13;
      if (multiple &amp;&amp; (attr.required || attr.ngRequired)) {&#13;
        var requiredValidator = function(value) {&#13;
          ctrl.$setValidity('required', !attr.required || (value &amp;&amp; value.length));&#13;
          return value;&#13;
        };&#13;
&#13;
        ctrl.$parsers.push(requiredValidator);&#13;
        ctrl.$formatters.unshift(requiredValidator);&#13;
&#13;
        attr.$observe('required', function() {&#13;
          requiredValidator(ctrl.$viewValue);&#13;
        });&#13;
      }&#13;
&#13;
      if (optionsExp) Options(scope, element, ctrl);&#13;
      else if (multiple) Multiple(scope, element, ctrl);&#13;
      else Single(scope, element, ctrl);&#13;
&#13;
&#13;
      ////////////////////////////&#13;
&#13;
&#13;
&#13;
      function Single(scope, selectElement, ctrl) {&#13;
        ctrl.$render = function() {&#13;
          selectElement.val(ctrl.$viewValue);&#13;
        };&#13;
&#13;
        selectElement.bind('change', function() {&#13;
          scope.$apply(function() {&#13;
            ctrl.$setViewValue(selectElement.val());&#13;
          });&#13;
        });&#13;
      }&#13;
&#13;
      function Multiple(scope, selectElement, ctrl) {&#13;
        var lastView;&#13;
        ctrl.$render = function() {&#13;
          var items = new HashMap(ctrl.$viewValue);&#13;
          forEach(selectElement.children(), function(option) {&#13;
            option.selected = isDefined(items.get(option.value));&#13;
          });&#13;
        };&#13;
&#13;
        // we have to do it on each watch since ng-model watches reference, but&#13;
        // we need to work of an array, so we need to see if anything was inserted/removed&#13;
        scope.$watch(function() {&#13;
          if (!equals(lastView, ctrl.$viewValue)) {&#13;
            lastView = copy(ctrl.$viewValue);&#13;
            ctrl.$render();&#13;
          }&#13;
        });&#13;
&#13;
        selectElement.bind('change', function() {&#13;
          scope.$apply(function() {&#13;
            var array = [];&#13;
            forEach(selectElement.children(), function(option) {&#13;
              if (option.selected) {&#13;
                array.push(option.value);&#13;
              }&#13;
            });&#13;
            ctrl.$setViewValue(array);&#13;
          });&#13;
        });&#13;
      }&#13;
&#13;
      function Options(scope, selectElement, ctrl) {&#13;
        var match;&#13;
&#13;
        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {&#13;
          throw Error(&#13;
            "Expected ng-options in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +&#13;
            " but got '" + optionsExp + "'.");&#13;
        }&#13;
&#13;
        var displayFn = $parse(match[2] || match[1]),&#13;
            valueName = match[4] || match[6],&#13;
            keyName = match[5],&#13;
            groupByFn = $parse(match[3] || ''),&#13;
            valueFn = $parse(match[2] ? match[1] : valueName),&#13;
            valuesFn = $parse(match[7]),&#13;
            // we can't just jqLite('&lt;option&gt;') since jqLite is not smart enough&#13;
            // to create it in &lt;select&gt; and IE barfs otherwise.&#13;
            optionTemplate = jqLite(document.createElement('option')),&#13;
            optGroupTemplate = jqLite(document.createElement('optgroup')),&#13;
            nullOption = false, // if false then user will not be able to select it&#13;
            // This is an array of array of existing option groups in DOM. We try to reuse these if possible&#13;
            // optionGroupsCache[0] is the options with no option group&#13;
            // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element&#13;
            optionGroupsCache = [[{element: selectElement, label:''}]];&#13;
&#13;
        // find existing special options&#13;
        forEach(selectElement.children(), function(option) {&#13;
          if (option.value == '') {&#13;
            // developer declared null option, so user should be able to select it&#13;
            nullOption = jqLite(option).remove();&#13;
            // compile the element since there might be bindings in it&#13;
            $compile(nullOption)(scope);&#13;
          }&#13;
        });&#13;
        selectElement.html(''); // clear contents&#13;
&#13;
        selectElement.bind('change', function() {&#13;
          scope.$apply(function() {&#13;
            var optionGroup,&#13;
                collection = valuesFn(scope) || [],&#13;
                locals = {},&#13;
                key, value, optionElement, index, groupIndex, length, groupLength;&#13;
&#13;
            if (multiple) {&#13;
              value = [];&#13;
              for (groupIndex = 0, groupLength = optionGroupsCache.length;&#13;
              groupIndex &lt; groupLength;&#13;
              groupIndex++) {&#13;
                // list of options for that group. (first item has the parent)&#13;
                optionGroup = optionGroupsCache[groupIndex];&#13;
&#13;
                for(index = 1, length = optionGroup.length; index &lt; length; index++) {&#13;
                  if ((optionElement = optionGroup[index].element)[0].selected) {&#13;
                    key = optionElement.val();&#13;
                    if (keyName) locals[keyName] = key;&#13;
                    locals[valueName] = collection[key];&#13;
                    value.push(valueFn(scope, locals));&#13;
                  }&#13;
                }&#13;
              }&#13;
            } else {&#13;
              key = selectElement.val();&#13;
              if (key == '?') {&#13;
                value = undefined;&#13;
              } else if (key == ''){&#13;
                value = null;&#13;
              } else {&#13;
                locals[valueName] = collection[key];&#13;
                if (keyName) locals[keyName] = key;&#13;
                value = valueFn(scope, locals);&#13;
              }&#13;
            }&#13;
            ctrl.$setViewValue(value);&#13;
          });&#13;
        });&#13;
&#13;
        ctrl.$render = render;&#13;
&#13;
        // TODO(vojta): can't we optimize this ?&#13;
        scope.$watch(render);&#13;
&#13;
        function render() {&#13;
          var optionGroups = {'':[]}, // Temporary location for the option groups before we render them&#13;
              optionGroupNames = [''],&#13;
              optionGroupName,&#13;
              optionGroup,&#13;
              option,&#13;
              existingParent, existingOptions, existingOption,&#13;
              modelValue = ctrl.$modelValue,&#13;
              values = valuesFn(scope) || [],&#13;
              keys = keyName ? sortedKeys(values) : values,&#13;
              groupLength, length,&#13;
              groupIndex, index,&#13;
              locals = {},&#13;
              selected,&#13;
              selectedSet = false, // nothing is selected yet&#13;
              lastElement,&#13;
              element;&#13;
&#13;
          if (multiple) {&#13;
            selectedSet = new HashMap(modelValue);&#13;
          } else if (modelValue === null || nullOption) {&#13;
            // if we are not multiselect, and we are null then we have to add the nullOption&#13;
            optionGroups[''].push({selected:modelValue === null, id:'', label:''});&#13;
            selectedSet = true;&#13;
          }&#13;
&#13;
          // We now build up the list of options we need (we merge later)&#13;
          for (index = 0; length = keys.length, index &lt; length; index++) {&#13;
               locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];&#13;
               optionGroupName = groupByFn(scope, locals) || '';&#13;
            if (!(optionGroup = optionGroups[optionGroupName])) {&#13;
              optionGroup = optionGroups[optionGroupName] = [];&#13;
              optionGroupNames.push(optionGroupName);&#13;
            }&#13;
            if (multiple) {&#13;
              selected = selectedSet.remove(valueFn(scope, locals)) != undefined;&#13;
            } else {&#13;
              selected = modelValue === valueFn(scope, locals);&#13;
              selectedSet = selectedSet || selected; // see if at least one item is selected&#13;
            }&#13;
            optionGroup.push({&#13;
              id: keyName ? keys[index] : index,   // either the index into array or key from object&#13;
              label: displayFn(scope, locals) || '', // what will be seen by the user&#13;
              selected: selected                   // determine if we should be selected&#13;
            });&#13;
          }&#13;
          if (!multiple &amp;&amp; !selectedSet) {&#13;
            // nothing was selected, we have to insert the undefined item&#13;
            optionGroups[''].unshift({id:'?', label:'', selected:true});&#13;
          }&#13;
&#13;
          // Now we need to update the list of DOM nodes to match the optionGroups we computed above&#13;
          for (groupIndex = 0, groupLength = optionGroupNames.length;&#13;
               groupIndex &lt; groupLength;&#13;
               groupIndex++) {&#13;
            // current option group name or '' if no group&#13;
            optionGroupName = optionGroupNames[groupIndex];&#13;
&#13;
            // list of options for that group. (first item has the parent)&#13;
            optionGroup = optionGroups[optionGroupName];&#13;
&#13;
            if (optionGroupsCache.length &lt;= groupIndex) {&#13;
              // we need to grow the optionGroups&#13;
              existingParent = {&#13;
                element: optGroupTemplate.clone().attr('label', optionGroupName),&#13;
                label: optionGroup.label&#13;
              };&#13;
              existingOptions = [existingParent];&#13;
              optionGroupsCache.push(existingOptions);&#13;
              selectElement.append(existingParent.element);&#13;
            } else {&#13;
              existingOptions = optionGroupsCache[groupIndex];&#13;
              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element&#13;
&#13;
              // update the OPTGROUP label if not the same.&#13;
              if (existingParent.label != optionGroupName) {&#13;
                existingParent.element.attr('label', existingParent.label = optionGroupName);&#13;
              }&#13;
            }&#13;
&#13;
            lastElement = null;  // start at the begining&#13;
            for(index = 0, length = optionGroup.length; index &lt; length; index++) {&#13;
              option = optionGroup[index];&#13;
              if ((existingOption = existingOptions[index+1])) {&#13;
                // reuse elements&#13;
                lastElement = existingOption.element;&#13;
                if (existingOption.label !== option.label) {&#13;
                  lastElement.text(existingOption.label = option.label);&#13;
                }&#13;
                if (existingOption.id !== option.id) {&#13;
                  lastElement.val(existingOption.id = option.id);&#13;
                }&#13;
                if (existingOption.element.selected !== option.selected) {&#13;
                  lastElement.prop('selected', (existingOption.selected = option.selected));&#13;
                }&#13;
              } else {&#13;
                // grow elements&#13;
&#13;
                // if it's a null option&#13;
                if (option.id === '' &amp;&amp; nullOption) {&#13;
                  // put back the pre-compiled element&#13;
                  element = nullOption;&#13;
                } else {&#13;
                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but&#13;
                  // in this version of jQuery on some browser the .text() returns a string&#13;
                  // rather then the element.&#13;
                  (element = optionTemplate.clone())&#13;
                      .val(option.id)&#13;
                      .attr('selected', option.selected)&#13;
                      .text(option.label);&#13;
                }&#13;
&#13;
                existingOptions.push(existingOption = {&#13;
                    element: element,&#13;
                    label: option.label,&#13;
                    id: option.id,&#13;
                    selected: option.selected&#13;
                });&#13;
                if (lastElement) {&#13;
                  lastElement.after(element);&#13;
                } else {&#13;
                  existingParent.element.append(element);&#13;
                }&#13;
                lastElement = element;&#13;
              }&#13;
            }&#13;
            // remove any excessive OPTIONs in a group&#13;
            index++; // increment since the existingOptions[0] is parent element not OPTION&#13;
            while(existingOptions.length &gt; index) {&#13;
              existingOptions.pop().element.remove();&#13;
            }&#13;
          }&#13;
          // remove any excessive OPTGROUPs from select&#13;
          while(optionGroupsCache.length &gt; groupIndex) {&#13;
            optionGroupsCache.pop()[0].element.remove();&#13;
          }&#13;
        };&#13;
      }&#13;
    }&#13;
  }&#13;
}];&#13;
&#13;
var optionDirective = ['$interpolate', function($interpolate) {&#13;
  return {&#13;
    restrict: 'E',&#13;
    priority: 100,&#13;
    compile: function(element, attr) {&#13;
      if (isUndefined(attr.value)) {&#13;
        var interpolateFn = $interpolate(element.text(), true);&#13;
        if (interpolateFn) {&#13;
          return function (scope, element, attr) {&#13;
            scope.$watch(interpolateFn, function(value) {&#13;
              attr.$set('value', value);&#13;
            });&#13;
          }&#13;
        } else {&#13;
          attr.$set('value', element.text());&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
}];&#13;
&#13;
var styleDirective = valueFn({&#13;
  restrict: 'E',&#13;
  terminal: true&#13;
});&#13;
  //try to bind to jquery now so that one can write angular.element().read()&#13;
  //but we will rebind on bootstrap again.&#13;
  bindJQuery();&#13;
&#13;
  publishExternalAPI(angular);&#13;
&#13;
  jqLite(document).ready(function() {&#13;
    angularInit(document, bootstrap);&#13;
  });&#13;
&#13;
})(window, document);&#13;
angular.element(document).find('head').append('&lt;style type="text/css"&gt;@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}&lt;/style&gt;');</script>
        <script_name>angular-1.0.0rc4</script_name>
        <sys_class_name>sys_ui_script</sys_class_name>
        <sys_created_by>hung.nguyen@rumbleasia.com</sys_created_by>
        <sys_created_on>2016-08-16 08:01:31</sys_created_on>
        <sys_customer_update>true</sys_customer_update>
        <sys_id>416f130d37d56200b816daa543990ebc</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>x_rugl_barcode.angular-1.0.0rc4</sys_name>
        <sys_package display_value="Barcode" source="x_rugl_barcode">6ff2892b6f09a20029726af6ad3ee447</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Barcode">6ff2892b6f09a20029726af6ad3ee447</sys_scope>
        <sys_update_name>sys_ui_script_416f130d37d56200b816daa543990ebc</sys_update_name>
        <sys_updated_by>hung.nguyen@rumbleasia.com</sys_updated_by>
        <sys_updated_on>2016-08-16 08:01:31</sys_updated_on>
        <use_scoped_format>false</use_scoped_format>
    </sys_ui_script>
</record_update>
